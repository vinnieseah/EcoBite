import { ethers, InterfaceAbi as InterfaceAbi$1 } from 'ethers';
export { ethers as vechain_sdk_core_ethers } from 'ethers';
import { Input, NestedUint8Array } from '@ethereumjs/rlp';
import { ObjectErrorData } from '@vechain/sdk-errors';
import * as n_bip32 from '@scure/bip32';

/**
 * Represents a wrapped Param Type for ethers.js types.
 */
type ParamType = ethers.ParamType;

/**
 * Represents a wrapped Function Fragment for ethers.js types.
 */
type FunctionFragment = ethers.FunctionFragment;

/**
 * Represents a wrapped Event Fragment for ethers.js types.
 */
type EventFragment = ethers.EventFragment;

/**
 * Represents a wrapped Interface for ethers.js types.
 */
type Interface = ethers.Interface;

/**
 * Represents a wrapped InterfaceAbi for ethers.js types.
 */
type InterfaceAbi = ethers.InterfaceAbi;

/**
 * Represents a wrapped Result for ethers.js types.
 * It represents the decoded data from a transaction (after decoding).
 */
type Result = ethers.Result;

/**
 * Represents a wrapped Log description for ethers.js types.
 * It represents the decoded data from a log (after decoding).
 */
type Log = ethers.LogDescription;

/**
 * Represents a wrapped BytesLike for ethers.js types.
 */
type BytesLike = ethers.BytesLike;

/**
 * Represents a wrapped FormatType for ethers.js types.
 * It is used to represents the format of the signature of a function.
 */
type FormatType = ethers.FormatType;

/**
 * Represents a function call in the Event/Function ABI.
 *
 * @template ABIType - The ABI fragment type.
 */
declare class Function<ABIType> {
    /**
     * The main fragment handled by ethers.js.
     *
     */
    fragment: FunctionFragment;
    /**
     * The main interface handled by ethers.js.
     */
    iface: Interface;
    /**
     * Creates a new Function instance from an ABI fragment.
     *
     * @param source - ABI fragment to use.
     * @throws {InvalidAbiFragment}
     */
    constructor(source: ABIType);
    /**
     * Get the signature hash of the function.
     *
     * @returns The signature hash of the function.
     */
    signatureHash(): string;
    /**
     * Get the signature of the function.
     *
     * @param formatType - The format type of the signature: 'sighash', 'minimal', 'full', or 'json'.
     * @returns The signature of the function.
     */
    signature(formatType: FormatType): string;
    /**
     * Decode data using the function's ABI.
     *
     * @param data - Data to decode.
     * @returns Decoding results.
     * @throws {InvalidAbiDataToEncodeOrDecode}
     */
    decodeInput(data: BytesLike): Result;
    /**
     * Decodes the output data from a transaction based on ABI (Application Binary Interface) specifications.
     * This method attempts to decode the given byte-like data into a readable format using the contract's interface.
     *
     * @param data - The `BytesLike` data to be decoded, typically representing the output of a contract function call.
     * @returns A `Result` object containing the decoded data.
     * @throws {InvalidAbiDataToEncodeOrDecode}
     *
     * @example
     * ```typescript
     *   const decoded = contractInstance.decodeOutput(rawTransactionOutput);
     *   console.log('Decoded Output:', decoded);
     * ```
     */
    decodeOutput(data: BytesLike): Result;
    /**
     * Encode data using the function's ABI.
     *
     * @param dataToEncode - Data to encode.
     * @returns Encoded data.
     * @throws {InvalidAbiDataToEncodeOrDecode}
     */
    encodeInput<TValue>(dataToEncode?: TValue[]): string;
}
/**
 * Represents an event call in the Event/Function ABI.
 *
 * @template ABIType - The ABI fragment type.
 */
declare class Event<ABIType> {
    /**
     * The main fragment handled by ethers.js.
     */
    fragment: EventFragment;
    /**
     * The main interface handled by ethers.js.
     */
    iface: Interface;
    /**
     * Creates a new Event instance from an ABI fragment.
     *
     * @param source - ABI fragment to use.
     * @throws {InvalidAbiFragment}
     */
    constructor(source: ABIType);
    /**
     * Get the signature hash of the event.
     *
     * @returns The signature hash of the event.
     */
    signatureHash(): string;
    /**
     * Get the signature of the event.
     *
     * @param formatType - The format type of the signature: 'sighash', 'minimal', 'full', or 'json'.
     * @returns The signature of the event.
     */
    signature(formatType: FormatType): string;
    /**
     * Decode event log data using the event's ABI.
     *
     * @param data - Data to decode.
     * @returns Decoding results.
     * @throws {InvalidAbiDataToEncodeOrDecode}
     */
    decodeEventLog(data: {
        data: string;
        topics: string[];
    }): Result;
    /**
     * Encode event log data using the event's ABI.
     *
     * @param dataToEncode - Data to encode.
     * @returns Encoded data along with topics.
     * @throws {InvalidAbiDataToEncodeOrDecode}
     */
    encodeEventLog<TValue>(dataToEncode: TValue[]): {
        data: string;
        topics: string[];
    };
    /**
     * Encode event log topics using the event's ABI.
     *
     * @param valuesToEncode - values to encode as topics. Non-indexed values are ignored.
     *                         Only the values of the indexed parameters are needed.
     * @returns Encoded topics array.
     * @throws {InvalidAbiDataToEncodeOrDecode}
     */
    encodeFilterTopics<TValue>(valuesToEncode: TValue[]): Array<string | undefined>;
}
/**
 * Object containing ABI representations.
 */
declare const fragment: {
    Function: typeof Function;
    Event: typeof Event;
};

/**
 * Encodes a parameter value.
 *
 * @note `ValueType` is used to explicitly specify the type of the value to encode.
 *
 * @param type - Type of the parameter.
 * @param value - Value to encode.
 * @returns Encoded parameter as a hexadecimal string.
 * @throws {InvalidAbiDataToEncodeOrDecode}
 */
declare function encode$2<ValueType>(type: string | ParamType, value: ValueType): string;
/**
 * Encodes the given values according to the specified ABI types.
 *
 * @param types - An array of ABI types or an array of ParamType objects representing the types of the values to encode.
 * @param values - An array of values to be encoded according to the specified ABI types.
 * @returns The ABI-encoded string representing the given values.
 * @throws {InvalidAbiDataToEncodeOrDecode}
 *
 * @template ValueType - The type of the values being encoded.
 *
 * @example
 * ```typescript
 * const abiTypes = ['uint256', 'address'];
 * const values = [123, '0x1234567890123456789012345678901234567890'];
 * const encodedParams = encodeParams(abiTypes, values);
 * console.log(encodedParams);
 * ```
 */
declare function encodeParams(types: string[] | ParamType[], values: string[]): string;
/**
 * Decodes a parameter value.
 *
 * @note `ReturnType` is used to explicitly specify the return type (the decoded value) of the function.
 *
 * @param types - Types of parameters.
 * @param data - Data to decode.
 * @returns Decoded parameter value.
 * @throws {InvalidAbiDataToEncodeOrDecode}
 */
declare function decode$2<ReturnType>(types: string | ParamType, data: BytesLike): ReturnType;
/**
 * Object containing ABI representations.
 */
declare const abi: {
    encode: typeof encode$2;
    encodeParams: typeof encodeParams;
    decode: typeof decode$2;
    Function: {
        new <ABIType>(source: ABIType): {
            fragment: FunctionFragment;
            iface: Interface;
            signatureHash(): string;
            signature(formatType: FormatType): string;
            decodeInput(data: BytesLike): Result;
            decodeOutput(data: BytesLike): Result;
            encodeInput<TValue>(dataToEncode?: TValue[]): string;
        };
    };
    Event: {
        new <ABIType>(source: ABIType): {
            fragment: EventFragment;
            iface: Interface;
            signatureHash(): string;
            signature(formatType: FormatType): string;
            decodeEventLog(data: {
                data: string;
                topics: string[];
            }): Result;
            encodeEventLog<TValue>(dataToEncode: TValue[]): {
                data: string;
                topics: string[];
            };
            encodeFilterTopics<TValue>(valuesToEncode: TValue[]): Array<string | undefined>;
        };
    };
};

/**
 * Creates a new Interface instance from an ABI fragment.
 * @param abi - ABI in a compatible format
 * @returns The Interface instance.
 */
declare function createInterface(abi: InterfaceAbi$1): Interface;
/**
 * Encode function data that can be used to send a transaction.
 * @param interfaceABI ABI in a compatible format
 * @param functionName The name of the function defined in the ABI.
 * @param functionData The data to pass to the function.
 * @returns The encoded data that can be used to send a transaction.
 * @throws {InvalidAbiDataToEncodeOrDecode}
 */
declare function encodeFunctionInput(interfaceABI: InterfaceAbi$1, functionName: string, functionData?: unknown[]): string;
/**
 * Decode the function data of an encoded function
 * @param interfaceABI ABI in a compatible format
 * @param functionName The name of the function defined in the ABI.
 * @param encodedFunctionInput The encoded function data.
 * @returns an array of the decoded function data
 * @throws {InvalidAbiDataToEncodeOrDecode}
 */
declare function decodeFunctionInput(interfaceABI: InterfaceAbi$1, functionName: string, encodedFunctionInput: BytesLike): Result;
/**
 * Decodes the output from a contract function using the specified ABI and function name.
 * It takes the encoded function output and attempts to decode it according to the ABI definition.
 *
 * @param {InterfaceAbi} interfaceABI - The ABI (Application Binary Interface) of the contract,
 *                                      which defines how data is structured in the blockchain.
 * @param {string} functionName - The name of the function in the contract to decode the output for.
 * @param encodedFunctionOutput - The encoded output data from the contract function.
 * @returns {Result} - The decoded output as a Result object, which provides a user-friendly way
 *                     to interact with the decoded data.
 * @throws {InvalidAbiDataToEncodeOrDecode}
 *
 * @example
 * // Example of decoding output for a function called "getValue":
 * const decodedOutput = decodeFunctionOutput(contractABI, 'getValue', encodedValue);
 *
 */
declare function decodeFunctionOutput(interfaceABI: InterfaceAbi$1, functionName: string, encodedFunctionOutput: BytesLike): Result;
/**
 * Encodes event log data based on the provided contract interface ABI, event name, and data to encode.
 * @param interfaceABI - The ABI (Application Binary Interface) of the contract.
 * @param eventName - The name of the event to be encoded.
 * @param dataToEncode - An array of data to be encoded in the event log.
 * @returns An object containing the encoded data and topics.
 * @throws {InvalidAbiDataToEncodeOrDecode}
 */
declare function encodeEventLog(interfaceABI: InterfaceAbi$1, eventName: string, dataToEncode: unknown[]): {
    data: string;
    topics: string[];
};
/**
 * Decodes event log data based on the provided contract interface ABI, event name, and data/topics to decode.
 * @param interfaceABI - The ABI (Application Binary Interface) of the contract.
 * @param eventName - The name of the event to be decoded.
 * @param dataToDecode - An object containing the data and topics to be decoded.
 * @returns The decoded data of the event log.
 * @throws {InvalidAbiDataToEncodeOrDecode}
 */
declare function decodeEventLog(interfaceABI: InterfaceAbi$1, eventName: string, dataToDecode: {
    data: string;
    topics: string[];
}): Result;
/**
 * Decodes an Ethereum log based on the ABI definition.
 *
 * This method takes raw `data` and `topics` from an Ethereum log and attempts
 * to decode them using the contract's ABI definition. If the decoding is successful,
 * it returns a `Log` object representing the decoded information. If the decoding fails,
 * it throws a custom error with detailed information.
 *
 * @param interfaceABI - The ABI (Application Binary Interface) of the contract.
 * @param {string} data - The hexadecimal string of the data field in the log.
 * @param {string[]} topics - An array of hexadecimal strings representing the topics of the log.
 * @returns {Log | null} - A `Log` object representing the decoded log or null if decoding fails.
 * @throws {InvalidAbiDataToEncodeOrDecode}
 */
declare function parseLog(interfaceABI: InterfaceAbi$1, data: string, topics: string[]): Log | null;
declare const coder: {
    createInterface: typeof createInterface;
    encodeFunctionInput: typeof encodeFunctionInput;
    decodeFunctionInput: typeof decodeFunctionInput;
    decodeFunctionOutput: typeof decodeFunctionOutput;
    encodeEventLog: typeof encodeEventLog;
    decodeEventLog: typeof decodeEventLog;
    parseLog: typeof parseLog;
};

/**
 * In the VeChainThor blockchain, a certificate is a data structure used for client-side self-signed certificates.
 * It plays a crucial role in providing a mechanism for secure identification and validation of data.
 *
 * Certificates are primarily used for purposes like attestation, validation, and verification of data authenticity.
 * They are used as proofs of authenticity and origin for data exchanged within the VeChain ecosystem.
 */
interface Certificate {
    /**
     * The purpose field indicates the intended use or context of the certificate.
     * For example, it could be used for identification, verification, or attestation.
     */
    purpose: string;

    /**
     * The payload field holds the actual content of the certificate.
     * This content can be of various types, such as text, images, or other data.
     */
    payload: {
        type: string;
        content: string;
    };

    /**
     * The domain field represents the specific context or domain for which the certificate is valid.
     * It helps ensure that the certificate is only applicable within the intended context.
     */
    domain: string;

    /**
     * The timestamp field records the time at which the certificate was created or issued.
     * This provides a temporal reference for the certificate's validity.
     */
    timestamp: number;

    /**
     * The signer field indicates the address of the entity that signs the certificate.
     * It is the public key address of the entity that issues the certificate.
     */
    signer: string;

    /**
     * The signature field contains the cryptographic signature generated by the issuer's private key.
     * This signature ensures the integrity and authenticity of the certificate's content.
     */
    signature?: string;
}

/**
 * Encodes a certificate object to an array of bytes of its JSON representation after the following
 * normalization operations are applied:
 * * only the properties defined in the {@link Certificate} interface are evaluated;
 * * the properties are sorted in ascending alphabetic order;
 * * the key/value properties are delimited with `"`;
 * * any not meaningful blank characters are ignored;
 * * the `signer` property is a hexadecimal address represented lowercase to back compatible with the certificates
 *   not implementing the [EIP/ERC-55: Mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55);
 * * the UTF-8 code is normalized according the
 *   [normalization form for canonical composition](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms)
 *
 * @param {Certificate} cert - The certificate object to encode.
 * @return {Uint8Array} - The byte encoded certificate.
 *
 *
 * @see {https://www.npmjs.com/package/fast-json-stable-stringify fastJsonStableStringify}
 * @see {sign}
 * @see {verify}
 */
declare function encode$1(cert: Certificate): Uint8Array;
/**
 * Signs a certificate using a private key.
 *
 * The signature is computed encoding the certificate according the following normalization rules:
 * * only the properties defined in the {@link Certificate} interface are evaluated;
 * * the properties are sorted in ascending alphabetic order;
 * * the key/value properties are delimited with `"`;
 * * any not meaningful blank characters are ignored;
 * * the `signer` property is a hexadecimal address represented lowercase to back compatible with the certificates
 *   not implementing the [EIP/ERC-55: Mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55);
 * * the UTF-8 code is normalized according the
 *   [normalization form for canonical composition](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms).
 *
 * The [BLAKE2](https://en.wikipedia.org/wiki/BLAKE_(hash_function)#BLAKE2) hash is computed from the encoded
 * certificate, then the hash is signed using the [SECP256K1](https://en.bitcoin.it/wiki/Secp256k1) parameters.
 *
 * [EIP/ERC-55: Mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55).
 * is supported.
 *
 * Secure audit function.
 * - {@link Blake2b256.of};
 * - {@link secp256k1.sign}.
 *
 * @param {Certificate} cert - The certificate to be signed.
 *                             Any instance extending the {@link Certificate} interface is supported.
 * @param {Uint8Array} privateKey - The private key used for signing.
 *
 * @returns {Certificate} - A new instance of the certificate with the signature added.
 *
 * @throws {InvalidSecp256k1PrivateKey} - If the private key is invalid.
 *
 */
declare function sign$2(cert: Certificate, privateKey: Uint8Array): Certificate;
/**
 * Verifies the validity of a certificate, throwing an error if the certificate is not valid.
 *
 * The certificate is valid when the signer's address computed from the signature
 * matches with the property {@link Certificate.signer}.
 *
 * This method is insensitive to the case representation of the signer's address.
 *
 * [EIP/ERC-55: Mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55).
 * is supported.
 *
 * Secure audit function.
 * - {@link Blake2b256.of};
 * - {@link secp256k1.recover}.
 *
 * @param {Certificate} cert - The certificate to verify.
 *                             Any instance extending the {@link Certificate} interface is supported.
 * @throws {CertificateSignature}
 *
 * @see {encode}
 */
declare function verify(cert: Certificate): void;
/**
 * Exposes the certificate sign and verification functions.
 */
declare const certificate: {
    encode: typeof encode$1;
    sign: typeof sign$2;
    verify: typeof verify;
};

/**
 * Simple type for transaction clause.
 */
interface TransactionClause {
    /**
     * Destination address where:
     * * transfer token to or
     * * invoke contract method on.
     *
     * @note Set null destination to deploy a contract.
     */
    to: string | null;

    /**
     * Amount of token to transfer to the destination
     */
    value: string | number;

    /**
     * Input data for contract method invocation or deployment
     */
    data: string;
}

/**
 * Extended type for transaction clause that includes wallet related properties.
 */
interface ExtendedTransactionClause extends TransactionClause {
    /**
     * Optional comment for the clause, helpful for displaying what the clause is doing.
     */
    comment?: string;

    /**
     * Optional ABI for the contract method invocation.
     */
    abi?: string;
}

/**
 * Options for creating a clause.
 */
interface ClauseOptions {
    /**
     * Optional comment for the clause, helpful for displaying what the clause is doing.
     */
    comment?: string;

    /**
     * Optional ABI for the contract method invocation.
     */
    includeABI?: boolean;
}

/**
 * Type for transaction body.
 */
interface TransactionBody {
    /**
     * Last byte of genesis block ID
     */
    chainTag: number;

    /**
     * 8 bytes prefix of some block's ID
     */
    blockRef: string;

    /**
     * Constraint of time bucket
     */
    expiration: number;

    /**
     * Array of clauses
     */
    clauses: TransactionClause[];

    /**
     * Coefficient applied to base gas price [0,255]
     */
    gasPriceCoef: number;

    /**
     * Max gas provided for execution
     */
    gas: string | number;

    /**
     * ID of another tx that is depended
     */
    dependsOn: string | null;

    /**
     * Nonce value for various purposes.
     * Basic is to prevent replay attack by make transaction unique.
     * Every transaction with same chainTag, blockRef, ... must have different nonce.
     */
    nonce: string | number;

    /**
     * A reserved field intended for features use.
     *
     * In standard EVM transactions, this reserved field typically is not present.
     * However, it's been designed to cater to VIP-191, which deals with fee delegation.
     *
     * If the `features` within the `reserved` field is set as `1111...111`, it indicates that the transaction has been delegated.
     * The method to check if the transaction is delegated is:
     *
     * ```typescript
     * reserved.features & 1 === 1
     * ```
     *
     * @example
     *
     * 1.
     * ```typescript
     * feature = 111101;
     * isDelegated = (111101 & 111111) === 111101; // false (not delegated)
     * ```
     *
     * 2.
     * ```typescript
     * feature = 111111;
     * isDelegated = (111111 & 111111) === 111111; // true (delegated)
     * ```
     *
     * @remarks
     * For more information on the subject, refer to {@link https://github.com/vechain/VIPs/blob/master/vips/VIP-191.md | VIP-191}.
     */
    reserved?: {
        /**
         * Tx feature bits
         */
        features?: number;
        /**
         * Unused
         */
        unused?: Buffer[];
    };
}

/**
 * Represents an immutable transaction entity.
 *
 * @remarks
 * Properties should be treated as read-only to avoid unintended side effects.
 * Any modifications create a new transaction instance which should be handled by the TransactionHandler component.
 *
 * @see {@link TransactionHandler} for transaction manipulation details.
 */
declare class Transaction {
    /**
     * Transaction body. It represents the body of the transaction.
     *
     * @note It is better to take it as a read-only property in order to avoid any external modification.
     */
    readonly body: TransactionBody;
    /**
     * Transaction signature. It represents the signature of the transaction.
     *
     * @note It is better to take it as a read-only property in order to avoid any external modification.
     */
    readonly signature?: Buffer;
    /**
     * Constructor with parameters.
     * This constructor creates a transaction immutable object.
     *
     * @param body - Transaction body
     * @param signature - Optional signature for the transaction
     * @throws {InvalidTransactionField, InvalidSecp256k1Signature}
     */
    constructor(body: TransactionBody, signature?: Buffer);
    /**
     * Calculate intrinsic gas required for this transaction
     *
     * @returns Intrinsic gas required for this transaction
     */
    get intrinsicGas(): number;
    /**
     * Determines whether the transaction is delegated.
     *
     * @returns If transaction is delegated or not
     */
    get isDelegated(): boolean;
    /**
     * Get transaction delegator address from signature.
     *
     * @returns Transaction delegator address
     * @throws {NotDelegatedTransaction, UnavailableTransactionField}
     */
    get delegator(): string;
    /**
     * Determines whether the transaction is signed or not.
     *
     * @returns If transaction is signed or not
     */
    get isSigned(): boolean;
    /**
     * Computes the signature hash for the transaction. The output is based on
     * the presence of the 'delegateFor' parameter.
     *
     * @param delegateFor - Optional address of the delegator.
     * @returns The computed hash.
     *
     * Mainly:
     *  - No 'delegateFor': return txHash
     * - 'delegateFor' return txHash +  hash('delegateFor' address)
     *
     * @remarks
     * delegateFor is used to sign a transaction on behalf of another account.
     * In fact when the delegator sign the transaction, delegator will add the address
     * of who send the transaction to sign (in this case the 'delegateFor' address parameter)
     *
     * @example
     * A is transaction origin
     * B is the delegator
     * TX is the transaction
     *
     * A sends a TX (signed by A) to B to who add his signature to TX using delegateFor parameter (that is A address)
     * on signing hash of TX computation.
     *
     * Mathematically:
     *
     * ```
     * final_signature = concat_buffer(
     *      sign(TX.signingHash(), A.privateKey),
     *      sign(TX.signingHash(A.address), B.privateKey)
     * )
     * ```
     *
     * Where:
     *
     * ```
     * TX.signatureHash() = blake2b256(TX.encoded)
     * TX.signingHash(A.address) = blake2b256(
     *      concat(
     *              blake2b256(TX.encoded),
     *              A.address
     *             )
     * )
     * ```
     *
     * @param delegateFor - Address of the delegator
     * @returns Signing hash of the transaction
     * @throws {InvalidTransactionField}
     */
    getSignatureHash(delegateFor?: string): Buffer;
    /**
     * Encode a transaction
     *
     * @returns The transaction encoded
     */
    get encoded(): Buffer;
    /**
     * Get transaction origin address from signature.
     *
     * @returns Transaction origin
     * @throws {UnavailableTransactionField}
     */
    get origin(): string;
    /**
     * Get transaction ID from signature.
     *
     * @returns Transaction ID
     * @throws {UnavailableTransactionField}
     */
    get id(): string;
    /**
     * Internal function to check if transaction is delegated or not.
     * This function is used to check directly the transaction body.
     * @private
     *
     * @param body Transaction body to check
     * @returns Weather the transaction is delegated or not
     */
    private _isDelegated;
    /**
     * Internal function to check if signature is valid or not.
     * This function is used to check directly the signature.
     * @private
     *
     * @param signature Signature to check
     * @returns Weather the signature is valid or not
     */
    private _isSignatureValid;
    /**
     * Encodes the reserved field to ensure it exists in every encoding.
     *
     * Due to the fact that reserved field is optional in TransactionBody,
     * BUT mandatory in RLPProfiler, we need to have it in every encoding.
     * Fot this reason this function is needed.
     * @private
     *
     * @returns Encoding of reserved field
     */
    private _encodeReservedField;
    /**
     * Make the RLP encoding of a transaction body.
     * @private
     *
     * @param body Body to encode
     * @param isSigned If transaction is signed or not
     * @returns RLP encoding of transaction body
     */
    private _lowLevelEncodeTransactionBodyWithRLP;
    /**
     * Private utility function to encode a transaction.
     * @private
     *
     * @param isSigned If transaction is signed or not (needed to determine if encoding with SIGNED_TRANSACTION_RLP or UNSIGNED_TRANSACTION_RLP)
     * @returns Encoding of transaction
     */
    private _encode;
    /**
     * utility function to check transaction body validity.
     *
     * @param body Transaction body to check
     */
    static isValidBody(body: TransactionBody): boolean;
}

/**
 * Sign a transaction with a given private key
 *
 * @param transactionBody - The body of the transaction to sign
 * @param signerPrivateKey - Private key used to sign the transaction
 * @returns Signed transaction
 * @throws {InvalidSecp256k1PrivateKey, InvalidTransactionField}
 */
declare function sign$1(transactionBody: TransactionBody, signerPrivateKey: Buffer): Transaction;
/**
 * Sign a transaction with signer and delegator private keys
 *
 * @param transactionBody - The body of the transaction to sign
 * @param signerPrivateKey - Signer private key (the origin)
 * @param delegatorPrivateKey - Delegate private key (the delegator)
 * @returns Signed transaction
 * @throws {InvalidSecp256k1PrivateKey}
 */
declare function signWithDelegator(transactionBody: TransactionBody, signerPrivateKey: Buffer, delegatorPrivateKey: Buffer): Transaction;

/**
 * Decode a raw transaction.
 * It can be signed or unsigned.
 *
 * @param rawTransaction - Raw transaction to decode
 * @param isSigned - If the transaction is signed or not
 * @returns Decoded transaction (signed or unsigned)
 */
declare function decode$1(rawTransaction: Buffer, isSigned: boolean): Transaction;

/**
 * TransactionHandler provides a set of utility functions for signing and decoding
 * transactions.
 */
declare const TransactionHandler: {
    sign: typeof sign$1;
    signWithDelegator: typeof signWithDelegator;
    decode: typeof decode$1;
};

/**
 * Constant representing the zero address in hexadecimal format
 */
declare const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
/**
 * VTHO token address (energy.sol smart contract address)
 */
declare const VTHO_ADDRESS = "0x0000000000000000000000000000456e65726779";
/**
 * Constant defining VeChain mainnet information
 */
declare const MAINNET_NETWORK: {
    genesisBlock: {
        number: number;
        id: string;
        size: number;
        parentID: string;
        timestamp: number;
        gasLimit: number;
        beneficiary: string;
        gasUsed: number;
        totalScore: number;
        txsRoot: string;
        txsFeatures: number;
        stateRoot: string;
        receiptsRoot: string;
        signer: string;
        isTrunk: boolean;
        transactions: never[];
    };
    chainTag: number;
};
/**
 * Constant defining VeChain testnet information
 */
declare const TESTNET_NETWORK: {
    genesisBlock: {
        number: number;
        id: string;
        size: number;
        parentID: string;
        timestamp: number;
        gasLimit: number;
        beneficiary: string;
        gasUsed: number;
        totalScore: number;
        txsRoot: string;
        txsFeatures: number;
        stateRoot: string;
        receiptsRoot: string;
        signer: string;
        isTrunk: boolean;
        transactions: never[];
    };
    chainTag: number;
};
/**
 * Constant defining VeChain solo network information
 */
declare const SOLO_NETWORK: {
    genesisBlock: {
        number: number;
        id: string;
        size: number;
        parentID: string;
        timestamp: number;
        gasLimit: number;
        beneficiary: string;
        gasUsed: number;
        totalScore: number;
        txsRoot: string;
        txsFeatures: number;
        stateRoot: string;
        receiptsRoot: string;
        signer: string;
        isTrunk: boolean;
        transactions: never[];
    };
    chainTag: number;
};
/**
 * Constant defining VeChain mainnet and testnet network information
 */
declare const networkInfo: {
    mainnet: {
        genesisBlock: {
            number: number;
            id: string;
            size: number;
            parentID: string;
            timestamp: number;
            gasLimit: number;
            beneficiary: string;
            gasUsed: number;
            totalScore: number;
            txsRoot: string;
            txsFeatures: number;
            stateRoot: string;
            receiptsRoot: string;
            signer: string;
            isTrunk: boolean;
            transactions: never[];
        };
        chainTag: number;
    };
    testnet: {
        genesisBlock: {
            number: number;
            id: string;
            size: number;
            parentID: string;
            timestamp: number;
            gasLimit: number;
            beneficiary: string;
            gasUsed: number;
            totalScore: number;
            txsRoot: string;
            txsFeatures: number;
            stateRoot: string;
            receiptsRoot: string;
            signer: string;
            isTrunk: boolean;
            transactions: never[];
        };
        chainTag: number;
    };
    solo: {
        genesisBlock: {
            number: number;
            id: string;
            size: number;
            parentID: string;
            timestamp: number;
            gasLimit: number;
            beneficiary: string;
            gasUsed: number;
            totalScore: number;
            txsRoot: string;
            txsFeatures: number;
            stateRoot: string;
            receiptsRoot: string;
            signer: string;
            isTrunk: boolean;
            transactions: never[];
        };
        chainTag: number;
    };
};

/**
 * Represents the parameters required for deployment.
 * @interface DeployParams
 */
interface DeployParams {
    /**
     * An array of types associated with the deployment parameters.
     * @type {string[] | ParamType[]}
     */
    types: string[] | ParamType[];

    /**
     * An array of values corresponding to the deployment parameters.
     * @type {string[]}
     */
    values: string[];
}

/**
 * Builds a clause for deploying a smart contract.
 *
 * @param contractBytecode - The bytecode of the smart contract to be deployed.
 * @param deployParams - The parameters to pass to the smart contract constructor.
 *
 * @param clauseOptions - Optional settings for the clause.
 * @returns A clause for deploying a smart contract.
 */
declare function deployContract(contractBytecode: string, deployParams?: DeployParams, clauseOptions?: ClauseOptions): TransactionClause | ExtendedTransactionClause;
/**
 * Builds a clause for interacting with a smart contract function.
 *
 * @param contractAddress - The address of the smart contract.
 * @param functionFragment - The function fragment to interact with.
 * @param args - The input data for the function.
 *
 * @param value - The amount of VET to send with the transaction.
 * @param clauseOptions - Optional settings for the clause.
 * @returns A clause for interacting with a smart contract function.
 *
 * @throws Will throw an error if an error occurs while encoding the function input.
 */
declare function functionInteraction(contractAddress: string, functionFragment: FunctionFragment, args: unknown[], value?: number, clauseOptions?: ClauseOptions): TransactionClause | ExtendedTransactionClause;
/**
 * Builds a clause for transferring VIP180 tokens.
 *
 * @param tokenAddress - The address of the VIP180 token.
 * @param recipientAddress - The address of the recipient.
 * @param amount - The amount of tokens to transfer in the decimals of the token.
 *                 For instance, a token with 18 decimals, 1 token would be 1000000000000000000 (i.e., 10 ** 18).
 *
 * @param clauseOptions - Optional settings for the clause.
 * @returns A clause for transferring VIP180 tokens.
 * @throws {InvalidDataType}
 */
declare function transferToken(tokenAddress: string, recipientAddress: string, amount: number | bigint | string, clauseOptions?: ClauseOptions): TransactionClause | ExtendedTransactionClause;
/**
 * Builds a clause for transferring VET.
 *
 * @param recipientAddress - The address of the recipient.
 * @param amount - The amount of VET to transfer in wei.
 * @param clauseOptions - Optional settings for the clause.
 * @returns A clause for transferring VET.
 * @throws {InvalidDataType}
 */
declare function transferVET(recipientAddress: string, amount: number | bigint | string, clauseOptions?: ClauseOptions): TransactionClause | ExtendedTransactionClause;
/**
 * Transfers a specified NFT (Non-Fungible Token) from one address to another.
 *
 * This function prepares a transaction clause for transferring an NFT, based on the ERC721 standard,
 * by invoking a smart contract's 'transferFrom' method.
 *
 * @param {string} contractAddress - The address of the NFT contract.
 * @param {string} senderAddress - The address of the current owner (sender) of the NFT.
 * @param {string} recipientAddress - The address of the new owner (recipient) of the NFT.
 * @param {string} tokenId - The unique identifier of the NFT to be transferred.
 * @param clauseOptions - Optional settings for the clause.
 * @returns {TransactionClause} - An object representing the transaction clause required for the transfer.
 * @throws {InvalidDataType}
 * */
declare function transferNFT(contractAddress: string, senderAddress: string, recipientAddress: string, tokenId: string, clauseOptions?: ClauseOptions): TransactionClause | ExtendedTransactionClause;
/**
 * clauseBuilder provides methods for building clauses for interacting with smart contracts or deploying smart contracts.
 */
declare const clauseBuilder: {
    deployContract: typeof deployContract;
    functionInteraction: typeof functionInteraction;
    transferToken: typeof transferToken;
    transferVET: typeof transferVET;
    transferNFT: typeof transferNFT;
};

/**
 * `ScalarKind` Abstract Class - A base for scalar kinds providing contract for data and buffer manipulations.
 */
declare abstract class ScalarKind {
    /**
     * Abstract method to handle data encoding.
     * @param data - The data to encode.
     * @param context - Contextual information for error messaging.
     * @returns An object providing a mechanism to encode the data into a Buffer.
     */
    abstract data(data: RLPInput | RLPValidObject, context: string): DataOutput;
    /**
     * Abstract method to handle buffer decoding.
     * @param buffer - The buffer to decode.
     * @param context - Contextual information for error messaging.
     * @returns An object providing a mechanism to decode the buffer back into data.
     */
    abstract buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * Represents a scalar kind with Buffer functionality.
 * This class extends the {@link ScalarKind} class.
 */
declare class BufferKind extends ScalarKind {
    /**
     * Encodes the input data into buffer format.
     *
     * @param data - The data to encode, expected to be of buffer type.
     * @param context - Descriptive context for error messages
     * @returns DataOutput object with an encode function.
     * @throws {InvalidRLP}
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer.
     *
     * @param buffer - The buffer to decode, expected to be of buffer type.
     * @param context - Descriptive context for error messages, usually representing the caller's identity.
     * @returns BufferOutput object with a decode function.
     * @throws {InvalidRLP}
     */
    buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * Represents a scalar kind with numeric functionality.
 * This class extends the {@link ScalarKind} class.
 */
declare class NumericKind extends ScalarKind {
    readonly maxBytes?: number | undefined;
    /**
     * Constructs a new instance of NumericKind.
     *
     * @param maxBytes - Optional parameter that specifies the maximum number of bytes that numeric data can occupy when encoded.
     */
    constructor(maxBytes?: number | undefined);
    /**
     * Encodes the input data into numeric format and ensures it doesn't exceed the maximum bytes, if specified.
     *
     * @param data - The data to encode, expected to be numeric.
     * @param context - Descriptive context for error messages
     * @returns DataOutput object with an encode function.
     * @throws Will throw an error if data validation fails or encoding issues occur.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a number or hexadecimal string, ensuring it meets numeric data constraints.
     *
     * @param buffer - The buffer to decode, containing numeric data.
     * @param context - Descriptive context for error messages.
     * @returns BufferOutput object with a decode function.
     * @throws Will throw an error if buffer validation fails.
     */
    buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * Represents a scalar kind with hex blob functionality.
 * This class extends the {@link ScalarKind} class.
 *
 * @remarks
 * A hex blob is a hex string that is prefixed with '0x' and has even length.
 */
declare class HexBlobKind extends ScalarKind {
    /**
     * Encodes the input data into a Buffer.
     *
     * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.
     * @param context - Context string for error handling.
     * @returns An object containing an encode function which returns the encoded Buffer.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a hex string.
     *
     * @param buffer - The buffer to decode.
     * @param context - Context string for error handling.
     * @returns An object containing a decode function which returns the decoded hex string.
     */
    buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * Represents a hex blob kind with fixed bytes size functionality.
 * This class extends the {@link HexBlobKind} class.
 */
declare class FixedHexBlobKind extends HexBlobKind {
    readonly bytes: number;
    /**
     * Creates a new instance of the {@link FixedHexBlobKind} class.
     * @param bytes - The number of bytes the blob must have.
     */
    constructor(bytes: number);
    /**
     * Encodes the input data into a Buffer with validation against fixed size.
     *
     * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.
     * @param context - Context string for error handling.
     * @returns An object containing an encode function which returns the encoded Buffer.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a hex string with validation against fixed size.
     *
     * @param buffer - The buffer to decode.
     * @param context - Context string for error handling.
     * @returns An object containing a decode function which returns the decoded hex string.
     */
    buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * Represents a fixed hex blob kind with optional data functionality.
 * This class extends the {@link FixedHexBlobKind} class.
 */
declare class OptionalFixedHexBlobKind extends FixedHexBlobKind {
    /**
     * Encodes the input data (which can be null or undefined) into a Buffer.
     *
     * @param data - The data to encode, can be null or undefined.
     * @param context - Context string for error handling.
     * @returns An object containing an encode function which returns the encoded Buffer.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a hex string or null if the buffer is empty.
     *
     * @param buffer - The buffer to decode, can be empty.
     * @param context - Context string for error handling.
     * @returns An object containing a decode function which returns the decoded hex string or null.
     */
    buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * Represents a fixed hex blob kind with zero trimming and padding functionality.
 * This class extends the {@link FixedHexBlobKind} class.
 */
declare class CompactFixedHexBlobKind extends FixedHexBlobKind {
    /**
     * Encodes the input data into a Buffer, trimming leading zeros.
     *
     * @param data - The data to encode, expected to be a '0x' prefixed hex string.
     * @param context - Context string for error handling.
     * @returns An object containing an encode function which returns the encoded Buffer.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a number or hexadecimal string, ensuring it meets the fixed size by padding with zeros.
     *
     * @param buffer - The buffer to decode, containing numeric data.
     * @param context - Descriptive context for error messages, usually representing the caller's identity.
     * @returns BufferOutput object with a decode function.
     * @throws Will throw an error if buffer validation fails.
     */
    buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * RLP_CODER profile classes.
 */
declare const RLPProfiles: {
    ScalarKind: typeof ScalarKind;
    BufferKind: typeof BufferKind;
    NumericKind: typeof NumericKind;
    HexBlobKind: typeof HexBlobKind;
    FixedHexBlobKind: typeof FixedHexBlobKind;
    OptionalFixedHexBlobKind: typeof OptionalFixedHexBlobKind;
    CompactFixedHexBlobKind: typeof CompactFixedHexBlobKind;
};

/**
 * Represents a valid input for the RLP (Recursive Length Prefix) encoding.
 * The RLP encoding is used to encode arbitrary binary data (nested arrays of bytes).
 *
 * @typeParam Input - Can be a Buffer, Array of Inputs, Buffer array, or nested array of Inputs.
 * @see {@link https://github.com/ethereumjs/ethereumjs-monorepo/blob/master/packages/rlp/src/index.ts}
 */
type RLPInput = Input;

/**
 * Represents an output from RLP decoding.
 * This type can either be a single Uint8Array (byte array) or a nested structure
 * of Uint8Array instances.
 *
 * @typeParam Uint8Array - A typed array of 8-bit unsigned integers.
 * @typeParam NestedUint8Array - A possibly nested array of Uint8Arrays.
 */
type RLPOutput = Uint8Array | NestedUint8Array;

/**
 * Represents a complex RLP object.
 * This type allows for recursive nesting of RLPInput or further RLPComplexObjects,
 * allowing the definition of complex structures.
 *
 * @typeParam RLPInput - A valid RLP input type.
 * @typeParam RLPComplexObject - Recursive type to enable nesting of complex objects.
 */
interface RLPComplexObject {
    [key: string]: RLPInput | RLPComplexObject | RLPComplexObject[];
}

/**
 * Represents a valid RLP object.
 * It is a dictionary-like object where keys are strings and values can be
 * a valid RLP input type or a complex RLP object (which can be further nested).
 *
 * @typeParam RLPValueType - A type that represents all valid RLP values.
 */
type RLPValidObject = Record<string, RLPValueType>;

/**
 * Represents all valid RLP value types.
 * This type union is used to simplify the definition of valid value types within
 * RLP object structures, supporting single inputs, complex objects, and arrays
 * of complex objects.
 *
 * @typeParam RLPInput - A valid RLP input type.
 * @typeParam RLPComplexObject - A valid complex RLP object.
 */
type RLPValueType = RLPInput | RLPComplexObject | RLPComplexObject[];

/* ------- RLP Profile Types ------- */
/**
 * `RLPProfile` Interface - Describes the profile of the RLP encoding.
 */
interface RLPProfile {
    name: string;
    kind: ScalarKind | ArrayKind | StructKind;
}

/**
 * `ArrayKind` Interface - Describes an array-kind in the RLP encoding profile.
 */
interface ArrayKind {
    item: RLPProfile['kind'];
}

/**
 * `StructKind` Type - Describes a structured-kind in the RLP encoding profile using an array of `RLPProfile`.
 */
type StructKind = RLPProfile[];

/**
 * `DataOutput` Interface - Provides an encoding mechanism to convert data into a Buffer.
 */
interface DataOutput {
    encode: () => Buffer;
}

/**
 * `BufferOutput` Interface - Provides a decoding mechanism to convert a Buffer back into data.
 */
interface BufferOutput {
    decode: () => RLPInput;
}

/**
 * Encodes data using the Ethereumjs RLP library.
 * @param data - The data to be encoded.
 * @returns The encoded data as a Buffer.
 */
declare function encode(data: RLPInput): Buffer;
/**
 * Decodes RLP-encoded data using the Ethereumjs RLP library.
 * @param encodedData - The RLP-encoded data as a Buffer.
 * @returns The decoded data or null if decoding fails.
 */
declare function decode(encodedData: Buffer): RLPOutput;
/**
 * Class handling the profiling of RLP encoded/decoded objects.
 * Provides methods to encode and decode objects based on a provided RLP profile.
 */
declare class Profiler {
    readonly profile: RLPProfile;
    /**
     * Creates a new Profiler instance.
     * @param profile - RLP_CODER profile for encoding/decoding structures.
     */
    constructor(profile: RLPProfile);
    /**
     * Encodes an object following the provided RLP_CODER profile.
     * @param data - Object to be encoded.
     * @returns - Encoded data as a Buffer.
     */
    encodeObject(data: RLPValidObject): Buffer;
    /**
     * Decodes an object following the provided RLP_CODER profile.
     * @param encodedData - Data to be decoded.
     * @returns - Decoded data as RLPValueType.
     */
    decodeObject(encodedData: Buffer): RLPValueType;
}
declare const RLPBase: {
    encode: typeof encode;
    decode: typeof decode;
    Profiler: typeof Profiler;
};

/**
 * Validates and converts the input data to a BigInt.
 *
 * @param data - Either a number or a string representing a non-negative integer.
 * @param context - A string representing the context in which this function is used,
 *                 to create meaningful error messages.
 * @returns The input data converted to a BigInt.
 * @throws {InvalidRLP}
 */
declare const validateNumericKindData: (data: RLPInput, context: string) => bigint;
/**
 * Validates a buffer to ensure it adheres to constraints and does not contain
 * leading zero bytes which are not canonical representation in integers.
 *
 * @param buf - The buffer to validate.
 * @param context - A string providing context for error messages.
 * @param maxBytes - [Optional] An integer representing the maximum allowed length
 *                   of the buffer. If provided, an error will be thrown if buf is longer.
 * @throws {InvalidRLP}
 *
 * @private
 */
declare const assertValidNumericKindBuffer: (buf: Buffer, context: string, maxBytes?: number) => void;
/**
 * Encode a BigInt instance into a Buffer, ensuring it adheres to specific constraints.
 *
 * @param bi - BigInt instance to encode.
 * @param maxBytes - Maximum byte length allowed for the encoding. If undefined, no byte size limit is imposed.
 * @param context - Contextual information for error messages.
 * @returns A Buffer instance containing the encoded data.
 * @throws {InvalidRLP}
 */
declare const encodeBigIntToBuffer: (bi: bigint, maxBytes: number | undefined, context: string) => Buffer;
/**
 * Decode a Buffer into a number or hexadecimal string.
 * @param buffer - Buffer instance to decode.
 * @returns A number if the decoded BigInt is a safe integer, otherwise returns a hexadecimal string.
 */
declare const decodeBufferToNumberOrHex: (buffer: Buffer) => number | string;

/**
 * Validates if the input is a proper hex string for HexBlobKind.
 *
 * @param data - The input data to validate.
 * @param context - Additional context for error handling.
 * @throws {InvalidRLP}
 */
declare const assertValidHexBlobKindData: (data: RLPInput, context: string) => void;
/**
 * Validates if the input buffer is valid for HexBlobKind.
 *
 * @param buffer - The buffer to validate.
 * @param context - Additional context for error handling.
 * @throws {InvalidRLP}
 */
declare const assertValidHexBlobKindBuffer: (buffer: Buffer, context: string) => void;

/**
 * Asserts that the data is a hex string of the correct length.
 *
 * @param data - The data to validate.
 * @param context - Descriptive context for error messages.
 * @param bytes - The expected number of bytes that the data can contain.
 * @throws {InvalidRLP}
 */
declare const assertFixedHexBlobKindData: (data: string, context: string, bytes: number) => void;
/**
 * Asserts that the buffer is of a specific length.
 *
 * @param buffer - The buffer to validate.
 * @param context - Descriptive context for error messages.
 * @param bytes - The expected number of bytes that the buffer can contain.
 * @throws {InvalidRLP}
 */
declare const assertFixedHexBlobKindBuffer: (buffer: Buffer, context: string, bytes: number) => void;

/**
 * Asserts that the provided buffer is of a specific length and does not contain leading zeros.
 *
 * @param buffer - The buffer to validate.
 * @param context - Descriptive context for error messages, usually representing the caller's identity.
 * @param bytes - The expected maximum number of bytes that the buffer can contain.
 * @throws {InvalidRLP}
 */
declare const assertCompactFixedHexBlobBuffer: (buffer: Buffer, context: string, bytes: number) => void;
/**
 * Encodes a buffer by trimming leading zero bytes.
 * Finds the first non-zero byte and returns a new buffer starting from that byte. Returns an empty buffer if all bytes are zero.
 *
 * @param buffer - The buffer to be Compact.
 * @returns A Buffer instance Compact of leading zero bytes, or an empty Buffer if all bytes are zero.
 */
declare const encodeCompactFixedHexBlob: (buffer: Buffer) => Buffer;
/**
 * Decodes a buffer into a hexadecimal string, ensuring a specific total byte length by prepending zeros if necessary.
 * Calculates the number of missing bytes compared to the expected total and prepends the corresponding number of '0' characters to the hexadecimal string representation of the buffer.
 *
 * @param buffer - The buffer to decode.
 * @param bytes - The expected total number of bytes in the final hexadecimal string (including leading zeros).
 * @returns A hexadecimal string with the necessary leading '0' characters to ensure the specified total byte length.
 */
declare const decodeBufferToHexWithLeadingZeros: (buffer: Buffer, bytes: number) => string;

/**
 * The `RLP_CODER` object, encapsulating all functionalities related to Recursive Length Prefix (RLP_CODER) encoding.
 *
 * RLP_CODER contains the following classes and methods:
 * - `encode` - Encodes data using the Ethereumjs RLP_CODER library.
 * - `decode` - Decodes RLP_CODER-encoded data using the Ethereumjs RLP_CODER library.
 * - `Profiler` - Class handling the profiling of RLP_CODER encoded/decoded objects.
 * - `ScalarKind` - Abstract class for scalar types.
 * - `BufferKind` - Class managing buffers and ensuring type safety with encode/decode methods.
 * - `NumericKind` - Class managing numerical data ensuring it adheres to specific constraints.
 */
declare const RLP_CODER: {
    ScalarKind: typeof ScalarKind;
    BufferKind: typeof BufferKind;
    NumericKind: typeof NumericKind;
    HexBlobKind: typeof HexBlobKind;
    FixedHexBlobKind: typeof FixedHexBlobKind;
    OptionalFixedHexBlobKind: typeof OptionalFixedHexBlobKind;
    CompactFixedHexBlobKind: typeof CompactFixedHexBlobKind;
    encode: (data: RLPInput) => Buffer;
    decode: (encodedData: Buffer) => RLPOutput;
    Profiler: {
        new (profile: RLPProfile): {
            readonly profile: RLPProfile;
            encodeObject(data: RLPValidObject): Buffer;
            decodeObject(encodedData: Buffer): RLPValueType;
        };
    };
};

/**
 * Root interface for all the classes part of the `VeChain Data Model`
 * to provide a coherent API to represent, encode, and cast data among data types.
 *
 * @interface
 */
interface VeChainDataModel<T> {
    /**
     * Return this instance cast to a big integer value
     * @throws InvalidOperation if this object can't cast to a big integer.
     */
    get bi(): bigint;
    /**
     * Return this instance cast to a buffer of bytes.
     */
    get bytes(): Uint8Array;
    /**
     * Return this object cast to number value.
     * @throws InvalidOperation if this object can't cast to a big integer.
     */
    get n(): number;
    /**
     * Compare this instance with `that` in a lexicographic meaningful way.
     *
     * @param {T} that object to compare.
     * @return a negative number if `this` < `that`, zero if `this` = `that`, a positive number if `this` > that`.
     */
    compareTo: (that: T) => number;
    /**
     * Checks if the given value is equal to the current instance.
     *
     * @param {T} that - The value to compare.
     * @returns {boolean} - True if the values are equal, false otherwise.
     */
    isEqual: (that: T) => boolean;
}

/**
 * Represents a hexadecimal value expressed as
 * * `-` sign if the value is negative,
 * * `0x` hexadecimal notation tag,
 * * a not empty string of hexadecimal digits from `0` to `9` and from `a` to `f`.
 *
 * @description This hexadecimal notation is coherent with the decimal notation:
 * * the sign is only expressed for negative values, and it is always the first symbol,
 * * the `0x` tags the string as a hexadecimal expression,
 * * hexadecimal digits follow.
 * * An empty content results is no digits.
 *
 * @implements {VeChainDataModel<Hex>}
 */
declare class Hex implements VeChainDataModel<Hex> {
    /**
     * Negative multiplier of the {@link digits} absolute value.
     *
     * @type {number}
     */
    protected static readonly NEGATIVE: number;
    /**
     * Positive multiplier of the {@link digits} absolute value.
     *
     * @type {number}
     */
    protected static readonly POSITIVE: number;
    /**
     * The radix used for representing numbers base 16 in a positional numeral notation system.
     *
     * @typedef {number} RADIX
     */
    protected static readonly RADIX: number;
    /**
     * Regular expression for matching hexadecimal strings.
     * An empty input is represented as a empty digits.
     *
     * @type {RegExp}
     */
    private static readonly REGEX_HEX;
    /**
     * Regular expression pattern to match a prefix indicating hexadecimal number.
     *
     * @type {RegExp}
     */
    protected static readonly REGEX_HEX_PREFIX: RegExp;
    /**
     * Returns the hexadecimal digits expressing this absolute value, sign and `0x` prefix omitted.

     * @remarks An empty content results in an empty string returned.
     */
    readonly digits: string;
    /**
     * Represents the sign multiplier of a given number:
     * * {@link NEGATIVE} `-1` if negative,
     * * {@link POSITIVE} `1` if positive.
     */
    readonly sign: number;
    /**
     * Creates a new instance of this class to represent the value
     * built multiplying `sign` for the absolute value expressed by the hexadecimal `digits`.
     *
     * @param {number} sign - The sign of the value.
     * @param {string} digits - The digits of the absolute value in hexadecimal base.
     * @param {function} [normalize] - The function used to normalize the digits. Defaults to converting digits to lowercase.
     */
    protected constructor(sign: number, digits: string, normalize?: (digits: string) => string);
    /**
     * Returns the absolute value of this Hex object.
     *
     * @return {Hex} A new Hex object representing the absolute value of this Hex.
     */
    get abs(): Hex;
    /**
     * Returns the value of `bi` as a `BigInt` type.
     *
     * @returns {bigint} The value of `bi` as a `BigInt`.
     */
    get bi(): bigint;
    /**
     * Returns the Uint8Array representation of the aligned bytes.
     *
     * @return {Uint8Array} The Uint8Array representation of the aligned bytes.
     */
    get bytes(): Uint8Array;
    /**
     * Returns the value of n.
     *
     * @return {number} The value of n.
     *
     * @throws {InvalidOperation<Hex>} Throws an error if this instance doesn't represent
     * an [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).
     */
    get n(): number;
    /**
     * Aligns the hexadecimal string to bytes by adding a leading '0' if the string length is odd.
     *
     * @returns {Hex} - The aligned hexadecimal string.
     */
    alignToBytes(): Hex;
    /**
     * Compares the current Hex object with another Hex object.
     *
     * @param {Hex} that - The Hex object to compare with.
     *
     * @return {number} - Returns a negative number if the current Hex object is less than the given Hex object,
     *                    zero if they are equal, or a positive number if the current Hex object is greater than the given Hex object.
     */
    compareTo(that: Hex): number;
    /**
     * Returns a new instance of the Hex class, its value fits to the specified number of digits.
     *
     * @param {number} digits - The number of digits to fit the Hex value into.
     *
     * @returns {Hex} - A new Hex instance that represents the fitted Hex value.
     *
     * @throws {InvalidDataType} - If the Hex value cannot be fit into the specified number of digits.
     */
    fit(digits: number): Hex;
    /**
     * Determines whether this Hex instance is equal to the given Hex instance.
     *
     * @param {Hex} that - The Hex instance to compare with.
     * @return {boolean} - True if the Hex instances are equal, otherwise false.
     */
    isEqual(that: Hex): boolean;
    /**
     * Checks if this instance expresses a valid {@link Number} value
     * according the
     * [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).
     *
     * @returns {boolean} Returns true if this instance expresses 32 hex digits (16 bytes, 128 bits) needed to represent
     * a {@link Number} value, else it returns false.
     */
    isNumber(): boolean;
    /**
     * Checks if the given string expression is a valid hexadecimal value.
     *
     * @param {string} exp - The string representation of a hexadecimal value.
     *
     * @return {boolean} - True if the expression is a valid hexadecimal value, case-insensitive,
     * optionally prefixed with `0x`; false otherwise.
     */
    static isValid(exp: string): boolean;
    /**
     * Determines whether the given string is a valid hexadecimal number prefixed with '0x'.
     *
     * @param {string} exp - The string to be evaluated.
     * @return {boolean} - True if the string is a valid hexadecimal number prefixed with '0x', otherwise false.
     */
    static isValid0x(exp: string): boolean;
    /**
     * Create a Hex instance from a bigint, number, string, or Uint8Array.
     *
     * @param {bigint | number | string | Uint8Array} exp - The value to represent in a Hex instance:
     * * bigint is always representable in hexadecimal base notation;
     * * number, encoded as [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format);
     * * string is parsed as the hexadecimal expression of a bigint value, optionally tagged with `0x`;
     * * Uint8Array is interpreted as the sequence of bytes.
     *
     * @returns {Hex} - A Hex instance representing the input value.
     *
     * @throws {InvalidDataType} if the given `exp` can't be represented as a hexadecimal expression.
     */
    static of(exp: bigint | number | string | Uint8Array): Hex;
    /**
     * Generates a random Hex value of the given number of bytes length.
     *
     * @param {number} bytes - The number of bytes to generate.
     * @throws {InvalidDataType} - If the bytes argument is not greater than 0.
     * @returns {Hex} - A randomly generated Hex value.
     *
     * @remarks Security auditable method, depends on
     * * [`nh_utils.randomBytes`](https://github.com/paulmillr/noble-hashes?tab=readme-ov-file#utils).
     */
    static random(bytes: number): Hex;
    /**
     * Error handler for Hex and its subclasses so we do not hide them.
     * To be used only for nested errors.
     *
     * @param error - The error to handle from the subclass.
     * @param methodName - The name of the method that threw the error.
     * @param {string} errorMessage - The error message to throw.
     * @param {ObjectErrorData} data - The data to include in the error.
     * @throws {InvalidDataType} - Throws an error with the given message and data.
     */
    protected static throwInvalidDataType(error: unknown, methodName: string, errorMessage: string, data: ObjectErrorData): never;
    /**
     * Returns a string representation of the object.
     *
     * @return {string} The string representation of the object.
     */
    toString(): string;
}

/**
 * Represents a hexadecimal signed integer value.
 *
 * @remarks This class makes equal instances created from the same value as number or as bigint.
 *
 * @extends {Hex}
 */
declare class HexInt extends Hex {
    /**
     * Retrieves the value of n cast from this instance interpreted as the hexadecimal expression of a bigint value.
     *
     * @return {number} The value of n.
     *
     * @throws {InvalidDataType} If n is not within the safe number range, if the number representation of this
     * instance results approximated.
     *
     * @remarks This class makes equal instances created from the same value as number or as bigint.
     */
    get n(): number;
    /**
     * Create a HexInt instance from a bigint, number, string, Uint8Array, or {@link Hex}.
     *
     * @param {bigint | number | string | Uint8Array | Hex} exp - The expression to be interpreted as an integer:
     * * bigint is always representable in hexadecimal base notation;
     * * number is converted to a bigint then represented in hexadecimal base notation;
     *   it throws {@link InvalidDataType} if not an integer value;
     * * string is parsed as the hexadecimal expression of a bigint value, optionally tagged with `0x`;
     * * Uint8Array is interpreted as the sequence of bytes expressing a bigint value;
     * * {@link Hex} is interpreted as expressing a bigint value.
     *
     * @returns {HexInt} - The new HexInt object representing the given `exp`.
     *
     * @throws {InvalidDataType} - If the given `exp` is not a valid hexadecimal integer expression,
     * if `exp` is a not integer number.
     *
     * @remarks This class makes equal instances created from the same value as number or as bigint.
     */
    static of(exp: bigint | number | string | Uint8Array | Hex): HexInt;
}

/**
 * Represents a hexadecimal unsigned integer value.
 *
 * @extends HexInt
 */
declare class HexUInt extends HexInt {
    /**
     * Regular expression for matching hexadecimal strings.
     * An empty input is represented as a empty digits.
     *
     * @type {RegExp}
     */
    private static readonly REGEX_HEXUINT;
    /**
     * Regular expression pattern to match a prefix indicating hexadecimal number.
     *
     * @type {RegExp}
     */
    protected static readonly REGEX_HEXUINT_PREFIX: RegExp;
    /**
     * Checks if the given string expression is a valid unsigned hexadecimal value.
     *
     * @param {string} exp - The string representation of a hexadecimal value.
     *
     * @return {boolean} - True if the expression is a valid unsigned hexadecimal value, case-insensitive,
     * optionally prefixed with `0x`; false otherwise.
     */
    static isValid(exp: string): boolean;
    /**
     * Determines whether the given string is a valid unsigned hexadecimal number prefixed with '0x'.
     *
     * @param {string} exp - The string to be evaluated.
     * @return {boolean} - True if the string is a valid unsigned hexadecimal number prefixed with '0x', otherwise false.
     */
    static isValid0x(exp: string): boolean;
    /**
     * Create a HexUInt instance from a bigint, number, string, Uint8Array, or {@link HexInt}.
     *
     * @param {bigint | number | string | Uint8Array | HexInt} exp - The expression to be interpreted as an unsigned integer:
     * * bigint is always representable in hexadecimal base notation,
     *   it throws {@link InvalidDataType} if not positive;
     * * number is converted to a bigint then represented in hexadecimal base notation,
     *   it throws {@link InvalidDataType} if not a positive integer value;
     * * string is parsed as the hexadecimal expression of a bigint value, optionally tagged with `0x`;
     *   it throws {@link InvalidDataType} if not positive;
     * * Uint8Array is interpreted as the sequence of bytes expressing a positive bigint value;
     * * {@link HexInt} is interpreted as expressing a bigint value,
     *   it throws {@link InvalidDataType} if not positive.
     *
     * @returns {HexUInt} he new HexInt object representing the given `exp`.
     *
     * @throws {InvalidDataType} If the given expression is not a valid hexadecimal positive integer expression.
     */
    static of(exp: bigint | number | string | Uint8Array | HexInt): HexUInt;
}

/**
 * Represents a VeChain Address as unsigned integer.
 *
 * @extends {HexUInt}
 */
declare class Address extends HexUInt {
    /**
     * It checksums a given hexadecimal address.
     *
     * @param {HexUInt} huint The HexUInt object representing the hexadecimal value.
     *
     * @returns {string} The checksummed address.
     */
    static checksum(huint: HexUInt): string;
    /**
     * Validate the given expression to be a valid address.
     *
     *  @param {string} exp Expression to validate
     *
     * @returns {boolean} true if the expression is a valid address, false otherwise
     */
    static isValid(exp: string): boolean;
    /**
     * Create ab Address instance from the given expression interpreted as an unsigned integer.
     *
     * @param exp The expression to convert. It can be of type bigint, number, string, Uint8Array, or HexUInt.
     *
     * @returns {Address} The converted hexadecimal unsigned integer.
     *
     * @throws {InvalidDataType} If the expression is not a valid hexadecimal positive integer expression.
     */
    static of(exp: bigint | number | string | Uint8Array | HexUInt): Address;
    /**
     * Create an Address instance from the given private key.
     *
     * @param {Uint8Array} privateKey The private key to convert.
     *
     * @param {boolean} [isCompressed=true] The flag to indicate if the derived public key should be compressed.
     *
     * @returns {Address} The converted address.
     *
     * @remarks Security auditable method, depends on
     * * {@link secp256k1.derivePublicKey}.
     */
    static ofPrivateKey(privateKey: Uint8Array, isCompressed?: boolean): Address;
    /**
     * Create an Address instance from the given public key.
     *
     * @param {Uint8Array} publicKey The public key to convert.
     *
     * @returns {Address} The converted address.
     *
     * @remarks Security auditable method, depends on
     * * {@link secp256k1.inflatePublicKey}.
     */
    static ofPublicKey(publicKey: Uint8Array): Address;
    /**
     * Derives the address from a given list of words of
     * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
     * and a [BIP44 Derivation Path](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)
     * as in the examples.
     *
     * Secure audit function.
     * - {@link bip32.HDKey}(https://github.com/paulmillr/scure-bip32)
     * - {@link HDNode}
     *
     * @example `m/0` (default)
     * @example `m/0/2`
     * @example `m/0/2/4/6`
     *
     * @param {string[]} mnemonic - Mnemonic used to generate the HD node.
     * @param {string} [path='m/0'] - The derivation path from the current node.
     * @return {Address} - The derived address.
     * @throws {InvalidHDNode}
     *
     */
    static ofMnemonic(mnemonic: string[], path?: string): Address;
}
declare const addressUtils: {
    fromPrivateKey: (privateKey: Uint8Array) => string;
    fromPublicKey: (publicKey: Uint8Array) => string;
    isAddress: (addressToVerify: string) => boolean;
    toERC55Checksum: (address: string) => string;
};

interface Currency extends VeChainDataModel<Currency> {
    get bi(): bigint;
    get code(): string;
}

type AccountType = 'EOA' | 'Contract';
/**
 * Represents a VeChain account.
 *
 * @implements {VeChainDataModel<Account>}
 */
declare class Account implements VeChainDataModel<Account> {
    readonly address: Address;
    readonly balance: Currency;
    readonly transactions: string[];
    readonly type: AccountType;
    constructor(address: Address, balance: Currency, type?: AccountType, transactions?: string[]);
    /**
     * Throws an exception because the account cannot be represented as a big integer.
     * @returns {bigint} The BigInt representation of the account.
     * @throws {InvalidOperation} The account cannot be represented as a bigint.
     * @override {@link VeChainDataModel#bi}
     * @remarks The conversion to BigInt is not supported for an account.
     */
    get bi(): bigint;
    /**
     * Throws an exception because the account cannot be represented as a byte array.
     * @returns {Uint8Array} The byte array representation of the account.
     * @throws {InvalidOperation} The account cannot be represented as a byte array.
     * @override {@link VeChainDataModel#bytes}
     * @remarks The conversion to byte array is not supported for an account.
     */
    get bytes(): Uint8Array;
    /**
     * Throws an exception because the account cannot be represented as a number.
     * @returns {bigint} The number representation of the account.
     * @throws {InvalidOperation} The account cannot be represented as a number.
     * @override {@link VeChainDataModel#n}
     * @remarks The conversion to number is not supported for an account.
     */
    get n(): number;
    /**
     * Adds a transaction to the account.
     * @param {string} transaction The transaction to add.
     */
    addTransaction(transaction: string): void;
    /**
     * Compare this instance with `that` in a meaningful way.
     *
     * @param {Account} that object to compare.
     * @return a negative number if `this` < `that`, zero if `this` = `that`, a positive number if `this` > that`.
     * @override {@link VeChainDataModel#compareTo}
     */
    compareTo(that: Account): number;
    /**
     * Checks if the given value is equal to the current instance.
     *
     * @param {Account} that - The value to compare.
     * @returns {boolean} - True if the values are equal, false otherwise.
     * @override {@link VeChainDataModel#isEqual}
     */
    isEqual(that: Account): boolean;
    /**
     * Returns a string representation of the account.
     *
     * @returns {string} A string representation of the account.
     */
    toString(): string;
}

/**
 * A [Bloom Filter](https://en.wikipedia.org/wiki/Bloom_filter)
 * is a space-efficient probabilistic data structure
 * that is used to test whether an element is a member of a set.
 *
 * @remarks False positive matches are possible, but false negatives are not.
 *
 * @implements {VeChainDataModel<Hex>}
 */
declare class BloomFilter implements VeChainDataModel<BloomFilter> {
    /**
     * Return the Bloom filter structure: an array of `m` bits per key encoding if a key is not part of the structure.
     *
     * @typedef {Uint8Array} bytes
     */
    readonly bytes: Uint8Array;
    /**
     * Return the number of hash functions used to compute this Bloom filter.
     *
     * @type {number}
     */
    readonly k: number;
    /**
     * Creates a new instance of this class.
     *
     * @param {Uint8Array} bytes - The Bloom filter structure of `m` bits per key encoding if the key
     *                             likely belongs to the structure or surely doesn't.
     * @param {number} k - The number of hash functions used to compute this Bloom filter.
     *
     */
    constructor(bytes: Uint8Array, k: number);
    /**
     * Return the Bloom filter data structure represented as a {@link bigint} value.
     *
     * @returns {bigint} - The Bloom filter data structure represented as a {@link bigint} value.
     */
    get bi(): bigint;
    /**
     * Return the Bloom filter data structure represented as a {@link number} value.
     *
     * @returns {bigint} - The Bloom filter data structure represented as a {@link number} value.
     *
     * @throws InvalidDataType if the data structure of the bloom filter can't be represented as a number
     * because underflow or overflow number safe integer range according
     * [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).
     *
     * @remarks Preferably use {@link bi} because the Bloom filter data structure can always be represented as a {@link bigint} value.
     */
    get n(): number;
    /**
     * Compare the current BloomFilter instance with another BloomFilter instance according their
     * * {@link bytes} data structure first,
     * * {@link k} if the data structures are equal.
     *
     * @param {BloomFilter} that - The BloomFilter instance to compare with.
     *
     * @return {number} - Returns a negative number if the current instance is less than the provided instance,
     *                   returns zero if they are equal, and returns a positive number if the current instance is greater than the provided instance.
     */
    compareTo(that: BloomFilter): number;
    /**
     * Checks if the current BloomFilter instance is equal to another BloomFilter instance.
     *
     * @param {BloomFilter} that - The other BloomFilter instance to compare with.
     *
     * @return {boolean} - Returns true if the current BloomFilter instance is equal to the other BloomFilter instance, otherwise returns false.
     */
    isEqual(that: BloomFilter): boolean;
    /**
     * Checks if the specified key may be contained within this Bloom filter or surely isn't.
     *
     * @param {Hex|Uint8Array} key - The key to check. It can be either a Hex object or a Uint8Array.
     *
     * @return {boolean} Returns true if this Bloom filter may contain the key, otherwise returns false.
     *
     * @remarks False positive matches are possible, but false negatives are not.
     * @remarks Security auditable method, depends on
     * * {@link hash}.
     */
    contains(key: Hex | Uint8Array): boolean;
    /**
     * Calculates the optimal number of bits per key (`m` in math literature) based
     * on the number of hash functions (`k` in math literature) used to generate the Bloom Filter.
     *
     * Mathematically, `m` is approximated as `(k / ln(2))` which is simplified
     * to the higher integer close to `(m / 0.69)` for computational efficiency.
     * It also ensures that `k` is within a practical range [1, 30], hence the function
     * - returns `2` for `k = 1`,
     * - returns `44` for `k >= 30`.
     *
     * @param {number} k - The number of keys.
     *
     * @return {number} - The number of bits per key.
     */
    static computeBestBitsPerKey(k: number): number;
    /**
     * Calculates the optimal number of hash functions (`k` in math literature)
     * based on bits per key (`m` in math literature).
     *
     * Mathematically, `k` is approximated as `(m * ln(2))` which is simplified
     * to the lower integer close to `(m * 0.69)` for computational efficiency.
     * It also ensures that `k` stays within a practical range [1, 30].
     *
     * @param m - The number of bits per key.
     *
     * @returns The calculated optimal `k` value.
     */
    static computeBestHashFunctionsQuantity(m: number): number;
    /**
     * Checks if the current BloomFilter instance is possible to join with another BloomFilter instance.
     *
     * @param {BloomFilter} other - The BloomFilter instance to check if it is possible to join with the current instance.
     *
     * @return {boolean} - Returns true if the BloomFilter instances have the same 'k' value and 'bytes' length, false otherwise.
     */
    isJoinable(other: BloomFilter): boolean;
    /**
     * Joins the current BloomFilter with another BloomFilter by performing a bitwise OR operation on the
     * data structures of the filters.
     * Both filters must have been generated with the same number of hash functions, and they must have the same length.
     *
     * @param other - The BloomFilter to join with.
     *
     * @returns A new BloomFilter that represents the result of the join operation.
     *          They keys made this and `other` filter may belong to the returned filter.
     *          Any key not part of the joined filter surely doesn't belong to the returned filter.
     *
     * @throws {InvalidOperation} If the k values of the BloomFilters are different.
     * @throws {InvalidOperation} If the length of the byte arrays are different.
     */
    join(other: BloomFilter): BloomFilter;
    /**
     * Creates a new instance of BloomFilterBuilder and adds the specified keys to it.
     * * Call {@link BloomFilterBuilder.add} to add more keys.
     * * Call {@link BloomFilterBuilder.build} to create a new Bloom filter once
     *
     * @param {...(Hex[] | Uint8Array[])} keys - The keys to be added to the BloomFilterBuilder.
     *
     * @returns {BloomFilterBuilder} - A new instance of BloomFilterBuilder with the specified keys added.
     *
     * @remarks Security auditable method, depends on
     * * {@link BloomFilterBuilder.add}.
     */
    static of(...keys: Hex[] | Uint8Array[]): BloomFilterBuilder;
}
/**
 * The `BloomFilterBuilder` class provides methods for constructing a Bloom filter,
 * This builder class allows you to add keys to the filter and specify its `m` (bits per key) and `k` (hash functions)
 * parameters before building it.
 *
 * @see {BloomFilter.of}
 *
 */
declare class BloomFilterBuilder {
    /**
     * The default value number of hash functions used to create {@link BloomFilter} instances.
     */
    private static readonly DEFAULT_K;
    /**
     * Map each element of the keys as likely part of the data structure of the Bloom filter to build.
     * Each key is mapped in `m` bits using `k` hash functions.
     *
     * @see {hash}
     */
    private readonly hashMap;
    /**
     * Adds one or more keys to the Bloom filter to create.
     *
     * @param {Hex[] | Uint8Array[]} keys - The keys to be added to Bloom filter to create.
     *
     * @return {this} - Returns this {@link BloomFilterBuilder} instance, the {@link this.hashMap} is updated to
     * map the keys presence in the filter data structure.
     *
     * @remarks Security auditable method, depends on
     * * {@link hash}.
     */
    add(...keys: Hex[] | Uint8Array[]): this;
    /**
     * Builds a Bloom filter with the specified parameters and returns it.
     *
     * @param k - The number of hash functions to use in the Bloom filter.  to BloomFilterBuilder.DEFAULT_K.
     * @param m - The number of bits per key in the Bloom filter. Defaults to the value computed by BloomFilter.computeBestBitsPerKey(k).
     *
     * @return The built Bloom filter.
     */
    build(k?: number, m?: number): BloomFilter;
}

/**
 * Marker interface for classes implementing hash functionalities.
 *
 * @interface
 */
interface Hash {
}

/**
 * Type of the wordlist size.
 * Every 4 bytes produce 3 words.
 */
type WordlistSizeType = 12 | 15 | 18 | 21 | 24;
/**
 * Size of the mnemonic words in bytes.
 */
type WordListRandomGeneratorSizeInBytes = 16 | 20 | 24 | 28 | 32;
declare class Mnemonic implements VeChainDataModel<Mnemonic> {
    /**
     * A TextEncoder instance used for encoding text to bytes.
     *
     * @type {TextEncoder}
     */
    private static readonly ENCODER;
    /**
     * Throws an exception because the mnemonic cannot be represented as a big integer.
     * @returns {bigint} The BigInt representation of the mnemonic.
     * @throws {InvalidOperation} The mnemonic cannot be represented as a bigint.
     * @override {@link VeChainDataModel#bi}
     * @remark The conversion to BigInt is not supported for a mnemonic.
     */
    get bi(): bigint;
    /**
     * Generates a mnemonic as encoded bytes.
     *
     * @returns {Uint8Array} The bytes representation of the words with spaces.
     */
    get bytes(): Uint8Array;
    /**
     * Throws an exception because the mnemonic cannot be represented as a number.
     * @returns {bigint} The number representation of the mnemonic.
     * @throws {InvalidOperation} The mnemonic cannot be represented as a number.
     * @override {@link VeChainDataModel#n}
     * @remark The conversion to number is not supported for a mnemonic.
     */
    get n(): number;
    /**
     *
     * @param _that The mnemonic to compare with.
     */
    compareTo(_that: Mnemonic): number;
    isEqual(_that: Mnemonic): boolean;
    /**
     * Convert the number of words to the corresponding strength.
     *
     * @param numberOfWords The number of words.
     *
     * @returns {number} The corresponding strength.
     *
     * @throws {InvalidDataType} If the number of words is not valid.
     */
    private static wordsNoToStrength;
    /**
     * Derives a private key from a given list of
     * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
     * and a derivation path as in the examples.
     *
     * @example `m/0` (default)
     * @example `m/0/2`
     * @example `m/0/2/4/6`
     *
     * @param {string[]} words - The set of words used for mnemonic generation.
     * @param {string} [path='m/0'] - The derivation path from the current node.
     *
     * @returns {Uint8Array} - The derived private key as a Uint8Array.
     *
     * @throws {InvalidHDNode}
     *
     * @remarks Security auditable method, depends on
     * * {@link HDNode}.
     */
    static toPrivateKey(words: string[], path?: string): Uint8Array;
    /**
     * Generates a
     * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
     * phrase using the specified wordlist size and random generator.
     *
     * @param {WordlistSizeType} wordlistSize The number of words to generate the mnemonic.
     * @param {function} [randomGenerator] The random generator function used to generate the entropy.
     *
     * @returns {Mnemonic} The generated mnemonic.
     *
     * @throws {InvalidDataType} If the number of words is not valid.
     *
     * @remarks Security auditable method, depends on
     * * [entropyToMnemonic](https://github.com/paulmillr/scure-bip39);
     * * [generateMnemonic](https://github.com/paulmillr/scure-bip39);
     * * `randomGenerator` - **Must provide a cryptographic secure source of entropy
     *    else any secure audit certification related with this software is invalid.**
     */
    static of(wordlistSize?: WordlistSizeType, randomGenerator?: (numberOfBytes: WordListRandomGeneratorSizeInBytes) => Uint8Array): string[];
    /**
     * Check if the given mnemonic words are valid.
     *
     * @param {string | string[]} words The mnemonic words to check.
     *
     * @returns {boolean} true if the words are valid, false otherwise.
     *
     * @remarks Security auditable method, depends on
     * * [validateMnemonic](https://github.com/paulmillr/scure-bip39).
     */
    static isValid(words: string | string[]): boolean;
}
declare const mnemonic: {
    deriveAddress: (words: string[], path?: string) => string;
    derivePrivateKey: (words: string[], path?: string) => Uint8Array;
    generate: (wordlistSize?: WordlistSizeType, randomGenerator?: (numberOfBytes: WordListRandomGeneratorSizeInBytes) => Uint8Array) => string[];
    isValid: (words: string[]) => boolean;
};

/**
 * Represents a hexadecimal numeric value compatible with the result of
 * [ethers](https://docs.ethers.org/v6/)
 * [utils.toQuantity](https://docs.ethers.org/v6/api/utils/#toQuantity) function.
 * This is most commonly used for JSON-RPC numeric values.
 *
 * @remarks A quantity instance:
 * * has not empty content,
 * * the hexadecimal representation removes any not meaningful zero on the left side of the expression,
 * * represents only positive integers.
 *
 * @extends HexUInt
 */
declare class Quantity extends HexUInt {
    /**
     * Creates a Quantity instance from a bigint or number given expression
     *
     * @param {bigint | number} exp - The value to be expressed as Quantity object:
     * * bigint must be positive;
     * * number must be positive, it is converted to bigint to create the Quantity.
     *
     * @returns {Quantity} - The new Quantity object.
     *
     * @throws {InvalidDataType} - If the provided expression is not a positive integer value.
     */
    static of(exp: bigint | number): Quantity;
}

/**
 * Represents a text string encoded according the *Normalization Form Canonical Composition*
 * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence).
 *
 * @implements {VeChainDataModel<Txt>}
 */
declare class Txt extends String implements VeChainDataModel<Txt> {
    /**
     * Decoder object used for decoding bytes as text data.
     *
     * @class
     * @constructor
     */
    private static readonly DECODER;
    /**
     * *Normalization Form Canonical Composition*
     * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence)
     * flag.
     *
     * @type {string}
     * @constant
     */
    private static readonly NFC;
    /**
     * A TextEncoder instance used for encoding text to bytes.
     *
     * @type {TextEncoder}
     */
    private static readonly ENCODER;
    /**
     * Creates a new instance of this class representing the `exp` string
     * normalized according the *Canonical Composition Form*
     * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence).
     *
     * @param {string} exp - The expression to be passed to the constructor.
     * @protected
     * @constructor
     */
    protected constructor(exp: string);
    /**
     * Converts the current Txt string to a BigInt.
     *
     * @returns {bigint} The BigInt representation of the Txt string.
     *
     *  @throws {InvalidOperation} If the conversion to BigInt fails because this Txt string doesn't represent an integer.
     */
    get bi(): bigint;
    /**
     * Converts the current Txt string to a buffer of bytes.
     *
     * @returns {Uint8Array} The bytes representation of the Txt string.
     */
    get bytes(): Uint8Array;
    /**
     * Returns the value of n as a number.
     *
     * @returns {number} The value of n as a number.
     */
    /**
     * Converts the current Txt string to a number.
     *
     * @returns {number} The numeric value of the Txt string.
     *
     * @throws {InvalidOperation} If the conversion to number fails because this Txt string doesn't represent a decimal number.
     */
    get n(): number;
    /**
     * Compares the current instance to another instance of Txt.
     *
     * @param {Txt} that - The instance to compare with.
     *
     * @return {number} - A negative number if the current instance is less than the specified instance,
     *                    zero if they are equal, or a positive number if the current instance is greater.
     */
    compareTo(that: Txt): number;
    /**
     * Checks if the current Txt object is equal to the given Txt object.
     *
     * @param {Txt} that - The Txt object to compare with.
     *
     *  @return {boolean} - True if the objects are equal, false otherwise.
     */
    isEqual(that: Txt): boolean;
    /**
     * Returns a string representation of the object.
     *
     * @returns {string} A string representation of the object.
     */
    toString(): string;
    /**
     * Creates a new Txt instance from the provided expression.
     *
     * @param {bigint | number | string | Uint8Array} exp - The expression to convert to Txt:
     * * {@link bigint} is represented as a {@link NFC} encoded string expressing the value in base 10;
     * * {@link number} is represented as a {@link NFC} encoded string expressing the value in base 10;
     * * {@link string} is encoded as {@link NFC} string;
     * * {@link Uint8Array} is {@link NFC} decoded to a string.
     *
     * @returns {Txt} - A new Txt instance.
     */
    static of(exp: bigint | number | string | Uint8Array): Txt;
}

/**
 * Represents a revision for a Thor transaction or block.
 *
 * @remarks The string representation of the revision is always expressed as a number in base 10.
 *
 * @extends Txt
 */
declare class Revision extends Txt {
    /**
     * Regular expression pattern for revision strings.
     * Revision strings can be one of the following:
     * - "best": indicating the best revision
     * - "finalized": indicating a finalized revision
     * - A positive numeric string indicating a specific revision
     *
     * @type {RegExp}
     */
    private static readonly REGEX_DECIMAL_REVISION;
    /**
     * Determines if the given value is valid.
     * This is true if the given value is
     * - "best" string or {@link Txt}: indicating the best revision;
     * - "finalized" string or {@link Txt}: indicating a finalized revision;
     * - a positive number;
     * - a positive numeric decimal or `0x` prefixed hexadecimal string indicating a specific revision,
     *
     * @param {bigint | number | string | Hex | Txt} value - The value to be validated.
     * @returns {boolean} - Returns `true` if the value is valid, `false` otherwise.
     */
    static isValid(value: number | string): boolean;
    /**
     * Creates a new Revision object from the given value.
     *
     * @param {bigint | number | string | Uint8Array | Hex } value - The value to create the Revision from:
     * * {@link Hex} must be positive;
     * * {@link Uint8Array} is decoded as a string: see {@link Txt.of}.
     *
     * @returns {Revision} - The created Revision object.
     *
     *  @throws {InvalidDataType} if the given value is not a valid revision: see {@link isValid}.
     *
     * @remarks The string representation of the revision is always expressed as a number in base 10.
     * @remarks The {@link Uint8Array} value is decoded as a string content: see {@link Txt.of}.
     */
    static of(value: bigint | number | string | Uint8Array | Hex): Txt;
}
declare const revisionUtils: {
    isRevisionAccount: (revision: string | number) => boolean;
    isRevisionBlock: (revision: string | number) => boolean;
};

/**
 * The ThorId class represents a Thor ID value, which is a hexadecimal positive integer having 64 digits.
 *
 * @extends HexInt
 */
declare class ThorId extends HexUInt {
    /**
     * Number of digits to represent a Thor ID value.
     *
     * @remarks The `0x` prefix is excluded.
     *
     * @type {number}
     */
    private static readonly DIGITS;
    /**
     * Constructs a ThorId object with the provided hexadecimal value.
     *
     * @param {HexUInt} huint - The hexadecimal value representing the ThorId.
     *
     * @throws {InvalidDataType} - If the provided value is not a valid ThorId expression.
     */
    protected constructor(huint: HexUInt);
    /**
     * Check if the given expression is a valid ThorId.
     *
     * @param {string} exp - The expression to be validated.
     *
     * @return {boolean} Returns true if the expression is a valid ThorId, false otherwise.
     */
    static isValid(exp: string): boolean;
    /**
     * Determines whether the given string is a valid hex number prefixed with '0x'.
     *
     * @param {string} exp - The hex number to be checked.
     *
     *  @returns {boolean} - True if the hex number is valid, false otherwise.
     */
    static isValid0x(exp: string): boolean;
    /**
     * Creates a new ThorId object from the given expression.
     *
     * @param {bigint | number | string | Hex | Uint8Array} exp - The expression to create the ThorId from.
     *     It can be one of the following types:
     *     - bigint: A BigInteger value that represents the ThorId.
     *     - number: A number value that represents the ThorId.
     *     - string: A string value that represents the ThorId.
     *     - HexUInt: A HexUInt object that represents the ThorId.
     *     - Uint8Array: A Uint8Array object that represents the ThorId.
     *
     * @returns {ThorId} - A new ThorId object created from the given expression.
     *
     * @throws {InvalidDataType} If the given expression is not a valid hexadecimal positive integer expression.
     */
    static of(exp: bigint | number | string | Uint8Array | HexUInt): ThorId;
}

/**
 * Represents the result of an [BLAKE](https://en.wikipedia.org/wiki/BLAKE_(hash_function)) [BlAKE2B 256](https://www.blake2.net/) hash operation.
 *
 * @extends HexUInt
 * @implements Hash
 */
declare class Blake2b256 extends HexUInt implements Hash {
    /**
     * Generates the [BLAKE](https://en.wikipedia.org/wiki/BLAKE_(hash_function)) [BLAKE2B 256](https://www.blake2.net/) hash of the given input.
     *
     * @param {bigint | number | string | Uint8Array | Hex} exp - The input value to hash.
     *
     * @returns {Sha256} - The [BLAKE2B 256](https://www.blake2.net/) hash of the input value.
     *
     * @throws {InvalidOperation} - If a hash error occurs.
     *
     * @remarks Security auditable method, depends on
     * * [`nh_blake2b.create(...).update(...).digest(...)`](https://github.com/paulmillr/noble-hashes#sha3-fips-shake-keccak).
     */
    static of(exp: bigint | number | string | Uint8Array | Hex): Blake2b256;
}
declare function blake2b256(data: string | Uint8Array, returnType: 'buffer'): Uint8Array;
declare function blake2b256(data: string | Uint8Array, returnType: 'hex'): string;

/**
 * Represents the result of an [SHA-3](https://en.wikipedia.org/wiki/SHA-3) [KECCAK 256](https://keccak.team/keccak.html) hash operation.
 *
 * @extends HexUInt
 * @implements Hash
 */
declare class Keccak256 extends HexUInt implements Hash {
    /**
     * Generates the [SHA-3](https://en.wikipedia.org/wiki/SHA-3) [KECCAK 256](https://keccak.team/keccak.html) hash of the given input.
     *
     * @param {bigint | number | string | Uint8Array | Hex} exp - The input value to hash.
     *
     * @returns {Sha256} - The [KECCAK 256](https://keccak.team/keccak.html) hash of the input value.
     *
     * @throws {InvalidOperation} - If a hash error occurs.
     *
     * @remarks Security auditable method, depends on
     * * [`nh_keccak_256`](https://github.com/paulmillr/noble-hashes#sha3-fips-shake-keccak).
     */
    static of(exp: bigint | number | string | Uint8Array | Hex): Keccak256;
}
declare function keccak256(data: string | Uint8Array, returnType: 'buffer'): Uint8Array;
declare function keccak256(data: string | Uint8Array, returnType: 'hex'): string;

/**
 * Represents the result of an [SHA256](https://en.wikipedia.org/wiki/SHA-2) hash operation.
 *
 * @extends HexUInt
 * @implements Hash
 */
declare class Sha256 extends HexUInt implements Hash {
    /**
     * Generates the [SHA 256](https://en.wikipedia.org/wiki/SHA-2) hash of the given input.
     *
     * @param {bigint | number | string | Uint8Array | Hex} exp - The input value to hash.
     *
     * @returns {Sha256} - The [SHA256](https://en.wikipedia.org/wiki/SHA-2) hash of the input value.
     *
     * @throws {InvalidOperation} - If a hash error occurs.
     *
     * @remarks Security auditable method, depends on
     * * [`nh_sha256.sha256`](https://github.com/paulmillr/noble-hashes#sha2-sha256-sha384-sha512-and-others).
     */
    static of(exp: bigint | number | string | Uint8Array): Sha256;
}
declare function sha256(data: string | Uint8Array, returnType: 'buffer'): Uint8Array;
declare function sha256(data: string | Uint8Array, returnType: 'hex'): string;

/**
 * Creates a [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
 * {@link bip32.HDKey} node
 * from [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) and from it
 * derives a child HDKey node based on the given derivation path.
 *
 * Secure audit function.
 * - [n_bip32](https://github.com/paulmillr/scure-bip32).
 * - [n_bip39](https://github.com/paulmillr/scure-bip39)
 *
 * @param {string[]} words - An array of words representing the mnemonic.
 * @param {string} path - The derivation path to derive the child node.
 * Default value is {@link VET_DERIVATION_PATH}.
 * @return {bip32.HDKey} - An instance of n_bip32.HDKey representing the derived child node.
 * @throws {InvalidHDNodeMnemonic,InvalidHDNode}
 */
declare function fromMnemonic(words: string[], path?: string): n_bip32.HDKey;
/**
 * Creates a [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
 * {@link bip32.HDKey} node from a private key and chain code.
 *
 * Secure audit function.
 * - [base58](https://github.com/paulmillr/scure-base)
 * - [n_bip32](https://github.com/paulmillr/scure-bip32).
 *
 * @param {Uint8Array} privateKey The private key.
 * @param {Uint8Array} chainCode The chain code.
 * @returns {bip32.HDKey} The `n_bip32.HDKey` object.
 * @throws {InvalidSecp256k1PrivateKey}
 */
declare function fromPrivateKey(privateKey: Uint8Array, chainCode: Uint8Array): n_bip32.HDKey;
/**
 * Creates a [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
 * {@link bip32.HDKey} node from a public key and chain code.
 *
 * @param {Uint8Array} publicKey - The public key bytes.
 * @param {Uint8Array} chainCode - The chain code bytes.
 * @returns {bip32.HDKey} - The `n_bip32.HDKey` object.
 * @throws {InvalidHDNode}
 */
declare function fromPublicKey(publicKey: Uint8Array, chainCode: Uint8Array): n_bip32.HDKey;
declare const HDNode: {
    fromMnemonic: typeof fromMnemonic;
    fromPrivateKey: typeof fromPrivateKey;
    fromPublicKey: typeof fromPublicKey;
};

/**
 * @interface Keystore
 * Represents a
 * [Web3 Secret Storage](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage)
 * keystore object that holds information about a private cryptographic key.
 * and its associated wallet address.
 *
 * @property {string} address - The wallet address associated with the stored private key.
 * @property {Object} crypto - The encryption information for the key.
 * @property {string} crypto.cipher - The encryption algorithm used.
 * @property {Object} crypto.cipherparams - Additional parameters for the encryption algorithm.
 * @property {string} crypto.cipherparams.iv - The initialization vector (IV) used for encryption.
 * @property {string} crypto.ciphertext - The encrypted private key.
 * @property {string} crypto.kdf - The key derivation function (KDF) used.
 * @property {Object} crypto.kdfparams - Additional parameters for the KDF.
 * @property {number} crypto.kdfparams.dklen - The derived private key length.
 * @property {number} crypto.kdfparams.n - The CPU/memory cost parameter for the key derivation function.
 * @property {number} crypto.kdfparams.p - The parallelization factor.
 * @property {number} crypto.kdfparams.r - The block size factor.
 * @property {string} crypto.kdfparams.salt - The salt value used in the KDF.
 * @property {string} crypto.mac - The MAC (Message Authentication Code)
 * to match the KDF function with the private key derived by the cyphered text stored.
 * @property {string} id - The
 * [unique identifier version 4](https://en.wikipedia.org/wiki/Universally_unique_identifier)
 * for the key store.
 * @property {number} version - The version number of the key store.
 */
interface Keystore {
    address: string;
    crypto: {
        cipher: string;
        cipherparams: {
            iv: string;
        };
        ciphertext: string;
        kdf: string;
        kdfparams: {
            dklen: number;
            n: number;
            p: number;
            r: number;
            salt: string;
        };
        mac: string;
    };
    id: string;
    version: number;
}

/**
 * Interface representing a keystore account.
 *
 * **WARNING:** call
 * ```javascript
 * privateKey.fill(0)
 * ```
 * after use to avoid to invalidate any security audit and certification granted to this code.
 *
 * @property {string} address - The address associated with the account.
 * @property {Uint8Array} privateKey - The private key associated with the account.
 *
 * @remarks **Differently from
 * [ethers KeystoreAccount](https://github.com/ethers-io/ethers.js/blob/main/src.ts/wallet/json-keystore.ts),
 * this type represents the private key as a buffer of bytes to avoid
 * [Memory Dumping](https://github.com/paulmillr/noble-hashes?tab=readme-ov-file#memory-dumping)
 * attack.**
 */
interface KeystoreAccount {
    address: string;
    privateKey: string;
    // @NOTE: Added ONLY for compatibility with ethers KeystoreAccount of ethers.
    mnemonic?: {
        path?: string;
        locale?: string;
        entropy: string;
    };
}

/**
 * Sets the keystore cryptography to experimental mode.
 *
 * @param experimentalCryptography - A boolean indicating whether the keystore cryptography is experimental or not.
 */
declare function useExperimentalCryptography(experimentalCryptography: boolean): void;
/**
 * Encrypts a given private key into a keystore format using the specified password.
 *
 * @param privateKey - The private key to be encrypted.
 * @param password - The password used for the encryption.
 * @returns A Promise that resolves to the encrypted keystore.
 */
declare function encrypt(privateKey: Buffer, password: string): Promise<Keystore>;
/**
 * Decrypts a keystore to obtain the private key using the given password.
 *
 * @throws {InvalidKeystoreError, InvalidKeystorePasswordError}
 * @param keystore - The keystore containing the encrypted private key.
 * @param password - The password used to decrypt the keystore.
 * @returns A Promise that resolves to the decrypted KeystoreAccount or rejects if the keystore or password is invalid.
 */
declare function decrypt(keystore: Keystore, password: string): Promise<KeystoreAccount>;
/**
 * Validates if the provided keystore adheres to the expected format and structure.
 *
 * @param keystore - The keystore to be validated.
 * @returns A boolean indicating whether the keystore is valid or not.
 */
declare function isValid(keystore: Keystore): boolean;
/**
 * Exports the keystore functions for encryption, decryption, and validation.
 */
declare const keystore: {
    encrypt: typeof encrypt;
    decrypt: typeof decrypt;
    isValid: typeof isValid;
    useExperimentalCryptography: typeof useExperimentalCryptography;
};

/**
 * Compresses a public key.
 *
 * Security audit function.
 * * [`ec` for elliptic curve](https://github.com/paulmillr/noble-curves)
 * * [n_utils](https://github.com/paulmillr/noble-curves?tab=readme-ov-file#utils-useful-utilities)
 *
 * @param {Uint8Array} publicKey - The uncompressed public key.
 *
 * @returns {Uint8Array} - The compressed public key.
 *
 * @see inflatePublicKey
 *
 */
declare function compressPublicKey(publicKey: Uint8Array): Uint8Array;
/**
 * Derives a public key from a given private key.
 *
 * Security audit function.
 * * [`ec` for elliptic curve](https://github.com/paulmillr/noble-curves)
 *
 * @param {Uint8Array} privateKey - The private key used to derive the public key.
 * @param {boolean} [isCompressed=true] - Boolean indicating whether the derived public key should be compressed or not.
 * @returns {Uint8Array} - The derived public key as a Uint8Array object.
 * @throws {InvalidSecp256k1PrivateKey}
 *
 * @see assertIsValidPrivateKey
 */
declare function derivePublicKey(privateKey: Uint8Array, isCompressed?: boolean): Uint8Array;
/**
 * Generates a new private key.
 *
 * Security audit function.
 * [`ec` for elliptic curve](https://github.com/paulmillr/noble-curves)
 *
 * @returns {Uint8Array} The newly generated private key as a buffer.
 */
declare function generatePrivateKey(): Promise<Uint8Array>;
/**
 * Inflates a compressed or uncompressed public key.
 *
 * Security audit function.
 * [`ec` for elliptic curve](https://github.com/paulmillr/noble-curves)
 *
 * @param {Uint8Array} publicKey - The compressed or uncompressed public key to inflate.
 *
 * @return {Uint8Array} - The inflated uncompressed public key.
 *
 * @see compressPublicKey
 */
declare function inflatePublicKey(publicKey: Uint8Array): Uint8Array;
/**
 * Check if the given hash is a valid message hash.
 *
 * Security audit function.
 * * [`ec` for elliptic curve](https://github.com/paulmillr/noble-curves)
 * * [n_utils](https://github.com/paulmillr/noble-curves?tab=readme-ov-file#utils-useful-utilities)
 *
 * @param {Uint8Array} hash - The hash of the message to validate.
 * @return {boolean} - Returns `true` if the hash is a valid message hash,
 * otherwise returns `false`.
 */
declare function isValidMessageHash(hash: Uint8Array): boolean;
/**
 * Checks if the given private key is valid.
 *
 * Security audit function.
 * * [`ec` for elliptic curve](https://github.com/paulmillr/noble-curves)
 *
 * @param {Uint8Array} privateKey - The private key to be checked.
 * @return {boolean} - Returns `true` if the private key is 32 bytes long
 * in the range between 0 and {@link PRIVATE_KEY_MAX_VALUE} excluded,
 * otherwise `false`.
 */
declare function isValidPrivateKey(privateKey: Uint8Array): boolean;
/**
 * Generates random bytes of specified length.
 *
 * The function relays on [noble-hashes](https://github.com/paulmillr/noble-hashes/blob/main/src/utils.ts)
 * functionality to delegate the OS to generate the random sequence according the host hardware.
 *
 * Security audit function.
 * * [_randomBytes](https://github.com/paulmillr/noble-curves?tab=readme-ov-file#utils-useful-utilities)
 *
 * @param {number} bytesLength - The length of the random bytes to generate.
 * @return {Uint8Array} - The generated random bytes as a Uint8Array object.
 * @throws Error with `crypto.getRandomValues must be defined`
 * message if no hardware for random generation is
 * available at runtime.
 */
declare function randomBytes(bytesLength?: number | undefined): Uint8Array;
/**
 * Recovers public key from a given message hash and signature.
 *
 * Security audit function.
 * [`ec` for elliptic curve](https://github.com/paulmillr/noble-curves)
 *
 * @param {Uint8Array} messageHash - The message hash to recover the public key from.
 * @param {Uint8Array} sig - The signature of the message.
 * @returns {Uint8Array} - The recovered public key.
 * @throws {InvalidSecp256k1MessageHash, InvalidSecp256k1Signature}
 *
 * @see assertIsValidSecp256k1MessageHash
 */
declare function recover(messageHash: Uint8Array, sig: Uint8Array): Uint8Array;
/**
 * Signs a message hash using a private key.
 *
 * Security audit function.
 * * [`ec` for elliptic curve](https://github.com/paulmillr/noble-curves)
 * * [n_utils](https://github.com/paulmillr/noble-curves?tab=readme-ov-file#utils-useful-utilities)
 *
 * @param {Uint8Array} messageHash - The message hash to be signed.
 * @param {Uint8Array} privateKey - The private key to use for signing.
 * @returns {Uint8Array} - The signature of the message hash.
 * @throws {InvalidSecp256k1MessageHash, InvalidSecp256k1PrivateKey}
 *
 * @see assertIsValidSecp256k1MessageHash
 * @see assertIsValidPrivateKey
 */
declare function sign(messageHash: Uint8Array, privateKey: Uint8Array): Uint8Array;
declare const secp256k1: {
    compressPublicKey: typeof compressPublicKey;
    derivePublicKey: typeof derivePublicKey;
    generatePrivateKey: typeof generatePrivateKey;
    inflatePublicKey: typeof inflatePublicKey;
    isValidMessageHash: typeof isValidMessageHash;
    isValidPrivateKey: typeof isValidPrivateKey;
    recover: typeof recover;
    randomBytes: typeof randomBytes;
    sign: typeof sign;
};

/**
 * ABI of the ERC20 token standard.
 *
 * @see [EIP 20](https://eips.ethereum.org/EIPS/eip-20)
 */
declare const ERC20_ABI: readonly [{
    readonly inputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "constructor";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "allowance";
        readonly type: "uint256";
    }, {
        readonly internalType: "uint256";
        readonly name: "needed";
        readonly type: "uint256";
    }];
    readonly name: "ERC20InsufficientAllowance";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "sender";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "balance";
        readonly type: "uint256";
    }, {
        readonly internalType: "uint256";
        readonly name: "needed";
        readonly type: "uint256";
    }];
    readonly name: "ERC20InsufficientBalance";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "approver";
        readonly type: "address";
    }];
    readonly name: "ERC20InvalidApprover";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "receiver";
        readonly type: "address";
    }];
    readonly name: "ERC20InvalidReceiver";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "sender";
        readonly type: "address";
    }];
    readonly name: "ERC20InvalidSender";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }];
    readonly name: "ERC20InvalidSpender";
    readonly type: "error";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "Approval";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "Transfer";
    readonly type: "event";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }];
    readonly name: "allowance";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "approve";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }];
    readonly name: "balanceOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "decimals";
    readonly outputs: readonly [{
        readonly internalType: "uint8";
        readonly name: "";
        readonly type: "uint8";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "name";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "symbol";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "totalSupply";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "transfer";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "transferFrom";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}];
/**
 * ABI of the ERC721 token standard.
 *
 * @see [EIP 721](https://eips.ethereum.org/EIPS/eip-721)
 */
declare const ERC721_ABI: readonly [{
    readonly inputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "constructor";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "sender";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }, {
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }];
    readonly name: "ERC721IncorrectOwner";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "ERC721InsufficientApproval";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "approver";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidApprover";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidOperator";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidOwner";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "receiver";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidReceiver";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "sender";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidSender";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "ERC721NonexistentToken";
    readonly type: "error";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "approved";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "Approval";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "bool";
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "ApprovalForAll";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "Transfer";
    readonly type: "event";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "approve";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }];
    readonly name: "balanceOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "getApproved";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }];
    readonly name: "isApprovedForAll";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "receiver";
        readonly type: "address";
    }];
    readonly name: "mintItem";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "name";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "ownerOf";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "safeTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }, {
        readonly internalType: "bytes";
        readonly name: "data";
        readonly type: "bytes";
    }];
    readonly name: "safeTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly internalType: "bool";
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "setApprovalForAll";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "bytes4";
        readonly name: "interfaceId";
        readonly type: "bytes4";
    }];
    readonly name: "supportsInterface";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "symbol";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "tokenURI";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "transferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}];
/**
 * ABI of the ERC1155 token standard.
 *
 * @see [EIP 1155](https://eips.ethereum.org/EIPS/eip-1155)
 */
declare const ERC1155_ABI: readonly [{
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "bool";
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "ApprovalForAll";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256[]";
        readonly name: "ids";
        readonly type: "uint256[]";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256[]";
        readonly name: "values";
        readonly type: "uint256[]";
    }];
    readonly name: "TransferBatch";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "TransferSingle";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "string";
        readonly name: "value";
        readonly type: "string";
    }, {
        readonly indexed: true;
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }];
    readonly name: "URI";
    readonly type: "event";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }];
    readonly name: "balanceOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address[]";
        readonly name: "accounts";
        readonly type: "address[]";
    }, {
        readonly internalType: "uint256[]";
        readonly name: "ids";
        readonly type: "uint256[]";
    }];
    readonly name: "balanceOfBatch";
    readonly outputs: readonly [{
        readonly internalType: "uint256[]";
        readonly name: "";
        readonly type: "uint256[]";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }];
    readonly name: "isApprovedForAll";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256[]";
        readonly name: "ids";
        readonly type: "uint256[]";
    }, {
        readonly internalType: "uint256[]";
        readonly name: "amounts";
        readonly type: "uint256[]";
    }, {
        readonly internalType: "bytes";
        readonly name: "data";
        readonly type: "bytes";
    }];
    readonly name: "safeBatchTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }, {
        readonly internalType: "uint256";
        readonly name: "amount";
        readonly type: "uint256";
    }, {
        readonly internalType: "bytes";
        readonly name: "data";
        readonly type: "bytes";
    }];
    readonly name: "safeTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly internalType: "bool";
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "setApprovalForAll";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "bytes4";
        readonly name: "interfaceId";
        readonly type: "bytes4";
    }];
    readonly name: "supportsInterface";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }];
    readonly name: "uri";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}];
/**
 * ABI of the VIP180 token standard.
 *
 * @see [VIP 180](https://github.com/vechain/VIPs/blob/master/vips/VIP-180.md)
 */
declare const VIP180_ABI: readonly [{
    readonly inputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "constructor";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "allowance";
        readonly type: "uint256";
    }, {
        readonly internalType: "uint256";
        readonly name: "needed";
        readonly type: "uint256";
    }];
    readonly name: "ERC20InsufficientAllowance";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "sender";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "balance";
        readonly type: "uint256";
    }, {
        readonly internalType: "uint256";
        readonly name: "needed";
        readonly type: "uint256";
    }];
    readonly name: "ERC20InsufficientBalance";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "approver";
        readonly type: "address";
    }];
    readonly name: "ERC20InvalidApprover";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "receiver";
        readonly type: "address";
    }];
    readonly name: "ERC20InvalidReceiver";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "sender";
        readonly type: "address";
    }];
    readonly name: "ERC20InvalidSender";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }];
    readonly name: "ERC20InvalidSpender";
    readonly type: "error";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "Approval";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "Transfer";
    readonly type: "event";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }];
    readonly name: "allowance";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "approve";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }];
    readonly name: "balanceOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "decimals";
    readonly outputs: readonly [{
        readonly internalType: "uint8";
        readonly name: "";
        readonly type: "uint8";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "name";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "symbol";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "totalSupply";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "transfer";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "transferFrom";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}];
/**
 * ABI of the VIP181 token standard.
 *
 * @see [VIP 181](https://github.com/vechain/VIPs/blob/master/vips/VIP-181.md)
 */
declare const VIP181_ABI: readonly [{
    readonly inputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "constructor";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "sender";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }, {
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }];
    readonly name: "ERC721IncorrectOwner";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "ERC721InsufficientApproval";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "approver";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidApprover";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidOperator";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidOwner";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "receiver";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidReceiver";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "sender";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidSender";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "ERC721NonexistentToken";
    readonly type: "error";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "approved";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "Approval";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "bool";
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "ApprovalForAll";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "Transfer";
    readonly type: "event";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "approve";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }];
    readonly name: "balanceOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "getApproved";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }];
    readonly name: "isApprovedForAll";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "receiver";
        readonly type: "address";
    }];
    readonly name: "mintItem";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "name";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "ownerOf";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "safeTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }, {
        readonly internalType: "bytes";
        readonly name: "data";
        readonly type: "bytes";
    }];
    readonly name: "safeTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly internalType: "bool";
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "setApprovalForAll";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "bytes4";
        readonly name: "interfaceId";
        readonly type: "bytes4";
    }];
    readonly name: "supportsInterface";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "symbol";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "tokenURI";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "transferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}];
/**
 * ABI of the VIP210 token standard.
 *
 * @see [VIP 210](https://github.com/vechain/VIPs/blob/master/vips/VIP-210.md)
 */
declare const VIP210_ABI: readonly [{
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "bool";
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "ApprovalForAll";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256[]";
        readonly name: "ids";
        readonly type: "uint256[]";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256[]";
        readonly name: "values";
        readonly type: "uint256[]";
    }];
    readonly name: "TransferBatch";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "TransferSingle";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "string";
        readonly name: "value";
        readonly type: "string";
    }, {
        readonly indexed: true;
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }];
    readonly name: "URI";
    readonly type: "event";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }];
    readonly name: "balanceOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address[]";
        readonly name: "accounts";
        readonly type: "address[]";
    }, {
        readonly internalType: "uint256[]";
        readonly name: "ids";
        readonly type: "uint256[]";
    }];
    readonly name: "balanceOfBatch";
    readonly outputs: readonly [{
        readonly internalType: "uint256[]";
        readonly name: "";
        readonly type: "uint256[]";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }];
    readonly name: "isApprovedForAll";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256[]";
        readonly name: "ids";
        readonly type: "uint256[]";
    }, {
        readonly internalType: "uint256[]";
        readonly name: "amounts";
        readonly type: "uint256[]";
    }, {
        readonly internalType: "bytes";
        readonly name: "data";
        readonly type: "bytes";
    }];
    readonly name: "safeBatchTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }, {
        readonly internalType: "uint256";
        readonly name: "amount";
        readonly type: "uint256";
    }, {
        readonly internalType: "bytes";
        readonly name: "data";
        readonly type: "bytes";
    }];
    readonly name: "safeTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly internalType: "bool";
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "setApprovalForAll";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "bytes4";
        readonly name: "interfaceId";
        readonly type: "bytes4";
    }];
    readonly name: "supportsInterface";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }];
    readonly name: "uri";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}];

/**
 * Create a Uint8Array filled with zero bytes of the specified size.
 *
 * @param {number} size - The size of the Uint8Array to create.
 * @returns {Uint8Array} - A Uint8Array filled with zero bytes.
 */
declare const ZERO_BYTES: (size: number) => Uint8Array;
/**
 * Regular expression pattern for matching integers expressed as base 10 strings.
 *
 * @type {RegExp}
 * @constant
 */
declare const INTEGER_REGEX: RegExp;
/**
 * Regular expression for matching numeric values expressed as base 10 strings.
 *
 * The regular expression matches the following numeric patterns:
 *    - Whole numbers:
 *      - Positive whole numbers: 1, 2, 3, ...
 *      - Negative whole numbers: -1, -2, -3, ...
 *    - Decimal numbers:
 *      - Positive decimal numbers: 1.0, 2.5, 3.14, ...
 *      - Negative decimal numbers: -1.0, -2.5, -3.14, ...
 *      - Decimal numbers without whole part:
 *        - Positive decimal numbers: .1, .5, .75, ...
 *        - Negative decimal numbers: -.1, -.5, -.75, ...
 *
 * @constant {RegExp} NUMERIC_REGEX
 */
declare const NUMERIC_REGEX: RegExp;

/**
 * Default VET derivation path.
 *
 * See https://github.com/satoshilabs/slips/blob/master/slip-0044.md for more info.
 */
declare const VET_DERIVATION_PATH = "m/44'/818'/0'/0";
/**
 * Prefix for extended public key
 */
declare const X_PUB_PREFIX: Buffer;
/**
 * Prefix for extended private key
 */
declare const X_PRIV_PREFIX: Buffer;

/**
 * Biggest value of private key
 * @internal
 */
declare const PRIVATE_KEY_MAX_VALUE: Buffer;

/**
 * Transaction gas constants
 */
declare const TRANSACTIONS_GAS_CONSTANTS: {
    /**
     * Default gas for a transaction
     * @internal
     */
    TX_GAS: number;
    /**
     * Default gas for a clause
     * @internal
     */
    CLAUSE_GAS: number;
    /**
     * Default gas for a contract creation clause
     * @internal
     */
    CLAUSE_GAS_CONTRACT_CREATION: number;
    /**
     * Zero gas data
     * @internal
     */
    ZERO_GAS_DATA: number;
    /**
     * Non-zero gas data
     * @internal
     */
    NON_ZERO_GAS_DATA: number;
};
/**
 * Kind for transaction features
 * @internal
 */
declare const TRANSACTION_FEATURES_KIND: {
    name: string;
    kind: NumericKind;
};
/**
 * Kind for transaction signature
 * @internal
 */
declare const TRANSACTION_SIGNATURE_KIND: {
    name: string;
    kind: BufferKind;
};
/**
 * RLP_CODER profiler for simple unsigned transactions
 * @internal
 */
declare const UNSIGNED_TRANSACTION_RLP: {
    readonly profile: RLPProfile;
    encodeObject(data: RLPValidObject): Buffer;
    decodeObject(encodedData: Buffer): RLPValueType;
};
/**
 * RLP_CODER profiler for simple signed transactions
 * @internal
 */
declare const SIGNED_TRANSACTION_RLP: {
    readonly profile: RLPProfile;
    encodeObject(data: RLPValidObject): Buffer;
    decodeObject(encodedData: Buffer): RLPValueType;
};
/**
 * Signature length
 * @internal
 */
declare const SIGNATURE_LENGTH = 65;
/**
 * Block ref field length
 * @internal
 */
declare const BLOCK_REF_LENGTH = 8;

declare const dataUtils: {
    decodeBytes32String: (hex: string) => string;
    encodeBytes32String: (value: string, zeroPadding?: "left" | "right") => string;
    isDecimalString: (data: string) => boolean;
    isNumeric: (value: string) => boolean;
};

/**
 * Checks if derivation path is valid
 *
 * @param derivationPath - Derivation path to check
 * @returns True if derivation path is valid, false otherwise
 */
declare function isDerivationPathValid(derivationPath: string): boolean;

/**
 * Calculates intrinsic gas that a tx costs with the given set of clauses.
 *
 * @note see the following link for more details: https://docs.vechain.org/core-concepts/transactions/transaction-calculation
 *
 * @param clauses - Transaction clauses
 * @returns Intrinsic gas of a set of clauses
 * @throws {InvalidDataType}
 */
declare function intrinsicGas(clauses: TransactionClause[]): number;
declare const TransactionUtils: {
    intrinsicGas: typeof intrinsicGas;
};

/**
 * The supported units of Ether currency which are supported by VeChainThor too.
 *
 * wei - The smallest unit of currency. 1 wei is equal to 10^-18 VET.
 * kewi - 1 kewi is equal to 10^3 wei.
 * mwei - 1 mwei is equal to 10^6 wei.
 * gwei - 1 gwei is equal to 10^9 wei.
 * szabo - 1 szabo is equal to 10^12 wei.
 * finney - 1 finney is equal to 10^15 wei.
 * ether - 1 ether is equal to 10^18 wei.
 */
type WEI_UNITS =
    | 'wei'
    | 'kwei'
    | 'mwei'
    | 'gwei'
    | 'szabo'
    | 'finney'
    | 'ether';

/**
 * Formats the given `value` into a decimal string,
 * assuming `decimalsOrUnits` decimal places.
 *
 * The method returns **value / 10^decimalsOrUnit**.
 *
 * @param {bigint | number | string} value - The value to be formatted,
 * it can be a hexadecimal expression prefixed with `0x`.
 * @param {bigint | number | WEI_UNITS} decimalsOrUnit - The number of decimals
 * or the name unit of measurement to use for formatting
 * (e.g. `gwei` for 9 decimal places).
 * Default value is {@link VET_DECIMAL_EXPONENT}.
 * @return {string} - The formatted value as a string,
 * as [ethers.formatUnits](https://docs.ethers.org/v6/api/utils/#formatUnits)
 * it returns at least a fractional digit unless the `digitsOrUnits` is `wei`.
 * @throws {InvalidDataType}
 *
 * @remarks This function is a drop-in replacement for
 * [ethers.formatUnits](https://docs.ethers.org/v6/api/utils/#formatUnits).
 *
 */
declare function formatUnits(value: bigint | number | string, decimalsOrUnit?: bigint | number | WEI_UNITS): string;
/**
 * Parses the given `value` and converts it to a BigInt value,
 * assuming `decimalsOrUnits` decimal places.
 *
 * The method returns **value * 10^digitsOrUnit**.
 *
 * @param {bigint | number | string} value - The value to parse and convert,
 * it can be a hexadecimal expression prefixed with `0x`.
 * @param {bigint | number | WEI_UNITS} digitsOrUnit - The number of digits
 * or the name of the unit of measurement to use for the conversion
 * (e.g. `gwei` for 9 decimal places),
 * Default value is VET_DECIMAL_EXPONENT.
 * @returns {bigint} - The parsed value converted to units.
 * @throws {InvalidDataType}
 *
 * @remarks This function is a drop-in replacement for
 * [ethers.parseUnits](https://docs.ethers.org/v6/api/utils/#parseUnits).
 */
declare function parseUnits(value: bigint | number | string, digitsOrUnit?: bigint | number | WEI_UNITS): bigint;
declare const unitsUtils: {
    formatUnits: typeof formatUnits;
    formatVET: (value: bigint | number | string) => string;
    parseUnits: typeof parseUnits;
    parseVET: (value: string) => bigint;
};

type core_Account = Account;
declare const core_Account: typeof Account;
type core_AccountType = AccountType;
type core_Address = Address;
declare const core_Address: typeof Address;
type core_ArrayKind = ArrayKind;
declare const core_BLOCK_REF_LENGTH: typeof BLOCK_REF_LENGTH;
type core_Blake2b256 = Blake2b256;
declare const core_Blake2b256: typeof Blake2b256;
type core_BloomFilter = BloomFilter;
declare const core_BloomFilter: typeof BloomFilter;
type core_BufferOutput = BufferOutput;
type core_BytesLike = BytesLike;
type core_Certificate = Certificate;
type core_ClauseOptions = ClauseOptions;
type core_Currency = Currency;
type core_DataOutput = DataOutput;
type core_DeployParams = DeployParams;
declare const core_ERC1155_ABI: typeof ERC1155_ABI;
declare const core_ERC20_ABI: typeof ERC20_ABI;
declare const core_ERC721_ABI: typeof ERC721_ABI;
type core_EventFragment = EventFragment;
type core_ExtendedTransactionClause = ExtendedTransactionClause;
type core_FormatType = FormatType;
type core_FunctionFragment = FunctionFragment;
declare const core_HDNode: typeof HDNode;
type core_Hash = Hash;
type core_Hex = Hex;
declare const core_Hex: typeof Hex;
type core_HexInt = HexInt;
declare const core_HexInt: typeof HexInt;
type core_HexUInt = HexUInt;
declare const core_HexUInt: typeof HexUInt;
declare const core_INTEGER_REGEX: typeof INTEGER_REGEX;
type core_Interface = Interface;
type core_InterfaceAbi = InterfaceAbi;
type core_Keccak256 = Keccak256;
declare const core_Keccak256: typeof Keccak256;
type core_Keystore = Keystore;
type core_KeystoreAccount = KeystoreAccount;
type core_Log = Log;
declare const core_MAINNET_NETWORK: typeof MAINNET_NETWORK;
type core_Mnemonic = Mnemonic;
declare const core_Mnemonic: typeof Mnemonic;
declare const core_NUMERIC_REGEX: typeof NUMERIC_REGEX;
declare const core_PRIVATE_KEY_MAX_VALUE: typeof PRIVATE_KEY_MAX_VALUE;
type core_ParamType = ParamType;
type core_Quantity = Quantity;
declare const core_Quantity: typeof Quantity;
declare const core_RLPBase: typeof RLPBase;
type core_RLPInput = RLPInput;
type core_RLPOutput = RLPOutput;
type core_RLPProfile = RLPProfile;
declare const core_RLPProfiles: typeof RLPProfiles;
type core_RLPValidObject = RLPValidObject;
type core_RLPValueType = RLPValueType;
declare const core_RLP_CODER: typeof RLP_CODER;
type core_Result = Result;
type core_Revision = Revision;
declare const core_Revision: typeof Revision;
declare const core_SIGNATURE_LENGTH: typeof SIGNATURE_LENGTH;
declare const core_SIGNED_TRANSACTION_RLP: typeof SIGNED_TRANSACTION_RLP;
declare const core_SOLO_NETWORK: typeof SOLO_NETWORK;
type core_ScalarKind = ScalarKind;
declare const core_ScalarKind: typeof ScalarKind;
type core_Sha256 = Sha256;
declare const core_Sha256: typeof Sha256;
type core_StructKind = StructKind;
declare const core_TESTNET_NETWORK: typeof TESTNET_NETWORK;
declare const core_TRANSACTIONS_GAS_CONSTANTS: typeof TRANSACTIONS_GAS_CONSTANTS;
declare const core_TRANSACTION_FEATURES_KIND: typeof TRANSACTION_FEATURES_KIND;
declare const core_TRANSACTION_SIGNATURE_KIND: typeof TRANSACTION_SIGNATURE_KIND;
type core_ThorId = ThorId;
declare const core_ThorId: typeof ThorId;
type core_Transaction = Transaction;
declare const core_Transaction: typeof Transaction;
type core_TransactionBody = TransactionBody;
type core_TransactionClause = TransactionClause;
declare const core_TransactionHandler: typeof TransactionHandler;
declare const core_TransactionUtils: typeof TransactionUtils;
type core_Txt = Txt;
declare const core_Txt: typeof Txt;
declare const core_UNSIGNED_TRANSACTION_RLP: typeof UNSIGNED_TRANSACTION_RLP;
declare const core_VET_DERIVATION_PATH: typeof VET_DERIVATION_PATH;
declare const core_VIP180_ABI: typeof VIP180_ABI;
declare const core_VIP181_ABI: typeof VIP181_ABI;
declare const core_VIP210_ABI: typeof VIP210_ABI;
declare const core_VTHO_ADDRESS: typeof VTHO_ADDRESS;
type core_VeChainDataModel<T> = VeChainDataModel<T>;
type core_WEI_UNITS = WEI_UNITS;
type core_WordListRandomGeneratorSizeInBytes = WordListRandomGeneratorSizeInBytes;
type core_WordlistSizeType = WordlistSizeType;
declare const core_X_PRIV_PREFIX: typeof X_PRIV_PREFIX;
declare const core_X_PUB_PREFIX: typeof X_PUB_PREFIX;
declare const core_ZERO_ADDRESS: typeof ZERO_ADDRESS;
declare const core_ZERO_BYTES: typeof ZERO_BYTES;
declare const core_abi: typeof abi;
declare const core_addressUtils: typeof addressUtils;
declare const core_assertCompactFixedHexBlobBuffer: typeof assertCompactFixedHexBlobBuffer;
declare const core_assertFixedHexBlobKindBuffer: typeof assertFixedHexBlobKindBuffer;
declare const core_assertFixedHexBlobKindData: typeof assertFixedHexBlobKindData;
declare const core_assertValidHexBlobKindBuffer: typeof assertValidHexBlobKindBuffer;
declare const core_assertValidHexBlobKindData: typeof assertValidHexBlobKindData;
declare const core_assertValidNumericKindBuffer: typeof assertValidNumericKindBuffer;
declare const core_blake2b256: typeof blake2b256;
declare const core_certificate: typeof certificate;
declare const core_clauseBuilder: typeof clauseBuilder;
declare const core_coder: typeof coder;
declare const core_dataUtils: typeof dataUtils;
declare const core_decodeBufferToHexWithLeadingZeros: typeof decodeBufferToHexWithLeadingZeros;
declare const core_decodeBufferToNumberOrHex: typeof decodeBufferToNumberOrHex;
declare const core_encodeBigIntToBuffer: typeof encodeBigIntToBuffer;
declare const core_encodeCompactFixedHexBlob: typeof encodeCompactFixedHexBlob;
declare const core_fragment: typeof fragment;
declare const core_isDerivationPathValid: typeof isDerivationPathValid;
declare const core_keccak256: typeof keccak256;
declare const core_keystore: typeof keystore;
declare const core_mnemonic: typeof mnemonic;
declare const core_networkInfo: typeof networkInfo;
declare const core_revisionUtils: typeof revisionUtils;
declare const core_secp256k1: typeof secp256k1;
declare const core_sha256: typeof sha256;
declare const core_unitsUtils: typeof unitsUtils;
declare const core_validateNumericKindData: typeof validateNumericKindData;
declare namespace core {
  export { core_Account as Account, type core_AccountType as AccountType, core_Address as Address, type core_ArrayKind as ArrayKind, core_BLOCK_REF_LENGTH as BLOCK_REF_LENGTH, core_Blake2b256 as Blake2b256, core_BloomFilter as BloomFilter, type core_BufferOutput as BufferOutput, type core_BytesLike as BytesLike, type core_Certificate as Certificate, type core_ClauseOptions as ClauseOptions, type core_Currency as Currency, type core_DataOutput as DataOutput, type core_DeployParams as DeployParams, core_ERC1155_ABI as ERC1155_ABI, core_ERC20_ABI as ERC20_ABI, core_ERC721_ABI as ERC721_ABI, type core_EventFragment as EventFragment, type core_ExtendedTransactionClause as ExtendedTransactionClause, type core_FormatType as FormatType, type core_FunctionFragment as FunctionFragment, core_HDNode as HDNode, type core_Hash as Hash, core_Hex as Hex, core_HexInt as HexInt, core_HexUInt as HexUInt, core_INTEGER_REGEX as INTEGER_REGEX, type core_Interface as Interface, type core_InterfaceAbi as InterfaceAbi, core_Keccak256 as Keccak256, type core_Keystore as Keystore, type core_KeystoreAccount as KeystoreAccount, type core_Log as Log, core_MAINNET_NETWORK as MAINNET_NETWORK, core_Mnemonic as Mnemonic, core_NUMERIC_REGEX as NUMERIC_REGEX, core_PRIVATE_KEY_MAX_VALUE as PRIVATE_KEY_MAX_VALUE, type core_ParamType as ParamType, core_Quantity as Quantity, core_RLPBase as RLPBase, type core_RLPInput as RLPInput, type core_RLPOutput as RLPOutput, type core_RLPProfile as RLPProfile, core_RLPProfiles as RLPProfiles, type core_RLPValidObject as RLPValidObject, type core_RLPValueType as RLPValueType, core_RLP_CODER as RLP_CODER, type core_Result as Result, core_Revision as Revision, core_SIGNATURE_LENGTH as SIGNATURE_LENGTH, core_SIGNED_TRANSACTION_RLP as SIGNED_TRANSACTION_RLP, core_SOLO_NETWORK as SOLO_NETWORK, core_ScalarKind as ScalarKind, core_Sha256 as Sha256, type core_StructKind as StructKind, core_TESTNET_NETWORK as TESTNET_NETWORK, core_TRANSACTIONS_GAS_CONSTANTS as TRANSACTIONS_GAS_CONSTANTS, core_TRANSACTION_FEATURES_KIND as TRANSACTION_FEATURES_KIND, core_TRANSACTION_SIGNATURE_KIND as TRANSACTION_SIGNATURE_KIND, core_ThorId as ThorId, core_Transaction as Transaction, type core_TransactionBody as TransactionBody, type core_TransactionClause as TransactionClause, core_TransactionHandler as TransactionHandler, core_TransactionUtils as TransactionUtils, core_Txt as Txt, core_UNSIGNED_TRANSACTION_RLP as UNSIGNED_TRANSACTION_RLP, core_VET_DERIVATION_PATH as VET_DERIVATION_PATH, core_VIP180_ABI as VIP180_ABI, core_VIP181_ABI as VIP181_ABI, core_VIP210_ABI as VIP210_ABI, core_VTHO_ADDRESS as VTHO_ADDRESS, type core_VeChainDataModel as VeChainDataModel, type core_WEI_UNITS as WEI_UNITS, type core_WordListRandomGeneratorSizeInBytes as WordListRandomGeneratorSizeInBytes, type core_WordlistSizeType as WordlistSizeType, core_X_PRIV_PREFIX as X_PRIV_PREFIX, core_X_PUB_PREFIX as X_PUB_PREFIX, core_ZERO_ADDRESS as ZERO_ADDRESS, core_ZERO_BYTES as ZERO_BYTES, core_abi as abi, core_addressUtils as addressUtils, core_assertCompactFixedHexBlobBuffer as assertCompactFixedHexBlobBuffer, core_assertFixedHexBlobKindBuffer as assertFixedHexBlobKindBuffer, core_assertFixedHexBlobKindData as assertFixedHexBlobKindData, core_assertValidHexBlobKindBuffer as assertValidHexBlobKindBuffer, core_assertValidHexBlobKindData as assertValidHexBlobKindData, core_assertValidNumericKindBuffer as assertValidNumericKindBuffer, core_blake2b256 as blake2b256, core_certificate as certificate, core_clauseBuilder as clauseBuilder, core_coder as coder, core_dataUtils as dataUtils, core_decodeBufferToHexWithLeadingZeros as decodeBufferToHexWithLeadingZeros, core_decodeBufferToNumberOrHex as decodeBufferToNumberOrHex, core_encodeBigIntToBuffer as encodeBigIntToBuffer, core_encodeCompactFixedHexBlob as encodeCompactFixedHexBlob, core_fragment as fragment, core_isDerivationPathValid as isDerivationPathValid, core_keccak256 as keccak256, core_keystore as keystore, core_mnemonic as mnemonic, core_networkInfo as networkInfo, core_revisionUtils as revisionUtils, core_secp256k1 as secp256k1, core_sha256 as sha256, core_unitsUtils as unitsUtils, core_validateNumericKindData as validateNumericKindData, ethers as vechain_sdk_core_ethers };
}

export { Account, type AccountType, Address, type ArrayKind, BLOCK_REF_LENGTH, Blake2b256, BloomFilter, type BufferOutput, type BytesLike, type Certificate, type ClauseOptions, type Currency, type DataOutput, type DeployParams, ERC1155_ABI, ERC20_ABI, ERC721_ABI, type EventFragment, type ExtendedTransactionClause, type FormatType, type FunctionFragment, HDNode, type Hash, Hex, HexInt, HexUInt, INTEGER_REGEX, type Interface, type InterfaceAbi, Keccak256, type Keystore, type KeystoreAccount, type Log, MAINNET_NETWORK, Mnemonic, NUMERIC_REGEX, PRIVATE_KEY_MAX_VALUE, type ParamType, Quantity, RLPBase, type RLPInput, type RLPOutput, type RLPProfile, RLPProfiles, type RLPValidObject, type RLPValueType, RLP_CODER, type Result, Revision, SIGNATURE_LENGTH, SIGNED_TRANSACTION_RLP, SOLO_NETWORK, ScalarKind, Sha256, type StructKind, TESTNET_NETWORK, TRANSACTIONS_GAS_CONSTANTS, TRANSACTION_FEATURES_KIND, TRANSACTION_SIGNATURE_KIND, ThorId, Transaction, type TransactionBody, type TransactionClause, TransactionHandler, TransactionUtils, Txt, UNSIGNED_TRANSACTION_RLP, VET_DERIVATION_PATH, VIP180_ABI, VIP181_ABI, VIP210_ABI, VTHO_ADDRESS, type VeChainDataModel, type WEI_UNITS, type WordListRandomGeneratorSizeInBytes, type WordlistSizeType, X_PRIV_PREFIX, X_PUB_PREFIX, ZERO_ADDRESS, ZERO_BYTES, abi, addressUtils, assertCompactFixedHexBlobBuffer, assertFixedHexBlobKindBuffer, assertFixedHexBlobKindData, assertValidHexBlobKindBuffer, assertValidHexBlobKindData, assertValidNumericKindBuffer, blake2b256, certificate, clauseBuilder, coder, core, dataUtils, decodeBufferToHexWithLeadingZeros, decodeBufferToNumberOrHex, encodeBigIntToBuffer, encodeCompactFixedHexBlob, fragment, isDerivationPathValid, keccak256, keystore, mnemonic, networkInfo, revisionUtils, secp256k1, sha256, unitsUtils, validateNumericKindData };
