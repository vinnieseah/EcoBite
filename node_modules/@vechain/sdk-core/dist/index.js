"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Account: () => Account,
  Address: () => Address,
  BLOCK_REF_LENGTH: () => BLOCK_REF_LENGTH,
  Blake2b256: () => Blake2b256,
  BloomFilter: () => BloomFilter,
  ERC1155_ABI: () => ERC1155_ABI,
  ERC20_ABI: () => ERC20_ABI,
  ERC721_ABI: () => ERC721_ABI,
  HDNode: () => HDNode,
  Hex: () => Hex,
  HexInt: () => HexInt,
  HexUInt: () => HexUInt,
  INTEGER_REGEX: () => INTEGER_REGEX,
  Keccak256: () => Keccak256,
  MAINNET_NETWORK: () => MAINNET_NETWORK,
  Mnemonic: () => Mnemonic,
  NUMERIC_REGEX: () => NUMERIC_REGEX,
  PRIVATE_KEY_MAX_VALUE: () => PRIVATE_KEY_MAX_VALUE,
  Quantity: () => Quantity,
  RLPBase: () => RLPBase,
  RLPProfiles: () => RLPProfiles,
  RLP_CODER: () => RLP_CODER,
  Revision: () => Revision,
  SIGNATURE_LENGTH: () => SIGNATURE_LENGTH,
  SIGNED_TRANSACTION_RLP: () => SIGNED_TRANSACTION_RLP,
  SOLO_NETWORK: () => SOLO_NETWORK,
  Sha256: () => Sha256,
  TESTNET_NETWORK: () => TESTNET_NETWORK,
  TRANSACTIONS_GAS_CONSTANTS: () => TRANSACTIONS_GAS_CONSTANTS,
  TRANSACTION_FEATURES_KIND: () => TRANSACTION_FEATURES_KIND,
  TRANSACTION_SIGNATURE_KIND: () => TRANSACTION_SIGNATURE_KIND,
  ThorId: () => ThorId,
  Transaction: () => Transaction,
  TransactionHandler: () => TransactionHandler,
  TransactionUtils: () => TransactionUtils,
  Txt: () => Txt,
  UNSIGNED_TRANSACTION_RLP: () => UNSIGNED_TRANSACTION_RLP,
  VET_DERIVATION_PATH: () => VET_DERIVATION_PATH,
  VIP180_ABI: () => VIP180_ABI,
  VIP181_ABI: () => VIP181_ABI,
  VIP210_ABI: () => VIP210_ABI,
  VTHO_ADDRESS: () => VTHO_ADDRESS,
  X_PRIV_PREFIX: () => X_PRIV_PREFIX,
  X_PUB_PREFIX: () => X_PUB_PREFIX,
  ZERO_ADDRESS: () => ZERO_ADDRESS,
  ZERO_BYTES: () => ZERO_BYTES,
  abi: () => abi,
  addressUtils: () => addressUtils,
  assertCompactFixedHexBlobBuffer: () => assertCompactFixedHexBlobBuffer,
  assertFixedHexBlobKindBuffer: () => assertFixedHexBlobKindBuffer,
  assertFixedHexBlobKindData: () => assertFixedHexBlobKindData,
  assertValidHexBlobKindBuffer: () => assertValidHexBlobKindBuffer,
  assertValidHexBlobKindData: () => assertValidHexBlobKindData,
  assertValidNumericKindBuffer: () => assertValidNumericKindBuffer,
  blake2b256: () => blake2b256,
  certificate: () => certificate,
  clauseBuilder: () => clauseBuilder,
  coder: () => coder,
  core: () => core_exports,
  dataUtils: () => dataUtils,
  decodeBufferToHexWithLeadingZeros: () => decodeBufferToHexWithLeadingZeros,
  decodeBufferToNumberOrHex: () => decodeBufferToNumberOrHex,
  encodeBigIntToBuffer: () => encodeBigIntToBuffer,
  encodeCompactFixedHexBlob: () => encodeCompactFixedHexBlob,
  fragment: () => fragment,
  isDerivationPathValid: () => isDerivationPathValid,
  keccak256: () => keccak256,
  keystore: () => keystore3,
  mnemonic: () => mnemonic,
  networkInfo: () => networkInfo,
  revisionUtils: () => revisionUtils,
  secp256k1: () => secp256k12,
  sha256: () => sha2563,
  unitsUtils: () => unitsUtils,
  validateNumericKindData: () => validateNumericKindData,
  vechain_sdk_core_ethers: () => import_ethers6.ethers
});
module.exports = __toCommonJS(src_exports);

// src/core.ts
var core_exports = {};
__export(core_exports, {
  Account: () => Account,
  Address: () => Address,
  BLOCK_REF_LENGTH: () => BLOCK_REF_LENGTH,
  Blake2b256: () => Blake2b256,
  BloomFilter: () => BloomFilter,
  ERC1155_ABI: () => ERC1155_ABI,
  ERC20_ABI: () => ERC20_ABI,
  ERC721_ABI: () => ERC721_ABI,
  HDNode: () => HDNode,
  Hex: () => Hex,
  HexInt: () => HexInt,
  HexUInt: () => HexUInt,
  INTEGER_REGEX: () => INTEGER_REGEX,
  Keccak256: () => Keccak256,
  MAINNET_NETWORK: () => MAINNET_NETWORK,
  Mnemonic: () => Mnemonic,
  NUMERIC_REGEX: () => NUMERIC_REGEX,
  PRIVATE_KEY_MAX_VALUE: () => PRIVATE_KEY_MAX_VALUE,
  Quantity: () => Quantity,
  RLPBase: () => RLPBase,
  RLPProfiles: () => RLPProfiles,
  RLP_CODER: () => RLP_CODER,
  Revision: () => Revision,
  SIGNATURE_LENGTH: () => SIGNATURE_LENGTH,
  SIGNED_TRANSACTION_RLP: () => SIGNED_TRANSACTION_RLP,
  SOLO_NETWORK: () => SOLO_NETWORK,
  Sha256: () => Sha256,
  TESTNET_NETWORK: () => TESTNET_NETWORK,
  TRANSACTIONS_GAS_CONSTANTS: () => TRANSACTIONS_GAS_CONSTANTS,
  TRANSACTION_FEATURES_KIND: () => TRANSACTION_FEATURES_KIND,
  TRANSACTION_SIGNATURE_KIND: () => TRANSACTION_SIGNATURE_KIND,
  ThorId: () => ThorId,
  Transaction: () => Transaction,
  TransactionHandler: () => TransactionHandler,
  TransactionUtils: () => TransactionUtils,
  Txt: () => Txt,
  UNSIGNED_TRANSACTION_RLP: () => UNSIGNED_TRANSACTION_RLP,
  VET_DERIVATION_PATH: () => VET_DERIVATION_PATH,
  VIP180_ABI: () => VIP180_ABI,
  VIP181_ABI: () => VIP181_ABI,
  VIP210_ABI: () => VIP210_ABI,
  VTHO_ADDRESS: () => VTHO_ADDRESS,
  X_PRIV_PREFIX: () => X_PRIV_PREFIX,
  X_PUB_PREFIX: () => X_PUB_PREFIX,
  ZERO_ADDRESS: () => ZERO_ADDRESS,
  ZERO_BYTES: () => ZERO_BYTES,
  abi: () => abi,
  addressUtils: () => addressUtils,
  assertCompactFixedHexBlobBuffer: () => assertCompactFixedHexBlobBuffer,
  assertFixedHexBlobKindBuffer: () => assertFixedHexBlobKindBuffer,
  assertFixedHexBlobKindData: () => assertFixedHexBlobKindData,
  assertValidHexBlobKindBuffer: () => assertValidHexBlobKindBuffer,
  assertValidHexBlobKindData: () => assertValidHexBlobKindData,
  assertValidNumericKindBuffer: () => assertValidNumericKindBuffer,
  blake2b256: () => blake2b256,
  certificate: () => certificate,
  clauseBuilder: () => clauseBuilder,
  coder: () => coder,
  dataUtils: () => dataUtils,
  decodeBufferToHexWithLeadingZeros: () => decodeBufferToHexWithLeadingZeros,
  decodeBufferToNumberOrHex: () => decodeBufferToNumberOrHex,
  encodeBigIntToBuffer: () => encodeBigIntToBuffer,
  encodeCompactFixedHexBlob: () => encodeCompactFixedHexBlob,
  fragment: () => fragment,
  isDerivationPathValid: () => isDerivationPathValid,
  keccak256: () => keccak256,
  keystore: () => keystore3,
  mnemonic: () => mnemonic,
  networkInfo: () => networkInfo,
  revisionUtils: () => revisionUtils,
  secp256k1: () => secp256k12,
  sha256: () => sha2563,
  unitsUtils: () => unitsUtils,
  validateNumericKindData: () => validateNumericKindData,
  vechain_sdk_core_ethers: () => import_ethers6.ethers
});
var import_ethers6 = require("ethers");

// src/abi/fragment.ts
var import_ethers = require("ethers");
var import_sdk_errors = require("@vechain/sdk-errors");

// src/abi/helpers/fragment.ts
var sanitizeValuesToEncode = (valuesToEncode, event) => {
  if (valuesToEncode.length === 0) return [];
  if (valuesToEncode.length > event.inputs.length) return valuesToEncode;
  const sanitizedValuesToEncode = [];
  const eventInputs = event.inputs;
  for (const input of eventInputs) {
    if (input.indexed === true && valuesToEncode.length > 0 && valuesToEncode[0] !== void 0) {
      sanitizedValuesToEncode.push(valuesToEncode.shift());
    } else {
      if (valuesToEncode.length > 0 && valuesToEncode[0] === void 0) {
        valuesToEncode.shift();
      }
      sanitizedValuesToEncode.push(null);
    }
  }
  return sanitizedValuesToEncode;
};

// src/abi/fragment.ts
var allowedSignatureFormats = ["sighash", "minimal", "full", "json"];
function getSignature(fragment2, formatType) {
  if (!allowedSignatureFormats.includes(formatType)) {
    throw new import_sdk_errors.InvalidAbiSignatureFormat(
      "getSignature()",
      "Initialization failed: Cannot create Function fragment. Function format is invalid.",
      {
        signatureFormat: formatType
      }
    );
  }
  return fragment2.format(formatType);
}
var Function = class {
  /**
   * The main fragment handled by ethers.js.
   *
   */
  fragment;
  /**
   * The main interface handled by ethers.js.
   */
  iface;
  /**
   * Creates a new Function instance from an ABI fragment.
   *
   * @param source - ABI fragment to use.
   * @throws {InvalidAbiFragment}
   */
  constructor(source) {
    try {
      this.fragment = import_ethers.ethers.FunctionFragment.from(source);
      this.iface = new import_ethers.ethers.Interface([this.fragment]);
    } catch (e) {
      throw new import_sdk_errors.InvalidAbiFragment(
        "abi.Function constructor",
        "Initialization failed: Cannot create Function fragment. Function format is invalid.",
        {
          type: "function",
          fragment: source
        },
        e
      );
    }
  }
  /**
   * Get the signature hash of the function.
   *
   * @returns The signature hash of the function.
   */
  signatureHash() {
    return this.fragment.selector;
  }
  /**
   * Get the signature of the function.
   *
   * @param formatType - The format type of the signature: 'sighash', 'minimal', 'full', or 'json'.
   * @returns The signature of the function.
   */
  signature(formatType) {
    return getSignature(this.fragment, formatType);
  }
  /**
   * Decode data using the function's ABI.
   *
   * @param data - Data to decode.
   * @returns Decoding results.
   * @throws {InvalidAbiDataToEncodeOrDecode}
   */
  decodeInput(data) {
    try {
      return this.iface.decodeFunctionData(this.fragment, data);
    } catch (e) {
      throw new import_sdk_errors.InvalidAbiDataToEncodeOrDecode(
        "abi.Function.decodeInput()",
        "Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",
        { data },
        e
      );
    }
  }
  /**
   * Decodes the output data from a transaction based on ABI (Application Binary Interface) specifications.
   * This method attempts to decode the given byte-like data into a readable format using the contract's interface.
   *
   * @param data - The `BytesLike` data to be decoded, typically representing the output of a contract function call.
   * @returns A `Result` object containing the decoded data.
   * @throws {InvalidAbiDataToEncodeOrDecode}
   *
   * @example
   * ```typescript
   *   const decoded = contractInstance.decodeOutput(rawTransactionOutput);
   *   console.log('Decoded Output:', decoded);
   * ```
   */
  decodeOutput(data) {
    try {
      return this.iface.decodeFunctionResult(this.fragment, data);
    } catch (e) {
      throw new import_sdk_errors.InvalidAbiDataToEncodeOrDecode(
        "abi.Function.decodeOutput()",
        "Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",
        { data },
        e
      );
    }
  }
  /**
   * Encode data using the function's ABI.
   *
   * @param dataToEncode - Data to encode.
   * @returns Encoded data.
   * @throws {InvalidAbiDataToEncodeOrDecode}
   */
  encodeInput(dataToEncode) {
    try {
      return this.iface.encodeFunctionData(this.fragment, dataToEncode);
    } catch (e) {
      throw new import_sdk_errors.InvalidAbiDataToEncodeOrDecode(
        "abi.Function.encodeInput()",
        "Encoding failed: Data format is invalid. Function data does not match the expected format for ABI type encoding.",
        { dataToEncode },
        e
      );
    }
  }
};
var Event = class {
  /**
   * The main fragment handled by ethers.js.
   */
  fragment;
  /**
   * The main interface handled by ethers.js.
   */
  iface;
  /**
   * Creates a new Event instance from an ABI fragment.
   *
   * @param source - ABI fragment to use.
   * @throws {InvalidAbiFragment}
   */
  constructor(source) {
    try {
      this.fragment = import_ethers.ethers.EventFragment.from(source);
      this.iface = new import_ethers.ethers.Interface([this.fragment]);
    } catch (e) {
      throw new import_sdk_errors.InvalidAbiFragment(
        "abi.Event constructor",
        "Initialization failed: Cannot create Event fragment. Event format is invalid.",
        {
          type: "event",
          fragment: source
        },
        e
      );
    }
  }
  /**
   * Get the signature hash of the event.
   *
   * @returns The signature hash of the event.
   */
  signatureHash() {
    return this.fragment.topicHash;
  }
  /**
   * Get the signature of the event.
   *
   * @param formatType - The format type of the signature: 'sighash', 'minimal', 'full', or 'json'.
   * @returns The signature of the event.
   */
  signature(formatType) {
    return getSignature(this.fragment, formatType);
  }
  /**
   * Decode event log data using the event's ABI.
   *
   * @param data - Data to decode.
   * @returns Decoding results.
   * @throws {InvalidAbiDataToEncodeOrDecode}
   */
  decodeEventLog(data) {
    try {
      return this.iface.decodeEventLog(
        this.fragment,
        data.data,
        data.topics
      );
    } catch (e) {
      throw new import_sdk_errors.InvalidAbiDataToEncodeOrDecode(
        "abi.Event.decodeEventLog()",
        "Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",
        { data },
        e
      );
    }
  }
  /**
   * Encode event log data using the event's ABI.
   *
   * @param dataToEncode - Data to encode.
   * @returns Encoded data along with topics.
   * @throws {InvalidAbiDataToEncodeOrDecode}
   */
  encodeEventLog(dataToEncode) {
    try {
      return this.iface.encodeEventLog(this.fragment, dataToEncode);
    } catch (e) {
      throw new import_sdk_errors.InvalidAbiDataToEncodeOrDecode(
        "abi.Event.encodeEventLog()",
        "Encoding failed: Data format is invalid. Event data does not match the expected format for ABI type encoding.",
        { dataToEncode },
        e
      );
    }
  }
  /**
   * Encode event log topics using the event's ABI.
   *
   * @param valuesToEncode - values to encode as topics. Non-indexed values are ignored.
   *                         Only the values of the indexed parameters are needed.
   * @returns Encoded topics array.
   * @throws {InvalidAbiDataToEncodeOrDecode}
   */
  encodeFilterTopics(valuesToEncode) {
    try {
      const sanitizedValuesToEncode = sanitizeValuesToEncode(
        valuesToEncode,
        this.fragment
      );
      return this.iface.encodeFilterTopics(this.fragment, sanitizedValuesToEncode).map((topic) => topic ?? void 0);
    } catch (e) {
      throw new import_sdk_errors.InvalidAbiDataToEncodeOrDecode(
        "abi.Event.encodeEventLog()",
        "Encoding failed: Data format is invalid. Event topics values must be correctly formatted for ABI-compliant encoding.",
        { valuesToEncode },
        e
      );
    }
  }
};
var fragment = {
  Function,
  Event
};

// src/abi/coder.ts
var import_ethers2 = require("ethers");
var import_sdk_errors2 = require("@vechain/sdk-errors");
var ethersCoder = new import_ethers2.ethers.AbiCoder();
function encode(type, value) {
  try {
    return ethersCoder.encode([type], [value]);
  } catch (e) {
    throw new import_sdk_errors2.InvalidAbiDataToEncodeOrDecode(
      "abi.encode()",
      "Encoding failed: Data must be a valid ABI type with corresponding valid data.",
      {
        type,
        value
      },
      e
    );
  }
}
function encodeParams(types, values) {
  try {
    return ethersCoder.encode(types, values);
  } catch (e) {
    throw new import_sdk_errors2.InvalidAbiDataToEncodeOrDecode(
      "abi.encodeParams()",
      "Encoding failed: Data must be a valid ABI type with corresponding valid data.",
      {
        types,
        values
      },
      e
    );
  }
}
function decode(types, data) {
  try {
    const decoded = ethersCoder.decode([types], data).toArray();
    return decoded[0];
  } catch (e) {
    throw new import_sdk_errors2.InvalidAbiDataToEncodeOrDecode(
      "abi.decode()",
      "Decoding failed: Data must be a valid ABI type with corresponding valid data.",
      {
        types,
        data
      },
      e
    );
  }
}
var abi = {
  ...fragment,
  encode,
  encodeParams,
  decode
};

// src/contract/coder.ts
var import_ethers3 = require("ethers");
var import_sdk_errors3 = require("@vechain/sdk-errors");
function createInterface(abi2) {
  return new import_ethers3.Interface(abi2);
}
function encodeFunctionInput(interfaceABI, functionName, functionData) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Function(
      contractInterface.getFunction(functionName)
    ).encodeInput(functionData);
  } catch (e) {
    throw new import_sdk_errors3.InvalidAbiDataToEncodeOrDecode(
      "coder.encodeFunctionInput()",
      `Encoding failed: Data format is invalid. Function data does not match the expected format for ABI type encoding.`,
      { interfaceABI, functionName, functionData },
      e
    );
  }
}
function decodeFunctionInput(interfaceABI, functionName, encodedFunctionInput) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Function(
      contractInterface.getFunction(functionName)
    ).decodeInput(encodedFunctionInput);
  } catch (e) {
    throw new import_sdk_errors3.InvalidAbiDataToEncodeOrDecode(
      "coder.decodeFunctionInput()",
      "Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",
      { interfaceABI, functionName, encodedFunctionInput },
      e
    );
  }
}
function decodeFunctionOutput(interfaceABI, functionName, encodedFunctionOutput) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Function(
      contractInterface.getFunction(functionName)
    ).decodeOutput(encodedFunctionOutput);
  } catch (e) {
    throw new import_sdk_errors3.InvalidAbiDataToEncodeOrDecode(
      "coder.decodeFunctionOutput()",
      `Decoding failed: Data must be a valid hex string encoding a compliant ABI type.`,
      { interfaceABI, functionName, encodedFunctionOutput },
      e
    );
  }
}
function encodeEventLog(interfaceABI, eventName, dataToEncode) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Event(
      contractInterface.getEvent(eventName)
    ).encodeEventLog(dataToEncode);
  } catch (e) {
    throw new import_sdk_errors3.InvalidAbiDataToEncodeOrDecode(
      "coder.encodeEventLog()",
      `Encoding failed: Data format is invalid. Event data does not match the expected format for ABI type encoding.`,
      { interfaceABI, eventName, dataToEncode },
      e
    );
  }
}
function decodeEventLog(interfaceABI, eventName, dataToDecode) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Event(
      contractInterface.getEvent(eventName)
    ).decodeEventLog(dataToDecode);
  } catch (e) {
    throw new import_sdk_errors3.InvalidAbiDataToEncodeOrDecode(
      "coder.decodeEventLog()",
      `Decoding failed: Data must be a valid hex string encoding a compliant ABI type.`,
      { interfaceABI, eventName, dataToDecode },
      e
    );
  }
}
function parseLog(interfaceABI, data, topics) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return contractInterface.parseLog({ topics, data });
  } catch (e) {
    throw new import_sdk_errors3.InvalidAbiDataToEncodeOrDecode(
      "coder.parseLog()",
      `Decoding failed: Data must be a valid hex string encoding a compliant ABI type.`,
      { interfaceABI, data, topics },
      e
    );
  }
}
var coder = {
  createInterface,
  encodeFunctionInput,
  decodeFunctionInput,
  decodeFunctionOutput,
  encodeEventLog,
  decodeEventLog,
  parseLog
};

// src/certificate/certificate.ts
var import_sdk_errors29 = require("@vechain/sdk-errors");
var import_fast_json_stable_stringify = __toESM(require("fast-json-stable-stringify"));

// src/hash/Blake2b256.ts
var import_blake2b = require("@noble/hashes/blake2b");
var import_sdk_errors26 = require("@vechain/sdk-errors");

// src/vcdm/account/Account.ts
var import_sdk_errors4 = require("@vechain/sdk-errors");
var Account = class {
  address;
  balance;
  // Replace the string array with a Transaction class #1162
  transactions;
  type;
  constructor(address, balance, type = "EOA", transactions) {
    this.address = address;
    this.balance = balance;
    this.type = type;
    this.transactions = transactions ?? [];
  }
  /**
   * Throws an exception because the account cannot be represented as a big integer.
   * @returns {bigint} The BigInt representation of the account.
   * @throws {InvalidOperation} The account cannot be represented as a bigint.
   * @override {@link VeChainDataModel#bi}
   * @remarks The conversion to BigInt is not supported for an account.
   */
  get bi() {
    throw new import_sdk_errors4.InvalidOperation(
      "Account.bi",
      "There is no big integer representation for an account.",
      { data: "" }
    );
  }
  /**
   * Throws an exception because the account cannot be represented as a byte array.
   * @returns {Uint8Array} The byte array representation of the account.
   * @throws {InvalidOperation} The account cannot be represented as a byte array.
   * @override {@link VeChainDataModel#bytes}
   * @remarks The conversion to byte array is not supported for an account.
   */
  get bytes() {
    throw new import_sdk_errors4.InvalidOperation(
      "Account.bytes",
      "There is no bytes representation for an account.",
      { data: "" }
    );
  }
  /**
   * Throws an exception because the account cannot be represented as a number.
   * @returns {bigint} The number representation of the account.
   * @throws {InvalidOperation} The account cannot be represented as a number.
   * @override {@link VeChainDataModel#n}
   * @remarks The conversion to number is not supported for an account.
   */
  get n() {
    throw new import_sdk_errors4.InvalidOperation(
      "Account.n",
      "There is no number representation for an account.",
      { data: "" }
    );
  }
  /**
   * Adds a transaction to the account.
   * @param {string} transaction The transaction to add.
   */
  addTransaction(transaction) {
    this.transactions.push(transaction);
  }
  /**
   * Compare this instance with `that` in a meaningful way.
   *
   * @param {Account} that object to compare.
   * @return a negative number if `this` < `that`, zero if `this` = `that`, a positive number if `this` > that`.
   * @override {@link VeChainDataModel#compareTo}
   */
  compareTo(that) {
    const typeCompareTo = this.type.localeCompare(that.type);
    if (typeCompareTo !== 0) {
      return typeCompareTo;
    }
    const addressCompareTo = this.address.compareTo(that.address);
    if (addressCompareTo !== 0) {
      return addressCompareTo;
    }
    return this.balance.compareTo(that.balance);
  }
  /**
   * Checks if the given value is equal to the current instance.
   *
   * @param {Account} that - The value to compare.
   * @returns {boolean} - True if the values are equal, false otherwise.
   * @override {@link VeChainDataModel#isEqual}
   */
  isEqual(that) {
    return this.compareTo(that) === 0;
  }
  /**
   * Returns a string representation of the account.
   *
   * @returns {string} A string representation of the account.
   */
  toString() {
    return `${this.type} Address: ${this.address.toString()} Balance: ${this.balance.bi.toString()}`;
  }
};

// src/vcdm/Address.ts
var import_sdk_errors20 = require("@vechain/sdk-errors");

// src/hdnode/hdnode.ts
var n_bip32 = __toESM(require("@scure/bip32"));
var n_bip39 = __toESM(require("@scure/bip39"));

// ../../node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes,
  hexToNumber: () => hexToNumber,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes,
  validateObject: () => validateObject
});
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var u8a = (a) => a instanceof Uint8Array;
var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes) {
  if (!u8a(bytes))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < bytes.length; i++) {
    hex += hexes[bytes[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const len = hex.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function bytesToNumberBE(bytes) {
  return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
  if (!u8a(bytes))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (u8a(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i = 0; i < b1.length; i++)
    if (b1[i] !== b2[i])
      return false;
  return true;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n;
}
var bitSet = (n, pos, value) => {
  return n | (value ? _1n : _0n) << BigInt(pos);
};
var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}

// src/hdnode/hdnode.ts
var import_sdk_errors16 = require("@vechain/sdk-errors");

// ../../node_modules/@scure/base/lib/esm/index.js
// @__NO_SIDE_EFFECTS__
function assertNumber(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`Wrong integer: ${n}`);
}
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
// @__NO_SIDE_EFFECTS__
function chain(...args) {
  const id = (a) => a;
  const wrap = (a, b) => (c) => a(b(c));
  const encode4 = args.map((x) => x.encode).reduceRight(wrap, id);
  const decode4 = args.map((x) => x.decode).reduce(wrap, id);
  return { encode: encode4, decode: decode4 };
}
// @__NO_SIDE_EFFECTS__
function alphabet(alphabet2) {
  return {
    encode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return digits.map((i) => {
        /* @__PURE__ */ assertNumber(i);
        if (i < 0 || i >= alphabet2.length)
          throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet2.length})`);
        return alphabet2[i];
      });
    },
    decode: (input) => {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("alphabet.decode input should be array of strings");
      return input.map((letter) => {
        if (typeof letter !== "string")
          throw new Error(`alphabet.decode: not string element=${letter}`);
        const index = alphabet2.indexOf(letter);
        if (index === -1)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
        return index;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function join(separator = "") {
  if (typeof separator !== "string")
    throw new Error("join separator should be string");
  return {
    encode: (from) => {
      if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
        throw new Error("join.encode input should be array of strings");
      for (let i of from)
        if (typeof i !== "string")
          throw new Error(`join.encode: non-string input=${i}`);
      return from.join(separator);
    },
    decode: (to) => {
      if (typeof to !== "string")
        throw new Error("join.decode input should be string");
      return to.split(separator);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function convertRadix(data, from, to) {
  if (from < 2)
    throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
  if (!Array.isArray(data))
    throw new Error("convertRadix: data should be array");
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data);
  digits.forEach((d) => {
    /* @__PURE__ */ assertNumber(d);
    if (d < 0 || d >= from)
      throw new Error(`Wrong integer: ${d}`);
  });
  while (true) {
    let carry = 0;
    let done = true;
    for (let i = pos; i < digits.length; i++) {
      const digit = digits[i];
      const digitBase = from * carry + digit;
      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
        throw new Error("convertRadix: carry overflow");
      }
      carry = digitBase % to;
      const rounded = Math.floor(digitBase / to);
      digits[i] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
    res.push(0);
  return res.reverse();
}
// @__NO_SIDE_EFFECTS__
function radix(num) {
  /* @__PURE__ */ assertNumber(num);
  return {
    encode: (bytes) => {
      if (!isBytes(bytes))
        throw new Error("radix.encode input should be Uint8Array");
      return /* @__PURE__ */ convertRadix(Array.from(bytes), 2 ** 8, num);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix.decode input should be array of numbers");
      return Uint8Array.from(/* @__PURE__ */ convertRadix(digits, num, 2 ** 8));
    }
  };
}
var genBase58 = (abc) => /* @__PURE__ */ chain(/* @__PURE__ */ radix(58), /* @__PURE__ */ alphabet(abc), /* @__PURE__ */ join(""));
var base58 = /* @__PURE__ */ genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

// src/vcdm/Hex.ts
var nh_utils = __toESM(require("@noble/hashes/utils"));
var import_sdk_errors5 = require("@vechain/sdk-errors");
var Hex = class _Hex {
  /**
   * Negative multiplier of the {@link digits} absolute value.
   *
   * @type {number}
   */
  static NEGATIVE = -1;
  /**
   * Positive multiplier of the {@link digits} absolute value.
   *
   * @type {number}
   */
  static POSITIVE = 1;
  /**
   * The radix used for representing numbers base 16 in a positional numeral notation system.
   *
   * @typedef {number} RADIX
   */
  static RADIX = 16;
  /**
   * Regular expression for matching hexadecimal strings.
   * An empty input is represented as a empty digits.
   *
   * @type {RegExp}
   */
  static REGEX_HEX = /^-?(0x)?[0-9a-f]*$/i;
  /**
   * Regular expression pattern to match a prefix indicating hexadecimal number.
   *
   * @type {RegExp}
   */
  static REGEX_HEX_PREFIX = /^-?0x/i;
  /**
       * Returns the hexadecimal digits expressing this absolute value, sign and `0x` prefix omitted.
  
       * @remarks An empty content results in an empty string returned.
       */
  digits;
  /**
   * Represents the sign multiplier of a given number:
   * * {@link NEGATIVE} `-1` if negative,
   * * {@link POSITIVE} `1` if positive.
   */
  sign;
  /**
   * Creates a new instance of this class to represent the value
   * built multiplying `sign` for the absolute value expressed by the hexadecimal `digits`.
   *
   * @param {number} sign - The sign of the value.
   * @param {string} digits - The digits of the absolute value in hexadecimal base.
   * @param {function} [normalize] - The function used to normalize the digits. Defaults to converting digits to lowercase.
   */
  constructor(sign4, digits, normalize = (digits2) => digits2.toLowerCase()) {
    this.digits = normalize(digits);
    this.sign = sign4;
  }
  /**
   * Returns the absolute value of this Hex object.
   *
   * @return {Hex} A new Hex object representing the absolute value of this Hex.
   */
  get abs() {
    return new _Hex(_Hex.POSITIVE, this.digits);
  }
  /**
   * Returns the value of `bi` as a `BigInt` type.
   *
   * @returns {bigint} The value of `bi` as a `BigInt`.
   */
  get bi() {
    return BigInt(this.sign) * hexToNumber(this.digits);
  }
  /**
   * Returns the Uint8Array representation of the aligned bytes.
   *
   * @return {Uint8Array} The Uint8Array representation of the aligned bytes.
   */
  get bytes() {
    return hexToBytes(this.alignToBytes().digits);
  }
  /**
   * Returns the value of n.
   *
   * @return {number} The value of n.
   *
   * @throws {InvalidOperation<Hex>} Throws an error if this instance doesn't represent
   * an [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).
   */
  get n() {
    if (this.isNumber()) {
      return new DataView(this.bytes.buffer).getFloat64(0);
    }
    throw new import_sdk_errors5.InvalidOperation("Hex.n", "not an IEEE 754 float 64 number", {
      hex: this.toString()
    });
  }
  /**
   * Aligns the hexadecimal string to bytes by adding a leading '0' if the string length is odd.
   *
   * @returns {Hex} - The aligned hexadecimal string.
   */
  alignToBytes() {
    return this.digits.length % 2 === 0 ? this : new _Hex(this.sign, "0" + this.digits);
  }
  /**
   * Compares the current Hex object with another Hex object.
   *
   * @param {Hex} that - The Hex object to compare with.
   *
   * @return {number} - Returns a negative number if the current Hex object is less than the given Hex object,
   *                    zero if they are equal, or a positive number if the current Hex object is greater than the given Hex object.
   */
  compareTo(that) {
    if (this.sign === that.sign) {
      const digits = Math.max(this.digits.length, that.digits.length);
      const thisBytes = this.fit(digits).bytes;
      const thatBytes = that.fit(digits).bytes;
      let i = 0;
      let compareByte = 0;
      while (compareByte === 0 && i < thisBytes.length) {
        compareByte = thisBytes[i] - thatBytes[i];
        i++;
      }
      return compareByte;
    }
    return this.sign - that.sign;
  }
  /**
   * Returns a new instance of the Hex class, its value fits to the specified number of digits.
   *
   * @param {number} digits - The number of digits to fit the Hex value into.
   *
   * @returns {Hex} - A new Hex instance that represents the fitted Hex value.
   *
   * @throws {InvalidDataType} - If the Hex value cannot be fit into the specified number of digits.
   */
  fit(digits) {
    if (digits < this.digits.length) {
      let cue = 0;
      while (this.digits.length - cue > digits && this.digits.at(cue) === "0") {
        cue++;
      }
      if (this.digits.length - cue === digits) {
        return new _Hex(this.sign, this.digits.slice(cue));
      }
      throw new import_sdk_errors5.InvalidDataType(
        "Hex.fit",
        `can't fit in ${digits} digits`,
        { digits, hex: this }
      );
    }
    if (digits > this.digits.length) {
      return new _Hex(
        this.sign,
        "0".repeat(digits - this.digits.length) + this.digits
      );
    }
    return this;
  }
  /**
   * Determines whether this Hex instance is equal to the given Hex instance.
   *
   * @param {Hex} that - The Hex instance to compare with.
   * @return {boolean} - True if the Hex instances are equal, otherwise false.
   */
  isEqual(that) {
    return this.compareTo(that) === 0;
  }
  /**
   * Checks if this instance expresses a valid {@link Number} value
   * according the
   * [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).
   *
   * @returns {boolean} Returns true if this instance expresses 32 hex digits (16 bytes, 128 bits) needed to represent
   * a {@link Number} value, else it returns false.
   */
  isNumber() {
    return this.digits.length === 32;
  }
  /**
   * Checks if the given string expression is a valid hexadecimal value.
   *
   * @param {string} exp - The string representation of a hexadecimal value.
   *
   * @return {boolean} - True if the expression is a valid hexadecimal value, case-insensitive,
   * optionally prefixed with `0x`; false otherwise.
   */
  static isValid(exp) {
    return _Hex.REGEX_HEX.test(exp);
  }
  /**
   * Determines whether the given string is a valid hexadecimal number prefixed with '0x'.
   *
   * @param {string} exp - The string to be evaluated.
   * @return {boolean} - True if the string is a valid hexadecimal number prefixed with '0x', otherwise false.
   */
  static isValid0x(exp) {
    return _Hex.REGEX_HEX_PREFIX.test(exp) && _Hex.isValid(exp);
  }
  /**
   * Create a Hex instance from a bigint, number, string, or Uint8Array.
   *
   * @param {bigint | number | string | Uint8Array} exp - The value to represent in a Hex instance:
   * * bigint is always representable in hexadecimal base notation;
   * * number, encoded as [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format);
   * * string is parsed as the hexadecimal expression of a bigint value, optionally tagged with `0x`;
   * * Uint8Array is interpreted as the sequence of bytes.
   *
   * @returns {Hex} - A Hex instance representing the input value.
   *
   * @throws {InvalidDataType} if the given `exp` can't be represented as a hexadecimal expression.
   */
  static of(exp) {
    try {
      if (exp instanceof Uint8Array) {
        return new _Hex(this.POSITIVE, bytesToHex(exp));
      } else if (typeof exp === "bigint") {
        if (exp < 0n) {
          return new _Hex(
            this.NEGATIVE,
            numberToHexUnpadded(-1n * exp)
          );
        }
        return new _Hex(
          this.POSITIVE,
          numberToHexUnpadded(exp)
        );
      } else if (typeof exp === "number") {
        const dataView = new DataView(new ArrayBuffer(16));
        dataView.setFloat64(0, exp);
        return new _Hex(
          exp < 0 ? this.NEGATIVE : this.POSITIVE,
          bytesToHex(new Uint8Array(dataView.buffer))
        );
      }
      if (this.isValid(exp)) {
        if (exp.startsWith("-")) {
          return new _Hex(
            this.NEGATIVE,
            this.REGEX_HEX_PREFIX.test(exp) ? exp.slice(3) : exp.slice(1)
          );
        }
        return new _Hex(
          this.POSITIVE,
          this.REGEX_HEX_PREFIX.test(exp) ? exp.slice(2) : exp
        );
      }
      throw new import_sdk_errors5.InvalidDataType("Hex.of", "not an hexadecimal string", {
        exp
      });
    } catch (e) {
      throw new import_sdk_errors5.InvalidDataType(
        "Hex.of",
        "not an hexadecimal expression",
        { exp: `${exp}` },
        // Needed to serialize bigint values.
        e
      );
    }
  }
  /**
   * Generates a random Hex value of the given number of bytes length.
   *
   * @param {number} bytes - The number of bytes to generate.
   * @throws {InvalidDataType} - If the bytes argument is not greater than 0.
   * @returns {Hex} - A randomly generated Hex value.
   *
   * @remarks Security auditable method, depends on
   * * [`nh_utils.randomBytes`](https://github.com/paulmillr/noble-hashes?tab=readme-ov-file#utils).
   */
  static random(bytes) {
    if (bytes > 0) {
      return _Hex.of(nh_utils.randomBytes(bytes));
    }
    throw new import_sdk_errors5.InvalidDataType("Hex.random", "bytes argument not > 0", {
      bytes
    });
  }
  /**
   * Error handler for Hex and its subclasses so we do not hide them.
   * To be used only for nested errors.
   *
   * @param error - The error to handle from the subclass.
   * @param methodName - The name of the method that threw the error.
   * @param {string} errorMessage - The error message to throw.
   * @param {ObjectErrorData} data - The data to include in the error.
   * @throws {InvalidDataType} - Throws an error with the given message and data.
   */
  static throwInvalidDataType(error, methodName, errorMessage, data) {
    if (error instanceof import_sdk_errors5.InvalidDataType) {
      throw error;
    }
    throw new import_sdk_errors5.InvalidDataType(methodName, errorMessage, data, error);
  }
  /**
   * Returns a string representation of the object.
   *
   * @return {string} The string representation of the object.
   */
  toString() {
    return (this.sign < 0 ? "-0x" : "0x") + this.digits;
  }
};

// src/utils/const/abi.ts
var ERC20_ABI = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "allowance", type: "uint256" },
      { internalType: "uint256", name: "needed", type: "uint256" }
    ],
    name: "ERC20InsufficientAllowance",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "uint256", name: "balance", type: "uint256" },
      { internalType: "uint256", name: "needed", type: "uint256" }
    ],
    name: "ERC20InsufficientBalance",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "approver", type: "address" }
    ],
    name: "ERC20InvalidApprover",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "receiver", type: "address" }
    ],
    name: "ERC20InvalidReceiver",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "sender", type: "address" }],
    name: "ERC20InvalidSender",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "spender", type: "address" }],
    name: "ERC20InvalidSpender",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var ERC721_ABI = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "ERC721IncorrectOwner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ERC721InsufficientApproval",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "approver",
        type: "address"
      }
    ],
    name: "ERC721InvalidApprover",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "ERC721InvalidOperator",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "ERC721InvalidOwner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "ERC721InvalidReceiver",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "ERC721InvalidSender",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ERC721NonexistentToken",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "approved",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getApproved",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "mintItem",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ownerOf",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "tokenURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var ERC1155_ABI = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      }
    ],
    name: "TransferBatch",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "TransferSingle",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "value",
        type: "string"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "URI",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      }
    ],
    name: "balanceOfBatch",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeBatchTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "uri",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var VIP180_ABI = ERC20_ABI;
var VIP181_ABI = ERC721_ABI;
var VIP210_ABI = ERC1155_ABI;

// src/utils/const/data.ts
var ZERO_BYTES = (size) => new Uint8Array(size);
var INTEGER_REGEX = /^\d+$/;
var NUMERIC_REGEX = /(^-?\d+(\.\d+)?)$|(^-?\.\d+)$/;

// src/utils/const/hdnode.ts
var VET_DERIVATION_PATH = "m/44'/818'/0'/0";
var X_PUB_PREFIX = Buffer.from("0488b21e000000000000000000", "hex");
var X_PRIV_PREFIX = Buffer.from("0488ade4000000000000000000", "hex");

// src/utils/const/secp256k1.ts
var PRIVATE_KEY_MAX_VALUE = Buffer.from(
  "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
  "hex"
);

// src/encoding/rlp/rlp.ts
var import_rlp = require("@ethereumjs/rlp");
var import_sdk_errors6 = require("@vechain/sdk-errors");
function encode2(data) {
  const encodedData = import_rlp.RLP.encode(data);
  return Buffer.from(encodedData);
}
function decode2(encodedData) {
  return import_rlp.RLP.decode(encodedData);
}
var Profiler = class {
  /**
   * Creates a new Profiler instance.
   * @param profile - RLP_CODER profile for encoding/decoding structures.
   */
  constructor(profile) {
    this.profile = profile;
  }
  /**
   * Encodes an object following the provided RLP_CODER profile.
   * @param data - Object to be encoded.
   * @returns - Encoded data as a Buffer.
   */
  encodeObject(data) {
    const packedData = _packData(data, this.profile, "");
    return Buffer.from(import_rlp.RLP.encode(packedData));
  }
  /**
   * Decodes an object following the provided RLP_CODER profile.
   * @param encodedData - Data to be decoded.
   * @returns - Decoded data as RLPValueType.
   */
  decodeObject(encodedData) {
    const packedData = import_rlp.RLP.decode(encodedData);
    return _unpackData(packedData, this.profile, "");
  }
};
var _packData = (obj, profile, context) => {
  context = context !== "" ? context + "." + profile.name : profile.name;
  const kind = profile.kind;
  if (kind instanceof RLPProfiles.ScalarKind) {
    return kind.data(obj, context).encode();
  }
  if (Array.isArray(kind)) {
    return kind.map(
      (k) => _packData(obj[k.name], k, context)
    );
  }
  if (!Array.isArray(obj)) {
    throw new import_sdk_errors6.InvalidRLP(
      "_packData()",
      `Validation error: Expected an array in ${context}.`,
      {
        context,
        data: {
          obj,
          profile
        }
      }
    );
  }
  if ("item" in kind && Array.isArray(obj)) {
    const item = kind.item;
    return obj.map(
      (part, i) => _packData(
        part,
        { name: "#" + i, kind: item },
        context
      )
    );
  }
};
var _unpackData = (packed, profile, context) => {
  context = context !== "" ? context + "." + profile.name : profile.name;
  const kind = profile.kind;
  if (kind instanceof RLPProfiles.ScalarKind) {
    if (!Buffer.isBuffer(packed) && !(packed instanceof Uint8Array)) {
      throw new import_sdk_errors6.InvalidRLP(
        "_unpackData()",
        `Unpacking error: Expected data type is Buffer.`,
        {
          context,
          data: {
            packed,
            profile
          }
        }
      );
    }
    if (packed instanceof Uint8Array) packed = Buffer.from(packed);
    return kind.buffer(packed, context).decode();
  }
  if (Array.isArray(kind) && Array.isArray(packed)) {
    const parts = packed;
    if (kind.length !== parts.length) {
      throw new import_sdk_errors6.InvalidRLP(
        "_unpackData()",
        `Unpacking error: Expected ${kind.length} items, but got ${parts.length}.`,
        {
          context,
          data: {
            packed,
            profile
          }
        }
      );
    }
    return kind.reduce(
      (obj, profile2, index) => {
        obj[profile2.name] = _unpackData(parts[index], profile2, context);
        return obj;
      },
      {}
    );
  }
  if (!Array.isArray(packed)) {
    throw new import_sdk_errors6.InvalidRLP(
      "_unpackData()",
      `Validation error: Expected an array in ${context}.`,
      {
        context,
        data: {
          packed,
          profile
        }
      }
    );
  }
  if ("item" in kind && Array.isArray(packed)) {
    const item = kind.item;
    return packed.map(
      (part, index) => _unpackData(part, { name: "#" + index, kind: item }, context)
    );
  }
};
var RLPBase = { encode: encode2, decode: decode2, Profiler };

// src/encoding/rlp/kind/scalarkind.abstract.ts
var ScalarKind = class {
};

// src/encoding/rlp/kind/bufferkind.ts
var import_sdk_errors7 = require("@vechain/sdk-errors");
var BufferKind = class extends ScalarKind {
  /**
   * Encodes the input data into buffer format.
   *
   * @param data - The data to encode, expected to be of buffer type.
   * @param context - Descriptive context for error messages
   * @returns DataOutput object with an encode function.
   * @throws {InvalidRLP}
   */
  data(data, context) {
    if (!Buffer.isBuffer(data))
      throw new import_sdk_errors7.InvalidRLP(
        "BufferKind.data()",
        `Validation error: Expected a Buffer type in ${context}.`,
        {
          context,
          data: {
            data
          }
        }
      );
    return {
      encode: () => data
      // Data is already a Buffer, so return as-is.
    };
  }
  /**
   * Decodes the input buffer.
   *
   * @param buffer - The buffer to decode, expected to be of buffer type.
   * @param context - Descriptive context for error messages, usually representing the caller's identity.
   * @returns BufferOutput object with a decode function.
   * @throws {InvalidRLP}
   */
  buffer(buffer, context) {
    if (!Buffer.isBuffer(buffer))
      throw new import_sdk_errors7.InvalidRLP(
        "BufferKind.buffer()",
        `Validation error: Expected a Buffer type in ${context}.`,
        {
          context,
          data: {
            buffer
          }
        }
      );
    return {
      decode: () => buffer
      // Buffer is already in the correct format, so return as-is.
    };
  }
};

// src/encoding/rlp/helpers/numerickind.ts
var import_sdk_errors8 = require("@vechain/sdk-errors");
var validateNumericKindData = (data, context) => {
  if (typeof data !== "number" && typeof data !== "string") {
    throw new import_sdk_errors8.InvalidRLP(
      "validateNumericKindData()",
      `Validation error: Input in ${context} must be a string or number.`,
      {
        context,
        data: {
          data
        }
      }
    );
  }
  if (typeof data === "number") {
    _validateNumericKindNumber(data, context);
  } else if (typeof data === "string") {
    _validateNumericKindString(data, context);
  }
  return BigInt(data);
};
var _validateNumericKindNumber = (num, context) => {
  if (!Number.isSafeInteger(num) || num < 0) {
    throw new import_sdk_errors8.InvalidRLP(
      "_validateNumericKindNumber()",
      `Validation error: Number in ${context} must be a safe and non-negative integer.`,
      {
        context,
        data: {
          num
        }
      }
    );
  }
};
var _validateNumericKindString = (str, context) => {
  const isHex = Hex.isValid0x(str);
  const isDecimal = dataUtils.isDecimalString(str);
  if (!isHex && !isDecimal) {
    throw new import_sdk_errors8.InvalidRLP(
      "_validateNumericKindString()",
      `Validation error: String in ${context} must represent a non-negative integer in hex or decimal format.`,
      {
        context,
        data: {
          str
        }
      }
    );
  }
  if (isHex && str.length <= 2) {
    throw new import_sdk_errors8.InvalidRLP(
      "_validateNumericKindString()",
      `Validation error: Hex string number in ${context} must be of valid length.`,
      {
        context,
        data: {
          str
        }
      }
    );
  }
};
var assertValidNumericKindBuffer = (buf, context, maxBytes) => {
  if (maxBytes !== void 0 && buf.length > maxBytes) {
    throw new import_sdk_errors8.InvalidRLP(
      "assertValidNumericKindBuffer()",
      `Validation error: Buffer in ${context} must be less than ${maxBytes} bytes.`,
      {
        context,
        data: {
          buf,
          maxBytes
        }
      }
    );
  }
  if (buf[0] === 0) {
    throw new import_sdk_errors8.InvalidRLP(
      "assertValidNumericKindBuffer()",
      `Validation error: Buffer in ${context} must represent a canonical integer (no leading zeros).`,
      {
        context,
        data: {
          buf,
          maxBytes
        }
      }
    );
  }
};
var encodeBigIntToBuffer = (bi, maxBytes, context) => {
  if (bi === 0n) return Buffer.alloc(0);
  const hex = Hex.of(bi).digits;
  if (maxBytes !== void 0 && hex.length > maxBytes * 2) {
    throw new import_sdk_errors8.InvalidRLP(
      "encodeBigIntToBuffer()",
      `Validation error: Encoded number in ${context} must fit within ${maxBytes} bytes.`,
      {
        context,
        data: {
          hex,
          maxBytes
        }
      }
    );
  }
  return Buffer.from(hex, "hex");
};
var decodeBufferToNumberOrHex = (buffer) => {
  if (buffer.length === 0) return 0;
  const bi = Hex.of(buffer).bi;
  const num = Number(bi);
  return Number.isSafeInteger(num) ? num : "0x" + bi.toString(16);
};

// src/encoding/rlp/helpers/hexblobkind.ts
var import_sdk_errors9 = require("@vechain/sdk-errors");
var assertValidHexBlobKindData = (data, context) => {
  if (typeof data !== "string") {
    throw new import_sdk_errors9.InvalidRLP(
      "assertValidHexBlobKindData()",
      `Validation error: Input must be a string.`,
      {
        context,
        data: {
          data
        }
      }
    );
  }
  if (!Hex.isValid(data)) {
    throw new import_sdk_errors9.InvalidRLP(
      "assertValidHexBlobKindData()",
      `Validation error: Input must be a valid hex string with a '0x' prefix.`,
      {
        context,
        data: {
          data
        }
      }
    );
  }
  if (data.length % 2 !== 0) {
    throw new import_sdk_errors9.InvalidRLP(
      "assertValidHexBlobKindData()",
      `Validation error: Hex string must have an even length.`,
      {
        context,
        data: {
          data
        }
      }
    );
  }
};
var assertValidHexBlobKindBuffer = (buffer, context) => {
  if (!Buffer.isBuffer(buffer)) {
    throw new import_sdk_errors9.InvalidRLP(
      "assertFixedHexBlobKindData()",
      `Validation error: Input must be a valid buffer.`,
      {
        context,
        data: {
          buffer
        }
      }
    );
  }
};

// src/encoding/rlp/helpers/fixedhexblobkind.ts
var import_sdk_errors10 = require("@vechain/sdk-errors");
var assertFixedHexBlobKindData = (data, context, bytes) => {
  if (data.length !== bytes * 2 + 2) {
    throw new import_sdk_errors10.InvalidRLP(
      "assertFixedHexBlobKindData()",
      `Validation error: Hex string in ${context} must be exactly ${bytes} bytes in length.`,
      {
        context,
        data: {
          data,
          bytes
        }
      }
    );
  }
};
var assertFixedHexBlobKindBuffer = (buffer, context, bytes) => {
  if (buffer.length !== bytes) {
    throw new import_sdk_errors10.InvalidRLP(
      "assertFixedHexBlobKindData()",
      `Validation error: Hex string in ${context} must be exactly ${bytes} bytes in length.`,
      {
        context,
        data: {
          buffer,
          bytes
        }
      }
    );
  }
};

// src/encoding/rlp/helpers/compactfixedhexblobkind.ts
var import_sdk_errors11 = require("@vechain/sdk-errors");
var assertCompactFixedHexBlobBuffer = (buffer, context, bytes) => {
  if (buffer.length > bytes) {
    throw new import_sdk_errors11.InvalidRLP(
      "assertCompactFixedHexBlobBuffer()",
      `Validation error: Buffer in ${context} must be at most ${bytes} bytes.`,
      {
        context,
        data: {
          buffer,
          bytes
        }
      }
    );
  }
  if (buffer.length !== 0 && buffer[0] === 0) {
    throw new import_sdk_errors11.InvalidRLP(
      "assertCompactFixedHexBlobBuffer()",
      `Validation error: Buffer in ${context} should not have leading zero bytes.`,
      {
        context,
        data: {
          buffer,
          bytes
        }
      }
    );
  }
};
var encodeCompactFixedHexBlob = (buffer) => {
  const zeroIndex = buffer.findIndex((byte) => byte !== 0);
  return zeroIndex !== -1 ? buffer.subarray(zeroIndex) : Buffer.alloc(0);
};
var decodeBufferToHexWithLeadingZeros = (buffer, bytes) => {
  return Hex.of(buffer).fit(bytes * 2).toString();
};

// src/encoding/rlp/kind/numerickind.ts
var NumericKind = class extends ScalarKind {
  /**
   * Constructs a new instance of NumericKind.
   *
   * @param maxBytes - Optional parameter that specifies the maximum number of bytes that numeric data can occupy when encoded.
   */
  constructor(maxBytes) {
    super();
    this.maxBytes = maxBytes;
  }
  /**
   * Encodes the input data into numeric format and ensures it doesn't exceed the maximum bytes, if specified.
   *
   * @param data - The data to encode, expected to be numeric.
   * @param context - Descriptive context for error messages
   * @returns DataOutput object with an encode function.
   * @throws Will throw an error if data validation fails or encoding issues occur.
   */
  data(data, context) {
    const dataBI = validateNumericKindData(data, context);
    return {
      encode: () => encodeBigIntToBuffer(dataBI, this.maxBytes, context)
      // Encodes BigInt to Buffer, respecting maxBytes.
    };
  }
  /**
   * Decodes the input buffer into a number or hexadecimal string, ensuring it meets numeric data constraints.
   *
   * @param buffer - The buffer to decode, containing numeric data.
   * @param context - Descriptive context for error messages.
   * @returns BufferOutput object with a decode function.
   * @throws Will throw an error if buffer validation fails.
   */
  buffer(buffer, context) {
    assertValidNumericKindBuffer(buffer, context, this.maxBytes);
    return {
      decode: () => decodeBufferToNumberOrHex(buffer)
      // Decodes buffer to either a number or a hexadecimal string.
    };
  }
};

// src/encoding/rlp/kind/hexblobkinds/hexblob.ts
var HexBlobKind = class extends ScalarKind {
  /**
   * Encodes the input data into a Buffer.
   *
   * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.
   * @param context - Context string for error handling.
   * @returns An object containing an encode function which returns the encoded Buffer.
   */
  data(data, context) {
    assertValidHexBlobKindData(data, context);
    return {
      encode: () => Buffer.from(data.slice(2), "hex")
    };
  }
  /**
   * Decodes the input buffer into a hex string.
   *
   * @param buffer - The buffer to decode.
   * @param context - Context string for error handling.
   * @returns An object containing a decode function which returns the decoded hex string.
   */
  buffer(buffer, context) {
    assertValidHexBlobKindBuffer(buffer, context);
    return {
      decode: () => Hex.of(buffer).toString()
    };
  }
};

// src/encoding/rlp/kind/hexblobkinds/fixedhexblob.ts
var FixedHexBlobKind = class extends HexBlobKind {
  /**
   * Creates a new instance of the {@link FixedHexBlobKind} class.
   * @param bytes - The number of bytes the blob must have.
   */
  constructor(bytes) {
    super();
    this.bytes = bytes;
  }
  /**
   * Encodes the input data into a Buffer with validation against fixed size.
   *
   * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.
   * @param context - Context string for error handling.
   * @returns An object containing an encode function which returns the encoded Buffer.
   */
  data(data, context) {
    const encoder = super.data(data, context);
    assertFixedHexBlobKindData(data, context, this.bytes);
    return encoder;
  }
  /**
   * Decodes the input buffer into a hex string with validation against fixed size.
   *
   * @param buffer - The buffer to decode.
   * @param context - Context string for error handling.
   * @returns An object containing a decode function which returns the decoded hex string.
   */
  buffer(buffer, context) {
    const decoder = super.buffer(buffer, context);
    assertFixedHexBlobKindBuffer(buffer, context, this.bytes);
    return decoder;
  }
};

// src/encoding/rlp/kind/hexblobkinds/optionalfixedhexblob.ts
var OptionalFixedHexBlobKind = class extends FixedHexBlobKind {
  /**
   * Encodes the input data (which can be null or undefined) into a Buffer.
   *
   * @param data - The data to encode, can be null or undefined.
   * @param context - Context string for error handling.
   * @returns An object containing an encode function which returns the encoded Buffer.
   */
  data(data, context) {
    return data == null ? {
      encode: () => Buffer.alloc(0)
    } : super.data(data, context);
  }
  /**
   * Decodes the input buffer into a hex string or null if the buffer is empty.
   *
   * @param buffer - The buffer to decode, can be empty.
   * @param context - Context string for error handling.
   * @returns An object containing a decode function which returns the decoded hex string or null.
   */
  buffer(buffer, context) {
    return buffer.length === 0 ? {
      decode: () => null
    } : super.buffer(buffer, context);
  }
};

// src/encoding/rlp/kind/hexblobkinds/compactfixedhexblob.ts
var CompactFixedHexBlobKind = class extends FixedHexBlobKind {
  /**
   * Encodes the input data into a Buffer, trimming leading zeros.
   *
   * @param data - The data to encode, expected to be a '0x' prefixed hex string.
   * @param context - Context string for error handling.
   * @returns An object containing an encode function which returns the encoded Buffer.
   */
  data(data, context) {
    const buffer = super.data(data, context).encode();
    return {
      encode: () => encodeCompactFixedHexBlob(buffer)
      // Encode the buffer, trimming leading zeros.
    };
  }
  /**
   * Decodes the input buffer into a number or hexadecimal string, ensuring it meets the fixed size by padding with zeros.
   *
   * @param buffer - The buffer to decode, containing numeric data.
   * @param context - Descriptive context for error messages, usually representing the caller's identity.
   * @returns BufferOutput object with a decode function.
   * @throws Will throw an error if buffer validation fails.
   */
  buffer(buffer, context) {
    assertCompactFixedHexBlobBuffer(buffer, context, this.bytes);
    return {
      decode: () => (
        // Decode the buffer, returning a hex string with leading zeros.
        Hex.of(buffer).fit(this.bytes * 2).toString()
      )
    };
  }
};

// src/encoding/rlp/kind/index.ts
var RLPProfiles = {
  ScalarKind,
  BufferKind,
  NumericKind,
  HexBlobKind,
  FixedHexBlobKind,
  OptionalFixedHexBlobKind,
  CompactFixedHexBlobKind
};

// src/encoding/rlp/index.ts
var RLP_CODER = {
  ...RLPBase,
  ...RLPProfiles
};

// src/utils/const/transaction.ts
var TRANSACTIONS_GAS_CONSTANTS = {
  /**
   * Default gas for a transaction
   * @internal
   */
  TX_GAS: 5e3,
  /**
   * Default gas for a clause
   * @internal
   */
  CLAUSE_GAS: 16e3,
  /**
   * Default gas for a contract creation clause
   * @internal
   */
  CLAUSE_GAS_CONTRACT_CREATION: 48e3,
  /**
   * Zero gas data
   * @internal
   */
  ZERO_GAS_DATA: 4,
  /**
   * Non-zero gas data
   * @internal
   */
  NON_ZERO_GAS_DATA: 68
};
var TRANSACTION_FIELDS = [
  /**
   * Chain tag. It represents the id of the chain the transaction is sent to.
   */
  { name: "chainTag", kind: new RLP_CODER.NumericKind(1) },
  /**
   * Block reference. It represents the last block of the chain the transaction is sent to.
   */
  {
    name: "blockRef",
    kind: new RLP_CODER.CompactFixedHexBlobKind(8)
  },
  /**
   * Expiration. It represents the expiration date of the transaction.
   */
  { name: "expiration", kind: new RLP_CODER.NumericKind(4) },
  /**
   * Clauses of the transaction. They represent the actions to be executed by the transaction.
   */
  {
    name: "clauses",
    kind: {
      item: [
        {
          name: "to",
          kind: new RLP_CODER.OptionalFixedHexBlobKind(20)
        },
        { name: "value", kind: new RLP_CODER.NumericKind(32) },
        { name: "data", kind: new RLP_CODER.HexBlobKind() }
      ]
    }
  },
  /**
   * Gas price coef. It represents the gas price coefficient of the transaction.
   */
  { name: "gasPriceCoef", kind: new RLP_CODER.NumericKind(1) },
  /**
   * Gas. It represents the gas limit of the transaction.
   */
  { name: "gas", kind: new RLP_CODER.NumericKind(8) },
  /**
   * Depends on. It represents the hash of the transaction the current transaction depends on.
   */
  { name: "dependsOn", kind: new RLP_CODER.OptionalFixedHexBlobKind(32) },
  /**
   * Nonce. It represents the nonce of the transaction.
   */
  { name: "nonce", kind: new RLP_CODER.NumericKind(8) },
  /**
   * Reserved. It represents the reserved field of the transaction.
   */
  { name: "reserved", kind: { item: new RLP_CODER.BufferKind() } }
];
var TRANSACTION_FEATURES_KIND = {
  name: "reserved.features",
  kind: new RLP_CODER.NumericKind(4)
};
var TRANSACTION_SIGNATURE_KIND = {
  name: "signature",
  kind: new RLP_CODER.BufferKind()
};
var UNSIGNED_TRANSACTION_RLP = new RLP_CODER.Profiler({
  name: "tx",
  kind: TRANSACTION_FIELDS
});
var SIGNED_TRANSACTION_RLP = new RLP_CODER.Profiler({
  name: "tx",
  // Add signature to the transaction fields
  kind: TRANSACTION_FIELDS.concat([TRANSACTION_SIGNATURE_KIND])
});
var SIGNATURE_LENGTH = 65;
var BLOCK_REF_LENGTH = 8;

// src/utils/data/data.ts
var import_sdk_errors12 = require("@vechain/sdk-errors");
var decodeBytes32String = (hex) => {
  if (!Hex.isValid(hex) || Hex.of(hex).digits.length !== 64)
    throw new import_sdk_errors12.InvalidDataType(
      "dataUtils.decodeBytes32String()",
      `Failed to decode value ${hex} to string. Value is not a valid hex string or it is not 64 characters long`,
      { value: hex }
    );
  const valueInBytes = Hex.of(hex).bytes;
  const firstZeroIndex = valueInBytes.findIndex((byte) => byte === 0);
  if (firstZeroIndex === 0) {
    const firstNotZeroIndex = valueInBytes.findIndex((byte) => byte !== 0);
    return Txt.of(valueInBytes.subarray(firstNotZeroIndex)).toString();
  } else if (firstZeroIndex !== -1) {
    return Txt.of(valueInBytes.subarray(0, firstZeroIndex)).toString();
  } else {
    return Txt.of(valueInBytes).toString();
  }
};
var encodeBytes32String = (value, zeroPadding = "right") => {
  try {
    const valueInBytes = Txt.of(value).bytes;
    if (valueInBytes.length > 32) {
      throw new import_sdk_errors12.InvalidDataType(
        "dataUtils.encodeBytes32String()",
        `Failed to encode value ${value} to bytes32 string. Value exceeds 32 bytes.`,
        { value }
      );
    }
    const pad = ZERO_BYTES(32 - valueInBytes.length);
    return zeroPadding === "left" ? Hex.of(concatBytes(pad, valueInBytes)).toString() : Hex.of(concatBytes(valueInBytes, pad)).toString();
  } catch (e) {
    throw new import_sdk_errors12.InvalidDataType(
      "dataUtils.encodeBytes32String()",
      `Failed to encode value ${value} to bytes32 string.`,
      { value },
      e
    );
  }
};
var isDecimalString = (data) => {
  return INTEGER_REGEX.test(data);
};
var isNumeric = (value) => {
  return NUMERIC_REGEX.test(value);
};
var dataUtils = {
  decodeBytes32String,
  encodeBytes32String,
  isDecimalString,
  isNumeric
};

// src/utils/hdnode/hdnode.ts
function _checkDerivationPathSingleComponentValid(component, index) {
  return (
    // m
    (index === 0 ? component === "m" : false) || // "number"
    INTEGER_REGEX.test(component) || // "number'"
    INTEGER_REGEX.test(component.slice(0, -1)) && component.endsWith("'")
  );
}
function isDerivationPathValid(derivationPath) {
  const pathComponents = derivationPath.split("/");
  for (let i = 0; i < pathComponents.length; i++) {
    if (!_checkDerivationPathSingleComponentValid(pathComponents[i], i))
      return false;
  }
  return true;
}

// src/utils/transaction/transaction.ts
var import_sdk_errors13 = require("@vechain/sdk-errors");
function intrinsicGas(clauses) {
  if (clauses.length === 0) {
    return TRANSACTIONS_GAS_CONSTANTS.TX_GAS + TRANSACTIONS_GAS_CONSTANTS.CLAUSE_GAS;
  }
  return clauses.reduce((sum, clause) => {
    if (clause.to !== null) {
      if (!Address.isValid(clause.to) && !clause.to.includes("."))
        throw new import_sdk_errors13.InvalidDataType(
          "TransactionUtils.intrinsicGas()",
          `Invalid data type in clause. Each 'to' field must be a valid address.`,
          { clause }
        );
      sum += TRANSACTIONS_GAS_CONSTANTS.CLAUSE_GAS;
    } else {
      sum += TRANSACTIONS_GAS_CONSTANTS.CLAUSE_GAS_CONTRACT_CREATION;
    }
    sum += _calculateDataUsedGas(clause.data);
    return sum;
  }, TRANSACTIONS_GAS_CONSTANTS.TX_GAS);
}
function _calculateDataUsedGas(data) {
  if (data !== "" && !Hex.isValid(data))
    throw new import_sdk_errors13.InvalidDataType(
      "_calculateDataUsedGas()",
      `Invalid data type for gas calculation. Data should be a hexadecimal string.`,
      { data }
    );
  let sum = 0;
  for (let i = 2; i < data.length; i += 2) {
    if (data.substring(i, i + 2) === "00") {
      sum += TRANSACTIONS_GAS_CONSTANTS.ZERO_GAS_DATA;
    } else {
      sum += TRANSACTIONS_GAS_CONSTANTS.NON_ZERO_GAS_DATA;
    }
  }
  return sum;
}
var TransactionUtils = { intrinsicGas };

// src/utils/units/units.ts
var import_bignumber = require("bignumber.js");
var import_sdk_errors14 = require("@vechain/sdk-errors");
var BIG_NUMBER_PRECISION = 80;
var VET_DECIMAL_EXPONENT = 18;
var WEI_UNIT_NAMES = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function bigNumberOf(value) {
  let bn;
  switch (typeof value) {
    case "bigint":
      bn = (0, import_bignumber.BigNumber)(value.toString());
      break;
    case "number":
      bn = (0, import_bignumber.BigNumber)(value);
      break;
    case "string": {
      if (Hex.isValid0x(value)) {
        bn = (0, import_bignumber.BigNumber)(Hex.of(value).bi.toString());
      } else {
        bn = (0, import_bignumber.BigNumber)(value);
      }
    }
  }
  if (bn.isNaN())
    throw new import_sdk_errors14.InvalidDataType("unitUtils.bigNumberOf()", "Not a number.", {
      value: value.toString()
    });
  return bn;
}
function digitsOfFractionalPart(value) {
  let d = 0;
  const i = value.abs().integerValue(import_bignumber.BigNumber.ROUND_FLOOR);
  let f = value.abs().minus(i);
  while (!f.isInteger()) {
    ++d;
    f = f.times(10);
  }
  return d;
}
function digitsOfIntegerPart(value) {
  let d = 0;
  let i = value.abs().integerValue(import_bignumber.BigNumber.ROUND_FLOOR);
  while (i.gte(1)) {
    d++;
    i = i.div(10);
  }
  return d;
}
function digitsOfUnit(digitsOrUnit) {
  let digits;
  switch (typeof digitsOrUnit) {
    case "bigint":
      digits = Number(digitsOrUnit);
      break;
    case "number":
      digits = Math.floor(digitsOrUnit);
      break;
    case "string": {
      const index = WEI_UNIT_NAMES.indexOf(digitsOrUnit);
      if (index < 0) {
        throw new import_sdk_errors14.InvalidDataType(
          "unitUtils.digitOfUnit()",
          "Invalid unit name. Valid unit names are 'wei','kwei', 'mwei', 'gwei', 'szabo', 'finney', 'ether'",
          {
            digitsOrUnit
          }
        );
      }
      digits = index * 3;
    }
  }
  if (digits > BIG_NUMBER_PRECISION)
    throw new import_sdk_errors14.InvalidDataType(
      "unitsUtils.digitOfUnit()",
      "Precision overflow (digits or unit name).",
      { digitsOrUnit: digitsOrUnit.toString() }
    );
  if (digits < 0)
    throw new import_sdk_errors14.InvalidDataType(
      "unitsUtils.digitOfUnit()",
      "Negative precision (digits or unit name).",
      { digitsOrUnit: digitsOrUnit.toString() }
    );
  return digits;
}
function formatUnits(value, decimalsOrUnit = VET_DECIMAL_EXPONENT) {
  const bnConfig = import_bignumber.BigNumber.config();
  import_bignumber.BigNumber.set({
    DECIMAL_PLACES: BIG_NUMBER_PRECISION,
    ROUNDING_MODE: import_bignumber.BigNumber.ROUND_HALF_UP
  });
  try {
    const bn = bigNumberOf(value);
    const powerOfTen = digitsOfUnit(decimalsOrUnit);
    const divisor = (0, import_bignumber.BigNumber)(10).pow(powerOfTen);
    const result = bn.div(divisor);
    let fixedDecimals = digitsOfFractionalPart(result);
    if (fixedDecimals === 0 && decimalsOrUnit !== WEI_UNIT_NAMES[0]) {
      fixedDecimals = 1;
    }
    return result.toFixed(fixedDecimals);
  } catch (e) {
    throw new import_sdk_errors14.InvalidDataType(
      "unitsUtils.formatUnits()",
      `Unable to format units: ${e.message}`,
      { value, digitsOrUnit: decimalsOrUnit },
      e
    );
  } finally {
    import_bignumber.BigNumber.set(bnConfig);
  }
}
var formatVET = (value) => {
  return formatUnits(value, VET_DECIMAL_EXPONENT);
};
function parseUnits(value, digitsOrUnit = VET_DECIMAL_EXPONENT) {
  const bnConfig = import_bignumber.BigNumber.config();
  import_bignumber.BigNumber.set({
    DECIMAL_PLACES: BIG_NUMBER_PRECISION,
    ROUNDING_MODE: import_bignumber.BigNumber.ROUND_HALF_UP
  });
  try {
    const bn = bigNumberOf(value);
    const powerOfTen = digitsOfUnit(digitsOrUnit);
    const multiplier = (0, import_bignumber.BigNumber)(10).pow(powerOfTen);
    const result = bn.times(multiplier);
    const fractionDigits = digitsOfFractionalPart(result);
    const integerDigits = digitsOfIntegerPart(result);
    return BigInt(result.toPrecision(fractionDigits + integerDigits));
  } catch (e) {
    throw new import_sdk_errors14.InvalidDataType(
      "unitsUtils.parseUnits()",
      `Unable to format units: ${e.message}`,
      { value, decimalsOrUnit: digitsOrUnit },
      e
    );
  } finally {
    import_bignumber.BigNumber.set(bnConfig);
  }
}
var parseVET = (value) => {
  return parseUnits(value, VET_DECIMAL_EXPONENT);
};
var unitsUtils = {
  formatUnits,
  formatVET,
  parseUnits,
  parseVET
};

// src/secp256k1/secp256k1.ts
var import_utils8 = require("@noble/hashes/utils");

// ../../node_modules/@noble/curves/esm/secp256k1.js
var import_sha256 = require("@noble/hashes/sha256");
var import_utils6 = require("@noble/hashes/utils");

// ../../node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n2 || power < _0n2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n2)
    return _0n2;
  let res = _1n2;
  while (power > _0n2) {
    if (power & _1n2)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n2;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number, modulo) {
  if (number === _0n2 || modulo <= _0n2) {
    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
  }
  let a = mod(number, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n2) / _2n2;
  let Q, S, Z;
  for (Q = P - _1n2, S = 0; Q % _2n2 === _0n2; Q /= _2n2, S++)
    ;
  for (Z = _2n2; Z < P && pow(Z, legendreC, P) !== P - _1n2; Z++)
    ;
  if (S === 1) {
    const p1div4 = (P + _1n2) / _4n;
    return function tonelliFast(Fp2, n) {
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n2) / _2n2;
  return function tonelliSlow(Fp2, n) {
    if (Fp2.pow(n, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
    let x = Fp2.pow(n, Q1div2);
    let b = Fp2.pow(n, Q);
    while (!Fp2.eql(b, Fp2.ONE)) {
      if (Fp2.eql(b, Fp2.ZERO))
        return Fp2.ZERO;
      let m = 1;
      for (let t2 = Fp2.sqr(b); m < r; m++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge = Fp2.pow(g, _1n2 << BigInt(r - m - 1));
      g = Fp2.sqr(ge);
      x = Fp2.mul(x, ge);
      b = Fp2.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n2) / _4n;
    return function sqrt3mod4(Fp2, n) {
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp2, n) {
      const n2 = Fp2.mul(n, _2n2);
      const v = Fp2.pow(n2, c1);
      const nv = Fp2.mul(n, v);
      const i = Fp2.mul(Fp2.mul(nv, _2n2), v);
      const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f, num, power) {
  if (power < _0n2)
    throw new Error("Expected power > 0");
  if (power === _0n2)
    return f.ONE;
  if (power === _1n2)
    return num;
  let p = f.ONE;
  let d = num;
  while (power > _0n2) {
    if (power & _1n2)
      p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = f.mul(acc, tmp[i]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE = false, redef = {}) {
  if (ORDER <= _0n2)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes) => {
      if (bytes.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
    }
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n2) + _1n2;
  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// ../../node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d = elm;
      while (n > _0n3) {
        if (n & _1n3)
          p = p.add(d);
        d = d.double();
        n >>= _1n3;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window = 0; window < windows; window++) {
        base = p;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window = 0; window < windows; window++) {
        const offset = window * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n3;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    },
    wNAFCached(P, precomputesMap, n, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// ../../node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    if (!(data instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice(h(sig.s));
    const r = slice(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
  }
};
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n3 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes) => {
    const tail = bytes.subarray(1);
    const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp2.sqr(x);
    const x3 = Fp2.mul(x2, x);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n4 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  class Point2 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x) && is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point2(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE;
      const b3 = Fp2.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n2);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n) {
      const I = Point2.ZERO;
      if (n === _0n4)
        return I;
      assertGE(n);
      if (n === _1n4)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n4 || k2 > _0n4) {
        if (k1 & _1n4)
          k1p = k1p.add(d);
        if (k2 & _1n4)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n4;
        k2 >>= _1n4;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(n);
        point = p;
        fake = f;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point2.BASE;
      const mul = (P, a2) => a2 === _0n4 || a2 === _1n4 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x, py: y, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y, iz);
      const zz = Fp2.mul(z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n4 < num && num < Fp2.ORDER;
  }
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp2.toBytes(a.x);
      const cat = concatBytes;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes) {
      const len = bytes.length;
      const head = bytes[0];
      const tail = bytes.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp2.sqrt(y2);
        const isYOdd = (y & _1n4) === _1n4;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number) {
    const HALF = CURVE_ORDER >> _1n4;
    return number > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
  class Signature {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h * ir);
      const u2 = modN(s * ir);
      const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point2.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes) {
    const num = bytesToNumberBE(bytes);
    const delta = bytes.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
    return modN(bits2int(bytes));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n4 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes5 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes5(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = modN(q.x);
      if (r === _0n4)
        return;
      const s = modN(ik * modN(m + r * d));
      if (s === _0n4)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign4(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify2(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig = new Signature(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point2.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN(h * is);
    const u2 = modN(r * is);
    const R = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign: sign4,
    verify: verify2,
    ProjectivePoint: Point2,
    Signature,
    utils
  };
}

// ../../node_modules/@noble/curves/esm/_shortw_utils.js
var import_hmac = require("@noble/hashes/hmac");
var import_utils5 = require("@noble/hashes/utils");
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => (0, import_hmac.hmac)(hash2, key, (0, import_utils5.concatBytes)(...msgs)),
    randomBytes: import_utils5.randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create(defHash), create });
}

// ../../node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var divNearest = (a, b) => (a + b / _2n4) / b;
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n4, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n4, P);
  if (!Fp.eql(Fp.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, import_sha256.sha256);
var _0n5 = BigInt(0);
var Point = secp256k1.ProjectivePoint;

// src/secp256k1/secp256k1.ts
var import_sdk_errors15 = require("@vechain/sdk-errors");
function compressPublicKey(publicKey) {
  const prefix = publicKey.at(0);
  if (prefix === 4) {
    const x = publicKey.slice(1, 33);
    const y = publicKey.slice(33, 65);
    const isYOdd = y[y.length - 1] & 1;
    return concatBytes(Uint8Array.of(2 + isYOdd), x);
  } else {
    return publicKey;
  }
}
function derivePublicKey(privateKey, isCompressed = true) {
  if (!isValidPrivateKey(privateKey)) {
    throw new import_sdk_errors15.InvalidSecp256k1PrivateKey(
      "secp256k1.derivePublicKey()",
      "Invalid private key given as input. Ensure it is a valid 32-byte secp256k1 private key.",
      void 0
    );
  }
  return secp256k1.getPublicKey(privateKey, isCompressed);
}
async function generatePrivateKey() {
  try {
    return secp256k1.utils.randomPrivateKey();
  } catch (error) {
    const cryptoKey = await global.crypto.subtle.generateKey(
      {
        name: "AES-GCM",
        length: 256
      },
      true,
      ["encrypt", "decrypt"]
    );
    const rawKey = await global.crypto.subtle.exportKey("raw", cryptoKey);
    return new Uint8Array(rawKey);
  }
}
function inflatePublicKey(publicKey) {
  const prefix = publicKey.at(0);
  if (prefix !== 4) {
    const x = publicKey.slice(0, 33);
    const p = secp256k1.ProjectivePoint.fromAffine(
      secp256k1.ProjectivePoint.fromHex(Hex.of(x).digits).toAffine()
    );
    return p.toRawBytes(false);
  } else {
    return publicKey;
  }
}
function isValidMessageHash(hash2) {
  return hash2.length === 32;
}
function isValidPrivateKey(privateKey) {
  return secp256k1.utils.isValidPrivateKey(privateKey);
}
function randomBytes4(bytesLength) {
  try {
    return (0, import_utils8.randomBytes)(bytesLength);
  } catch (error) {
    return global.crypto.getRandomValues(new Uint8Array(bytesLength ?? 32));
  }
}
function recover(messageHash, sig) {
  if (!isValidMessageHash(messageHash)) {
    throw new import_sdk_errors15.InvalidSecp256k1MessageHash(
      "secp256k1.sign()",
      "Invalid message hash given as input. Ensure it is a valid 32-byte message hash.",
      { messageHash }
    );
  }
  if (sig.length !== SIGNATURE_LENGTH)
    throw new import_sdk_errors15.InvalidSecp256k1Signature(
      "secp256k1.recover()",
      "Invalid signature given as input. Length must be exactly 65 bytes.",
      { signature: sig }
    );
  const recovery = sig[64];
  if (recovery !== 0 && recovery !== 1)
    throw new import_sdk_errors15.InvalidSecp256k1Signature(
      "secp256k1.recover()",
      "Invalid signature recovery value. Signature bytes at position 64 must be 0 or 1.",
      { signature: sig, recovery }
    );
  return secp256k1.Signature.fromCompact(sig.slice(0, 64)).addRecoveryBit(recovery).recoverPublicKey(messageHash).toRawBytes(false);
}
function sign(messageHash, privateKey) {
  if (!isValidMessageHash(messageHash)) {
    throw new import_sdk_errors15.InvalidSecp256k1MessageHash(
      "secp256k1.sign()",
      "Invalid message hash given as input. Ensure it is a valid 32-byte message hash.",
      { messageHash }
    );
  }
  if (!isValidPrivateKey(privateKey)) {
    throw new import_sdk_errors15.InvalidSecp256k1PrivateKey(
      "secp256k1.sign()",
      "Invalid private key given as input. Ensure it is a valid 32-byte secp256k1 private key.",
      void 0
    );
  }
  const sig = secp256k1.sign(messageHash, privateKey);
  return concatBytes(
    numberToBytesBE(sig.r, 32),
    numberToBytesBE(sig.s, 32),
    numberToVarBytesBE(sig.recovery)
  );
}
var secp256k12 = {
  compressPublicKey,
  derivePublicKey,
  generatePrivateKey,
  inflatePublicKey,
  isValidMessageHash,
  isValidPrivateKey,
  recover,
  randomBytes: randomBytes4,
  sign
};

// src/hdnode/hdnode.ts
function fromMnemonic(words, path = VET_DERIVATION_PATH) {
  let master;
  try {
    master = n_bip32.HDKey.fromMasterSeed(
      n_bip39.mnemonicToSeedSync(words.join(" ").toLowerCase())
    );
  } catch (error) {
    throw new import_sdk_errors16.InvalidHDNodeMnemonic(
      "HDNode.fromMnemonic()",
      "Invalid mnemonic words given as input.",
      void 0,
      error
    );
  }
  try {
    return master.derive(path);
  } catch (error) {
    throw new import_sdk_errors16.InvalidHDNode(
      "HDNode.fromMnemonic()",
      "Invalid derivation path given as input.",
      { derivationPath: path },
      error
    );
  }
}
function fromPrivateKey(privateKey, chainCode) {
  if (privateKey.length === 32) {
    const header = concatBytes(
      X_PRIV_PREFIX,
      chainCode,
      Uint8Array.of(0),
      privateKey
    );
    privateKey.fill(0);
    const checksum = Sha256.of(Sha256.of(header).bytes).bytes.subarray(
      0,
      4
    );
    const expandedPrivateKey = concatBytes(header, checksum);
    try {
      return n_bip32.HDKey.fromExtendedKey(
        base58.encode(expandedPrivateKey)
      );
    } catch (error) {
      throw new import_sdk_errors16.InvalidSecp256k1PrivateKey(
        "HDNode.fromPrivateKey()",
        "Invalid private key path given as input.",
        void 0
      );
    }
  }
  privateKey.fill(0);
  throw new import_sdk_errors16.InvalidSecp256k1PrivateKey(
    "HDNode.fromPrivateKey()",
    "Invalid private key path given as input. Length must be exactly 32 bytes.",
    void 0
  );
}
function fromPublicKey(publicKey, chainCode) {
  if (chainCode.length === 32) {
    const header = concatBytes(
      X_PUB_PREFIX,
      chainCode,
      secp256k12.compressPublicKey(publicKey)
    );
    const checksum = Sha256.of(Sha256.of(header).bytes).bytes.subarray(
      0,
      4
    );
    const expandedPublicKey = concatBytes(header, checksum);
    try {
      return n_bip32.HDKey.fromExtendedKey(
        base58.encode(expandedPublicKey)
      );
    } catch (error) {
      throw new import_sdk_errors16.InvalidHDNode(
        "HDNode.fromPublicKey()",
        "Invalid public key path given as input.",
        { publicKey },
        error
      );
    }
  }
  throw new import_sdk_errors16.InvalidHDNode(
    "HDNode.fromPublicKey()",
    "Invalid chain code given as input. Length must be exactly 32 bytes.",
    { chainCode }
  );
}
var HDNode = {
  fromMnemonic,
  fromPrivateKey,
  fromPublicKey
};

// src/vcdm/HexInt.ts
var import_sdk_errors17 = require("@vechain/sdk-errors");
var HexInt = class _HexInt extends Hex {
  /**
   * Retrieves the value of n cast from this instance interpreted as the hexadecimal expression of a bigint value.
   *
   * @return {number} The value of n.
   *
   * @throws {InvalidDataType} If n is not within the safe number range, if the number representation of this
   * instance results approximated.
   *
   * @remarks This class makes equal instances created from the same value as number or as bigint.
   */
  get n() {
    const bi = this.bi;
    if (Number.MIN_SAFE_INTEGER <= bi && bi <= Number.MAX_SAFE_INTEGER) {
      return Number(bi);
    }
    throw new import_sdk_errors17.InvalidDataType("HexInt.n", "not in the safe number range", {
      bi: `${bi}`,
      hex: this.toString()
    });
  }
  /**
   * Create a HexInt instance from a bigint, number, string, Uint8Array, or {@link Hex}.
   *
   * @param {bigint | number | string | Uint8Array | Hex} exp - The expression to be interpreted as an integer:
   * * bigint is always representable in hexadecimal base notation;
   * * number is converted to a bigint then represented in hexadecimal base notation;
   *   it throws {@link InvalidDataType} if not an integer value;
   * * string is parsed as the hexadecimal expression of a bigint value, optionally tagged with `0x`;
   * * Uint8Array is interpreted as the sequence of bytes expressing a bigint value;
   * * {@link Hex} is interpreted as expressing a bigint value.
   *
   * @returns {HexInt} - The new HexInt object representing the given `exp`.
   *
   * @throws {InvalidDataType} - If the given `exp` is not a valid hexadecimal integer expression,
   * if `exp` is a not integer number.
   *
   * @remarks This class makes equal instances created from the same value as number or as bigint.
   */
  static of(exp) {
    try {
      if (exp instanceof Hex) {
        return new _HexInt(exp.sign, exp.digits);
      }
      if (typeof exp === "number") {
        if (Number.isInteger(exp)) {
          const hex2 = Hex.of(BigInt(exp));
          return new _HexInt(hex2.sign, hex2.digits);
        }
        throw new import_sdk_errors17.InvalidDataType("HexInt.of", "not an integer", {
          exp
        });
      }
      const hex = Hex.of(exp);
      return new _HexInt(hex.sign, hex.digits);
    } catch (e) {
      throw new import_sdk_errors17.InvalidDataType(
        "HexInt.of",
        "not an hexadecimal integer expression",
        { exp: `${exp}`, e }
        // Needed to serialize bigint values.
      );
    }
  }
};

// src/vcdm/HexUInt.ts
var import_sdk_errors18 = require("@vechain/sdk-errors");
var HexUInt = class _HexUInt extends HexInt {
  /**
   * Regular expression for matching hexadecimal strings.
   * An empty input is represented as a empty digits.
   *
   * @type {RegExp}
   */
  static REGEX_HEXUINT = /^(0x)?[0-9a-f]*$/i;
  /**
   * Regular expression pattern to match a prefix indicating hexadecimal number.
   *
   * @type {RegExp}
   */
  static REGEX_HEXUINT_PREFIX = /^0x/i;
  /**
   * Checks if the given string expression is a valid unsigned hexadecimal value.
   *
   * @param {string} exp - The string representation of a hexadecimal value.
   *
   * @return {boolean} - True if the expression is a valid unsigned hexadecimal value, case-insensitive,
   * optionally prefixed with `0x`; false otherwise.
   */
  static isValid(exp) {
    return _HexUInt.REGEX_HEXUINT.test(exp);
  }
  /**
   * Determines whether the given string is a valid unsigned hexadecimal number prefixed with '0x'.
   *
   * @param {string} exp - The string to be evaluated.
   * @return {boolean} - True if the string is a valid unsigned hexadecimal number prefixed with '0x', otherwise false.
   */
  static isValid0x(exp) {
    return _HexUInt.REGEX_HEX_PREFIX.test(exp) && Hex.isValid(exp);
  }
  /**
   * Create a HexUInt instance from a bigint, number, string, Uint8Array, or {@link HexInt}.
   *
   * @param {bigint | number | string | Uint8Array | HexInt} exp - The expression to be interpreted as an unsigned integer:
   * * bigint is always representable in hexadecimal base notation,
   *   it throws {@link InvalidDataType} if not positive;
   * * number is converted to a bigint then represented in hexadecimal base notation,
   *   it throws {@link InvalidDataType} if not a positive integer value;
   * * string is parsed as the hexadecimal expression of a bigint value, optionally tagged with `0x`;
   *   it throws {@link InvalidDataType} if not positive;
   * * Uint8Array is interpreted as the sequence of bytes expressing a positive bigint value;
   * * {@link HexInt} is interpreted as expressing a bigint value,
   *   it throws {@link InvalidDataType} if not positive.
   *
   * @returns {HexUInt} he new HexInt object representing the given `exp`.
   *
   * @throws {InvalidDataType} If the given expression is not a valid hexadecimal positive integer expression.
   */
  static of(exp) {
    try {
      const hint = HexInt.of(exp);
      if (hint.sign >= Hex.POSITIVE) {
        return new _HexUInt(hint.sign, hint.digits);
      }
      throw new import_sdk_errors18.InvalidDataType(
        "HexUInt.of",
        "not positive",
        { exp: `${exp}` }
        // Needed to serialize bigint values.
      );
    } catch (e) {
      throw new import_sdk_errors18.InvalidDataType(
        "HexUInt.of",
        "not a hexadecimal positive integer expression",
        { exp: `${exp}`, e },
        // Needed to serialize bigint values.
        e
      );
    }
  }
};

// src/vcdm/Txt.ts
var import_sdk_errors19 = require("@vechain/sdk-errors");
var Txt = class _Txt extends String {
  /**
   * Decoder object used for decoding bytes as text data.
   *
   * @class
   * @constructor
   */
  static DECODER = new TextDecoder();
  /**
   * *Normalization Form Canonical Composition*
   * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence)
   * flag.
   *
   * @type {string}
   * @constant
   */
  static NFC = "NFC";
  /**
   * A TextEncoder instance used for encoding text to bytes.
   *
   * @type {TextEncoder}
   */
  static ENCODER = new TextEncoder();
  /**
   * Creates a new instance of this class representing the `exp` string
   * normalized according the *Canonical Composition Form*
   * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence).
   *
   * @param {string} exp - The expression to be passed to the constructor.
   * @protected
   * @constructor
   */
  constructor(exp) {
    super(exp.normalize(_Txt.NFC));
  }
  /**
   * Converts the current Txt string to a BigInt.
   *
   * @returns {bigint} The BigInt representation of the Txt string.
   *
   *  @throws {InvalidOperation} If the conversion to BigInt fails because this Txt string doesn't represent an integer.
   */
  get bi() {
    try {
      return BigInt(this.toString());
    } catch (e) {
      throw new import_sdk_errors19.InvalidOperation(
        "Txt.bi()",
        "Can't cast to big integer",
        { txt: this.toString() },
        e
      );
    }
  }
  /**
   * Converts the current Txt string to a buffer of bytes.
   *
   * @returns {Uint8Array} The bytes representation of the Txt string.
   */
  get bytes() {
    return _Txt.ENCODER.encode(this.toString());
  }
  /**
   * Returns the value of n as a number.
   *
   * @returns {number} The value of n as a number.
   */
  /**
   * Converts the current Txt string to a number.
   *
   * @returns {number} The numeric value of the Txt string.
   *
   * @throws {InvalidOperation} If the conversion to number fails because this Txt string doesn't represent a decimal number.
   */
  get n() {
    return Number(this.toString());
  }
  /**
   * Compares the current instance to another instance of Txt.
   *
   * @param {Txt} that - The instance to compare with.
   *
   * @return {number} - A negative number if the current instance is less than the specified instance,
   *                    zero if they are equal, or a positive number if the current instance is greater.
   */
  compareTo(that) {
    return this.toString().localeCompare(that.toString());
  }
  /**
   * Checks if the current Txt object is equal to the given Txt object.
   *
   * @param {Txt} that - The Txt object to compare with.
   *
   *  @return {boolean} - True if the objects are equal, false otherwise.
   */
  isEqual(that) {
    return this.compareTo(that) === 0;
  }
  /**
   * Returns a string representation of the object.
   *
   * @returns {string} A string representation of the object.
   */
  toString() {
    return this.valueOf();
  }
  /**
   * Creates a new Txt instance from the provided expression.
   *
   * @param {bigint | number | string | Uint8Array} exp - The expression to convert to Txt:
   * * {@link bigint} is represented as a {@link NFC} encoded string expressing the value in base 10;
   * * {@link number} is represented as a {@link NFC} encoded string expressing the value in base 10;
   * * {@link string} is encoded as {@link NFC} string;
   * * {@link Uint8Array} is {@link NFC} decoded to a string.
   *
   * @returns {Txt} - A new Txt instance.
   */
  static of(exp) {
    if (exp instanceof Uint8Array) {
      return new _Txt(_Txt.DECODER.decode(exp));
    } else if (typeof exp === "bigint" || typeof exp === "number") {
      return new _Txt(exp.toString());
    }
    return new _Txt(exp);
  }
};

// src/vcdm/Address.ts
var Address = class _Address extends HexUInt {
  /**
   * It checksums a given hexadecimal address.
   *
   * @param {HexUInt} huint The HexUInt object representing the hexadecimal value.
   *
   * @returns {string} The checksummed address.
   */
  static checksum(huint) {
    const stringAddress = huint.digits;
    const hash2 = Keccak256.of(Txt.of(stringAddress).bytes).digits;
    let checksum = "";
    for (let i = 0; i < stringAddress.length; i++) {
      checksum += parseInt(hash2[i], 16) > 7 ? stringAddress[i].toUpperCase() : stringAddress[i];
    }
    return "0x" + checksum;
  }
  /**
   * Validate the given expression to be a valid address.
   *
   *  @param {string} exp Expression to validate
   *
   * @returns {boolean} true if the expression is a valid address, false otherwise
   */
  static isValid(exp) {
    return Hex.isValid0x(exp) && exp.length === 42;
  }
  /**
   * Create ab Address instance from the given expression interpreted as an unsigned integer.
   *
   * @param exp The expression to convert. It can be of type bigint, number, string, Uint8Array, or HexUInt.
   *
   * @returns {Address} The converted hexadecimal unsigned integer.
   *
   * @throws {InvalidDataType} If the expression is not a valid hexadecimal positive integer expression.
   */
  static of(exp) {
    try {
      const huint = HexUInt.of(exp);
      if (_Address.isValid(huint.toString())) {
        const addressChecksummed = _Address.checksum(huint);
        return new _Address(
          Hex.POSITIVE,
          "0x0",
          // When we normalize we return the checksummed address as digits
          () => addressChecksummed.substring(2)
        );
      } else {
        throw new import_sdk_errors20.InvalidDataType("Address.of", "not a valid address", {
          huint
        });
      }
    } catch (error) {
      this.throwInvalidDataType(
        error,
        "Address.of",
        "not a valid hexadecimal positive integer expression",
        { exp: `${exp}`, error }
      );
    }
  }
  /**
   * Create an Address instance from the given private key.
   *
   * @param {Uint8Array} privateKey The private key to convert.
   *
   * @param {boolean} [isCompressed=true] The flag to indicate if the derived public key should be compressed.
   *
   * @returns {Address} The converted address.
   *
   * @remarks Security auditable method, depends on
   * * {@link secp256k1.derivePublicKey}.
   */
  static ofPrivateKey(privateKey, isCompressed = true) {
    try {
      return _Address.ofPublicKey(
        secp256k12.derivePublicKey(privateKey, isCompressed)
      );
    } catch (error) {
      if (error instanceof import_sdk_errors20.InvalidSecp256k1PrivateKey) {
        throw error;
      }
      this.throwInvalidDataType(
        error,
        "Address.ofPrivateKey",
        "not a valid private key",
        { privateKey: `${privateKey}`, error }
      );
    }
  }
  /**
   * Create an Address instance from the given public key.
   *
   * @param {Uint8Array} publicKey The public key to convert.
   *
   * @returns {Address} The converted address.
   *
   * @remarks Security auditable method, depends on
   * * {@link secp256k1.inflatePublicKey}.
   */
  static ofPublicKey(publicKey) {
    try {
      const publicKeyInflated = secp256k12.inflatePublicKey(publicKey);
      const publicKeyHash = Keccak256.of(
        publicKeyInflated.slice(1)
      ).bytes;
      return _Address.of(publicKeyHash.slice(12));
    } catch (error) {
      this.throwInvalidDataType(
        error,
        "Address.ofPublicKey",
        "not a valid public key",
        { publicKey: `${publicKey}`, error }
      );
    }
  }
  /**
   * Derives the address from a given list of words of
   * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
   * and a [BIP44 Derivation Path](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)
   * as in the examples.
   *
   * Secure audit function.
   * - {@link bip32.HDKey}(https://github.com/paulmillr/scure-bip32)
   * - {@link HDNode}
   *
   * @example `m/0` (default)
   * @example `m/0/2`
   * @example `m/0/2/4/6`
   *
   * @param {string[]} mnemonic - Mnemonic used to generate the HD node.
   * @param {string} [path='m/0'] - The derivation path from the current node.
   * @return {Address} - The derived address.
   * @throws {InvalidHDNode}
   *
   */
  static ofMnemonic(mnemonic2, path = "m/0") {
    const root = HDNode.fromMnemonic(mnemonic2);
    try {
      return _Address.ofPublicKey(
        root.derive(path).publicKey
      );
    } catch (error) {
      throw new import_sdk_errors20.InvalidHDNode(
        "mnemonic.deriveAddress()",
        "Invalid derivation path given as input.",
        { derivationPath: path },
        error
      );
    }
  }
};
var addressUtils = {
  fromPrivateKey: (privateKey) => Address.ofPrivateKey(privateKey).toString(),
  fromPublicKey: (publicKey) => Address.ofPublicKey(publicKey).toString(),
  isAddress: (addressToVerify) => Address.isValid(addressToVerify),
  toERC55Checksum: (address) => Address.checksum(HexUInt.of(address)).toString()
};

// src/vcdm/BloomFilter.ts
var import_sdk_errors21 = require("@vechain/sdk-errors");
var BloomFilter = class _BloomFilter {
  /**
   * Return the Bloom filter structure: an array of `m` bits per key encoding if a key is not part of the structure.
   *
   * @typedef {Uint8Array} bytes
   */
  bytes;
  /**
   * Return the number of hash functions used to compute this Bloom filter.
   *
   * @type {number}
   */
  k;
  /**
   * Creates a new instance of this class.
   *
   * @param {Uint8Array} bytes - The Bloom filter structure of `m` bits per key encoding if the key
   *                             likely belongs to the structure or surely doesn't.
   * @param {number} k - The number of hash functions used to compute this Bloom filter.
   *
   */
  constructor(bytes, k) {
    this.bytes = bytes;
    this.k = k;
  }
  /**
   * Return the Bloom filter data structure represented as a {@link bigint} value.
   *
   * @returns {bigint} - The Bloom filter data structure represented as a {@link bigint} value.
   */
  get bi() {
    return bytesToNumberBE(this.bytes);
  }
  /**
   * Return the Bloom filter data structure represented as a {@link number} value.
   *
   * @returns {bigint} - The Bloom filter data structure represented as a {@link number} value.
   *
   * @throws InvalidDataType if the data structure of the bloom filter can't be represented as a number
   * because underflow or overflow number safe integer range according
   * [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).
   *
   * @remarks Preferably use {@link bi} because the Bloom filter data structure can always be represented as a {@link bigint} value.
   */
  get n() {
    const bi = this.bi;
    if (Number.MIN_SAFE_INTEGER <= bi && bi <= Number.MAX_SAFE_INTEGER) {
      return Number(bi);
    }
    throw new import_sdk_errors21.InvalidDataType(
      "BloomFilter.n",
      "not in the safe number range",
      {
        bytes: this.bytes,
        k: this.k
      }
    );
  }
  /**
   * Compare the current BloomFilter instance with another BloomFilter instance according their
   * * {@link bytes} data structure first,
   * * {@link k} if the data structures are equal.
   *
   * @param {BloomFilter} that - The BloomFilter instance to compare with.
   *
   * @return {number} - Returns a negative number if the current instance is less than the provided instance,
   *                   returns zero if they are equal, and returns a positive number if the current instance is greater than the provided instance.
   */
  compareTo(that) {
    return this.bi < that.bi ? -1 : this.bi === that.bi ? this.k - that.k : 1;
  }
  /**
   * Checks if the current BloomFilter instance is equal to another BloomFilter instance.
   *
   * @param {BloomFilter} that - The other BloomFilter instance to compare with.
   *
   * @return {boolean} - Returns true if the current BloomFilter instance is equal to the other BloomFilter instance, otherwise returns false.
   */
  isEqual(that) {
    return this.bi === that.bi && this.k === that.k;
  }
  /**
   * Checks if the specified key may be contained within this Bloom filter or surely isn't.
   *
   * @param {Hex|Uint8Array} key - The key to check. It can be either a Hex object or a Uint8Array.
   *
   * @return {boolean} Returns true if this Bloom filter may contain the key, otherwise returns false.
   *
   * @remarks False positive matches are possible, but false negatives are not.
   * @remarks Security auditable method, depends on
   * * {@link hash}.
   */
  contains(key) {
    return distribute(
      hash(key instanceof Hex ? key.bytes : key),
      this.k,
      this.bytes.byteLength * 8,
      (index, bit) => {
        return (this.bytes[index] & bit) === bit;
      }
    );
  }
  /**
   * Calculates the optimal number of bits per key (`m` in math literature) based
   * on the number of hash functions (`k` in math literature) used to generate the Bloom Filter.
   *
   * Mathematically, `m` is approximated as `(k / ln(2))` which is simplified
   * to the higher integer close to `(m / 0.69)` for computational efficiency.
   * It also ensures that `k` is within a practical range [1, 30], hence the function
   * - returns `2` for `k = 1`,
   * - returns `44` for `k >= 30`.
   *
   * @param {number} k - The number of keys.
   *
   * @return {number} - The number of bits per key.
   */
  static computeBestBitsPerKey(k) {
    if (k <= 1) return 2;
    return k >= 30 ? 44 : Math.ceil(k / 0.69);
  }
  /**
   * Calculates the optimal number of hash functions (`k` in math literature)
   * based on bits per key (`m` in math literature).
   *
   * Mathematically, `k` is approximated as `(m * ln(2))` which is simplified
   * to the lower integer close to `(m * 0.69)` for computational efficiency.
   * It also ensures that `k` stays within a practical range [1, 30].
   *
   * @param m - The number of bits per key.
   *
   * @returns The calculated optimal `k` value.
   */
  static computeBestHashFunctionsQuantity(m) {
    const k = Math.floor(m * 0.69);
    if (k < 1) return 1;
    return k > 30 ? 30 : k;
  }
  /**
   * Checks if the current BloomFilter instance is possible to join with another BloomFilter instance.
   *
   * @param {BloomFilter} other - The BloomFilter instance to check if it is possible to join with the current instance.
   *
   * @return {boolean} - Returns true if the BloomFilter instances have the same 'k' value and 'bytes' length, false otherwise.
   */
  isJoinable(other) {
    return this.k === other.k && this.bytes.length === other.bytes.length;
  }
  /**
   * Joins the current BloomFilter with another BloomFilter by performing a bitwise OR operation on the
   * data structures of the filters.
   * Both filters must have been generated with the same number of hash functions, and they must have the same length.
   *
   * @param other - The BloomFilter to join with.
   *
   * @returns A new BloomFilter that represents the result of the join operation.
   *          They keys made this and `other` filter may belong to the returned filter.
   *          Any key not part of the joined filter surely doesn't belong to the returned filter.
   *
   * @throws {InvalidOperation} If the k values of the BloomFilters are different.
   * @throws {InvalidOperation} If the length of the byte arrays are different.
   */
  join(other) {
    if (this.k === other.k) {
      if (this.bytes.length === other.bytes.length) {
        return new _BloomFilter(
          new Uint8Array(
            this.bytes.map(
              (byte, index) => byte | other.bytes[index]
            )
          ),
          this.k
        );
      }
      throw new import_sdk_errors21.InvalidOperation(
        "BloomFilter.join",
        "different length values",
        { this: this, other }
      );
    }
    throw new import_sdk_errors21.InvalidOperation("BloomFilter.join", "different k values", {
      this: this,
      other
    });
  }
  /**
   * Creates a new instance of BloomFilterBuilder and adds the specified keys to it.
   * * Call {@link BloomFilterBuilder.add} to add more keys.
   * * Call {@link BloomFilterBuilder.build} to create a new Bloom filter once
   *
   * @param {...(Hex[] | Uint8Array[])} keys - The keys to be added to the BloomFilterBuilder.
   *
   * @returns {BloomFilterBuilder} - A new instance of BloomFilterBuilder with the specified keys added.
   *
   * @remarks Security auditable method, depends on
   * * {@link BloomFilterBuilder.add}.
   */
  static of(...keys) {
    const builder = new BloomFilterBuilder();
    builder.add(...keys);
    return builder;
  }
};
var BloomFilterBuilder = class _BloomFilterBuilder {
  /**
   * The default value number of hash functions used to create {@link BloomFilter} instances.
   */
  static DEFAULT_K = 5;
  /**
   * Map each element of the keys as likely part of the data structure of the Bloom filter to build.
   * Each key is mapped in `m` bits using `k` hash functions.
   *
   * @see {hash}
   */
  hashMap = /* @__PURE__ */ new Map();
  /**
   * Adds one or more keys to the Bloom filter to create.
   *
   * @param {Hex[] | Uint8Array[]} keys - The keys to be added to Bloom filter to create.
   *
   * @return {this} - Returns this {@link BloomFilterBuilder} instance, the {@link this.hashMap} is updated to
   * map the keys presence in the filter data structure.
   *
   * @remarks Security auditable method, depends on
   * * {@link hash}.
   */
  add(...keys) {
    for (const key of keys) {
      this.hashMap.set(hash(key instanceof Hex ? key.bytes : key), true);
    }
    return this;
  }
  /**
   * Builds a Bloom filter with the specified parameters and returns it.
   *
   * @param k - The number of hash functions to use in the Bloom filter.  to BloomFilterBuilder.DEFAULT_K.
   * @param m - The number of bits per key in the Bloom filter. Defaults to the value computed by BloomFilter.computeBestBitsPerKey(k).
   *
   * @return The built Bloom filter.
   */
  build(k = _BloomFilterBuilder.DEFAULT_K, m = BloomFilter.computeBestBitsPerKey(k)) {
    let nBytes = Math.floor((this.hashMap.size * m + 7) / 8);
    nBytes = nBytes < 8 ? 8 : nBytes;
    const bits = new Uint8Array(nBytes);
    const nBits = nBytes * 8;
    for (const hash2 of this.hashMap.keys()) {
      distribute(hash2, k, nBits, (index, bit) => {
        bits[index] |= bit;
        return true;
      });
    }
    return new BloomFilter(bits, k);
  }
};
var UINT32_LIMIT = 2 ** 32;
function addAndWrapAsUInt32(a, b) {
  return (a + b) % UINT32_LIMIT;
}
function distribute(hash2, k, m, collision) {
  const delta = (hash2 >>> 17 | hash2 << 15) >>> 0;
  for (let i = 0; i < k; i++) {
    const bitPos = hash2 % m;
    if (!collision(Math.floor(bitPos / 8), 1 << bitPos % 8)) {
      return false;
    }
    hash2 = addAndWrapAsUInt32(hash2, delta);
  }
  return true;
}
function hash(key) {
  return Number(
    bytesToNumberBE(Blake2b256.of(key).bytes.slice(0, 4))
  );
}

// src/vcdm/Mnemonic.ts
var import_bip39 = require("@scure/bip39");
var import_english = require("@scure/bip39/wordlists/english");
var import_sdk_errors22 = require("@vechain/sdk-errors");
var Mnemonic = class _Mnemonic {
  /**
   * A TextEncoder instance used for encoding text to bytes.
   *
   * @type {TextEncoder}
   */
  static ENCODER = new TextEncoder();
  /**
   * Throws an exception because the mnemonic cannot be represented as a big integer.
   * @returns {bigint} The BigInt representation of the mnemonic.
   * @throws {InvalidOperation} The mnemonic cannot be represented as a bigint.
   * @override {@link VeChainDataModel#bi}
   * @remark The conversion to BigInt is not supported for a mnemonic.
   */
  get bi() {
    throw new import_sdk_errors22.InvalidOperation(
      "Mnemonic.bi",
      "There is no big integer representation for a mnemonic.",
      { data: "" }
    );
  }
  /**
   * Generates a mnemonic as encoded bytes.
   *
   * @returns {Uint8Array} The bytes representation of the words with spaces.
   */
  get bytes() {
    return _Mnemonic.ENCODER.encode(_Mnemonic.of().join(" "));
  }
  /**
   * Throws an exception because the mnemonic cannot be represented as a number.
   * @returns {bigint} The number representation of the mnemonic.
   * @throws {InvalidOperation} The mnemonic cannot be represented as a number.
   * @override {@link VeChainDataModel#n}
   * @remark The conversion to number is not supported for a mnemonic.
   */
  get n() {
    throw new import_sdk_errors22.InvalidOperation(
      "Mnemonic.n",
      "There is no number representation for a mnemonic.",
      { data: "" }
    );
  }
  /**
   *
   * @param _that The mnemonic to compare with.
   */
  compareTo(_that) {
    throw new import_sdk_errors22.InvalidOperation(
      "Mnemonic.compareTo",
      "There is no comparison for a mnemonic since it is not stored in memory.",
      { data: "" }
    );
  }
  isEqual(_that) {
    throw new import_sdk_errors22.InvalidOperation(
      "Mnemonic.isEqual",
      "There is no comparison for a mnemonic since it is not stored in memory.",
      { data: "" }
    );
  }
  /**
   * Convert the number of words to the corresponding strength.
   *
   * @param numberOfWords The number of words.
   *
   * @returns {number} The corresponding strength.
   *
   * @throws {InvalidDataType} If the number of words is not valid.
   */
  static wordsNoToStrength(numberOfWords) {
    switch (numberOfWords) {
      case 12:
        return 128;
      case 15:
        return 160;
      case 18:
        return 192;
      case 21:
        return 224;
      case 24:
        return 256;
      default:
        throw new import_sdk_errors22.InvalidDataType(
          "Mnemonic.wordsNoToStrength",
          "not a valid number of words",
          { numberOfWords }
        );
    }
  }
  // Legacy method, probably should be part of a Private Key class (ofMnemonic) #1122
  /**
   * Derives a private key from a given list of
   * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
   * and a derivation path as in the examples.
   *
   * @example `m/0` (default)
   * @example `m/0/2`
   * @example `m/0/2/4/6`
   *
   * @param {string[]} words - The set of words used for mnemonic generation.
   * @param {string} [path='m/0'] - The derivation path from the current node.
   *
   * @returns {Uint8Array} - The derived private key as a Uint8Array.
   *
   * @throws {InvalidHDNode}
   *
   * @remarks Security auditable method, depends on
   * * {@link HDNode}.
   */
  static toPrivateKey(words, path = "m/0") {
    const root = HDNode.fromMnemonic(words);
    try {
      return root.derive(path).privateKey;
    } catch (error) {
      throw new import_sdk_errors22.InvalidHDNode(
        "mnemonic.derivePrivateKey()",
        "Invalid derivation path given as input.",
        { derivationPath: path },
        error
      );
    }
  }
  /**
   * Generates a
   * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
   * phrase using the specified wordlist size and random generator.
   *
   * @param {WordlistSizeType} wordlistSize The number of words to generate the mnemonic.
   * @param {function} [randomGenerator] The random generator function used to generate the entropy.
   *
   * @returns {Mnemonic} The generated mnemonic.
   *
   * @throws {InvalidDataType} If the number of words is not valid.
   *
   * @remarks Security auditable method, depends on
   * * [entropyToMnemonic](https://github.com/paulmillr/scure-bip39);
   * * [generateMnemonic](https://github.com/paulmillr/scure-bip39);
   * * `randomGenerator` - **Must provide a cryptographic secure source of entropy
   *    else any secure audit certification related with this software is invalid.**
   */
  static of(wordlistSize = 12, randomGenerator) {
    try {
      const strength = _Mnemonic.wordsNoToStrength(wordlistSize);
      if (randomGenerator != null) {
        const numberOfBytes = strength / 8;
        return (0, import_bip39.entropyToMnemonic)(
          randomGenerator(numberOfBytes),
          import_english.wordlist
        ).split(" ");
      }
      return (0, import_bip39.generateMnemonic)(import_english.wordlist, strength).split(" ");
    } catch (error) {
      throw new import_sdk_errors22.InvalidHDNodeMnemonic(
        "Mnemonic.of",
        "error while generating mnemonic",
        { wordlistSize },
        error
      );
    }
  }
  /**
   * Check if the given mnemonic words are valid.
   *
   * @param {string | string[]} words The mnemonic words to check.
   *
   * @returns {boolean} true if the words are valid, false otherwise.
   *
   * @remarks Security auditable method, depends on
   * * [validateMnemonic](https://github.com/paulmillr/scure-bip39).
   */
  static isValid(words) {
    const wordsToValidate = Array.isArray(words) ? words.join(" ") : words;
    return (0, import_bip39.validateMnemonic)(wordsToValidate, import_english.wordlist);
  }
};
var mnemonic = {
  deriveAddress: (words, path = "m/0") => Address.ofMnemonic(words, path).toString(),
  derivePrivateKey: (words, path = "m/0") => Mnemonic.toPrivateKey(words, path),
  generate: (wordlistSize, randomGenerator) => Mnemonic.of(wordlistSize, randomGenerator),
  isValid: (words) => Mnemonic.isValid(words)
};

// src/vcdm/Quantity.ts
var import_sdk_errors23 = require("@vechain/sdk-errors");
var Quantity = class _Quantity extends HexUInt {
  /**
   * Creates a Quantity instance from a bigint or number given expression
   *
   * @param {bigint | number} exp - The value to be expressed as Quantity object:
   * * bigint must be positive;
   * * number must be positive, it is converted to bigint to create the Quantity.
   *
   * @returns {Quantity} - The new Quantity object.
   *
   * @throws {InvalidDataType} - If the provided expression is not a positive integer value.
   */
  static of(exp) {
    try {
      const huint = HexUInt.of(exp);
      let cue = 0;
      while (cue < huint.digits.length && huint.digits.at(cue) === "0") {
        cue++;
      }
      return new _Quantity(
        huint.sign,
        cue === huint.digits.length ? "0" : huint.digits.slice(cue)
      );
    } catch (e) {
      throw new import_sdk_errors23.InvalidDataType(
        "Quantity.of",
        "not a Quantity expression",
        { exp: `${exp}` },
        // Needed to serialize bigint values.
        e
      );
    }
  }
};

// src/vcdm/Revision.ts
var import_sdk_errors24 = require("@vechain/sdk-errors");
var Revision = class _Revision extends Txt {
  /**
   * Regular expression pattern for revision strings.
   * Revision strings can be one of the following:
   * - "best": indicating the best revision
   * - "finalized": indicating a finalized revision
   * - A positive numeric string indicating a specific revision
   *
   * @type {RegExp}
   */
  static REGEX_DECIMAL_REVISION = /^(best|finalized|\d+)$/;
  /**
   * Determines if the given value is valid.
   * This is true if the given value is
   * - "best" string or {@link Txt}: indicating the best revision;
   * - "finalized" string or {@link Txt}: indicating a finalized revision;
   * - a positive number;
   * - a positive numeric decimal or `0x` prefixed hexadecimal string indicating a specific revision,
   *
   * @param {bigint | number | string | Hex | Txt} value - The value to be validated.
   * @returns {boolean} - Returns `true` if the value is valid, `false` otherwise.
   */
  static isValid(value) {
    if (typeof value === "number") {
      return Number.isInteger(value) && value >= 0;
    }
    return HexUInt.isValid0x(value) || _Revision.REGEX_DECIMAL_REVISION.test(value);
  }
  /**
   * Creates a new Revision object from the given value.
   *
   * @param {bigint | number | string | Uint8Array | Hex } value - The value to create the Revision from:
   * * {@link Hex} must be positive;
   * * {@link Uint8Array} is decoded as a string: see {@link Txt.of}.
   *
   * @returns {Revision} - The created Revision object.
   *
   *  @throws {InvalidDataType} if the given value is not a valid revision: see {@link isValid}.
   *
   * @remarks The string representation of the revision is always expressed as a number in base 10.
   * @remarks The {@link Uint8Array} value is decoded as a string content: see {@link Txt.of}.
   */
  static of(value) {
    try {
      let txt;
      if (value instanceof Hex) {
        txt = value.bi.toString();
      } else if (value instanceof Uint8Array) {
        txt = Txt.of(value).toString();
      } else {
        txt = `${value}`;
      }
      if (_Revision.isValid(txt)) {
        return new _Revision(txt);
      }
      throw new import_sdk_errors24.InvalidDataType("Revision.of", "not a revision", {
        value: `${value}`
      });
    } catch (e) {
      throw new import_sdk_errors24.InvalidDataType("Revision.of", "not a revision", {
        value: `${value}`,
        e
      });
    }
  }
};
var revisionUtils = {
  isRevisionAccount: (revision) => Revision.isValid(revision),
  isRevisionBlock: (revision) => Revision.isValid(revision)
};

// src/vcdm/ThorId.ts
var import_sdk_errors25 = require("@vechain/sdk-errors");
var ThorId = class _ThorId extends HexUInt {
  /**
   * Number of digits to represent a Thor ID value.
   *
   * @remarks The `0x` prefix is excluded.
   *
   * @type {number}
   */
  static DIGITS = 64;
  /**
   * Constructs a ThorId object with the provided hexadecimal value.
   *
   * @param {HexUInt} huint - The hexadecimal value representing the ThorId.
   *
   * @throws {InvalidDataType} - If the provided value is not a valid ThorId expression.
   */
  constructor(huint) {
    if (_ThorId.isValid(huint.digits)) {
      super(Hex.POSITIVE, huint.digits);
    } else {
      throw new import_sdk_errors25.InvalidDataType(
        "ThorId.constructor",
        "not a ThorId expression",
        { hex: huint }
      );
    }
  }
  /**
   * Check if the given expression is a valid ThorId.
   *
   * @param {string} exp - The expression to be validated.
   *
   * @return {boolean} Returns true if the expression is a valid ThorId, false otherwise.
   */
  static isValid(exp) {
    return Hex.isValid(exp) && HexUInt.REGEX_HEXUINT_PREFIX.test(exp) ? exp.length === _ThorId.DIGITS + 2 : exp.length === _ThorId.DIGITS;
  }
  /**
   * Determines whether the given string is a valid hex number prefixed with '0x'.
   *
   * @param {string} exp - The hex number to be checked.
   *
   *  @returns {boolean} - True if the hex number is valid, false otherwise.
   */
  static isValid0x(exp) {
    return HexUInt.REGEX_HEXUINT_PREFIX.test(exp) && _ThorId.isValid(exp);
  }
  /**
   * Creates a new ThorId object from the given expression.
   *
   * @param {bigint | number | string | Hex | Uint8Array} exp - The expression to create the ThorId from.
   *     It can be one of the following types:
   *     - bigint: A BigInteger value that represents the ThorId.
   *     - number: A number value that represents the ThorId.
   *     - string: A string value that represents the ThorId.
   *     - HexUInt: A HexUInt object that represents the ThorId.
   *     - Uint8Array: A Uint8Array object that represents the ThorId.
   *
   * @returns {ThorId} - A new ThorId object created from the given expression.
   *
   * @throws {InvalidDataType} If the given expression is not a valid hexadecimal positive integer expression.
   */
  static of(exp) {
    try {
      if (exp instanceof Hex) {
        return new _ThorId(exp.fit(this.DIGITS));
      }
      return new _ThorId(HexUInt.of(exp).fit(_ThorId.DIGITS));
    } catch (e) {
      throw new import_sdk_errors25.InvalidDataType(
        "ThorId.of",
        "not a ThorId expression",
        { exp: `${exp}` },
        // Needed to serialize bigint values.
        e
      );
    }
  }
};

// src/hash/Blake2b256.ts
var Blake2b256 = class _Blake2b256 extends HexUInt {
  /**
   * Generates the [BLAKE](https://en.wikipedia.org/wiki/BLAKE_(hash_function)) [BLAKE2B 256](https://www.blake2.net/) hash of the given input.
   *
   * @param {bigint | number | string | Uint8Array | Hex} exp - The input value to hash.
   *
   * @returns {Sha256} - The [BLAKE2B 256](https://www.blake2.net/) hash of the input value.
   *
   * @throws {InvalidOperation} - If a hash error occurs.
   *
   * @remarks Security auditable method, depends on
   * * [`nh_blake2b.create(...).update(...).digest(...)`](https://github.com/paulmillr/noble-hashes#sha3-fips-shake-keccak).
   */
  static of(exp) {
    try {
      const hash2 = import_blake2b.blake2b.create({ dkLen: 32 }).update(HexUInt.of(exp).bytes).digest();
      return new _Blake2b256(Hex.POSITIVE, HexUInt.of(hash2).digits);
    } catch (e) {
      throw new import_sdk_errors26.InvalidOperation("Blake2b256.of", "hash error", {
        exp: `${exp}`,
        // Needed to serialize bigint values.
        e
      });
    }
  }
};
function blake2b256(data, returnType = "buffer") {
  return returnType === "buffer" ? Blake2b256.of(Txt.of(data).bytes).bytes : Blake2b256.of(Txt.of(data).bytes).toString();
}

// src/hash/Keccak256.ts
var import_sha3 = require("@noble/hashes/sha3");
var import_sdk_errors27 = require("@vechain/sdk-errors");
var Keccak256 = class _Keccak256 extends HexUInt {
  /**
   * Generates the [SHA-3](https://en.wikipedia.org/wiki/SHA-3) [KECCAK 256](https://keccak.team/keccak.html) hash of the given input.
   *
   * @param {bigint | number | string | Uint8Array | Hex} exp - The input value to hash.
   *
   * @returns {Sha256} - The [KECCAK 256](https://keccak.team/keccak.html) hash of the input value.
   *
   * @throws {InvalidOperation} - If a hash error occurs.
   *
   * @remarks Security auditable method, depends on
   * * [`nh_keccak_256`](https://github.com/paulmillr/noble-hashes#sha3-fips-shake-keccak).
   */
  static of(exp) {
    try {
      const hash2 = (0, import_sha3.keccak_256)(HexUInt.of(exp).bytes);
      return new _Keccak256(Hex.POSITIVE, HexUInt.of(hash2).digits);
    } catch (e) {
      throw new import_sdk_errors27.InvalidOperation("Keccak256.of", "hash error", {
        exp: `${exp}`,
        // Needed to serialize bigint values.
        e
      });
    }
  }
};
function keccak256(data, returnType = "buffer") {
  return returnType === "buffer" ? Keccak256.of(Txt.of(data).bytes).bytes : Keccak256.of(Txt.of(data).bytes).toString();
}

// src/hash/Sha256.ts
var nh_sha256 = __toESM(require("@noble/hashes/sha256"));
var import_sdk_errors28 = require("@vechain/sdk-errors");
var Sha256 = class _Sha256 extends HexUInt {
  /**
   * Generates the [SHA 256](https://en.wikipedia.org/wiki/SHA-2) hash of the given input.
   *
   * @param {bigint | number | string | Uint8Array | Hex} exp - The input value to hash.
   *
   * @returns {Sha256} - The [SHA256](https://en.wikipedia.org/wiki/SHA-2) hash of the input value.
   *
   * @throws {InvalidOperation} - If a hash error occurs.
   *
   * @remarks Security auditable method, depends on
   * * [`nh_sha256.sha256`](https://github.com/paulmillr/noble-hashes#sha2-sha256-sha384-sha512-and-others).
   */
  static of(exp) {
    try {
      const hash2 = nh_sha256.sha256(HexUInt.of(exp).bytes);
      return new _Sha256(Hex.POSITIVE, HexUInt.of(hash2).digits);
    } catch (e) {
      throw new import_sdk_errors28.InvalidOperation("Sha256.of", "hash error", {
        exp: `${exp}`,
        // Needed to serialize bigint values.
        e
      });
    }
  }
};
function sha2563(data, returnType = "buffer") {
  return returnType === "buffer" ? Sha256.of(Txt.of(data).bytes).bytes : Sha256.of(Txt.of(data).bytes).toString();
}

// src/certificate/certificate.ts
function encode3(cert) {
  return Txt.of(
    // The following `fastJsonStableStringify` strips blank chars and serialize alphabetical sorted properties.
    (0, import_fast_json_stable_stringify.default)({
      purpose: cert.purpose,
      payload: {
        type: cert.payload.type,
        content: cert.payload.content
      },
      domain: cert.domain,
      timestamp: cert.timestamp,
      signer: cert.signer.toLowerCase()
    })
  ).bytes;
}
function sign2(cert, privateKey) {
  return {
    ...cert,
    signature: Hex.of(
      secp256k12.sign(Blake2b256.of(encode3(cert)).bytes, privateKey)
    ).toString()
  };
}
function verify(cert) {
  if (cert.signature === void 0 || cert.signature === null) {
    throw new import_sdk_errors29.CertificateSignature(
      "certificate.verify()",
      "Verification failed: certificate's signature is missing.",
      { cert }
    );
  }
  if (!Hex.isValid0x(cert.signature) || cert.signature.length % 2 !== 0) {
    throw new import_sdk_errors29.CertificateSignature(
      "certificate.verify()",
      "Verification failed: signature format is invalid.",
      { cert }
    );
  }
  const sign4 = Hex.of(cert.signature).bytes;
  const hash2 = Blake2b256.of(encode3(cert)).bytes;
  const signer = Address.ofPublicKey(secp256k12.recover(hash2, sign4)).toString().toLowerCase();
  if (signer !== cert.signer?.toLowerCase()) {
    throw new import_sdk_errors29.CertificateSignature(
      "certificate.verify()",
      "Verification failed: signature does not correspond to the signer's public key.",
      { cert }
    );
  }
}
var certificate = { encode: encode3, sign: sign2, verify };

// src/clause/clause.ts
var import_sdk_errors30 = require("@vechain/sdk-errors");
function deployContract(contractBytecode, deployParams, clauseOptions) {
  let encodedParams = "";
  if (deployParams != null) {
    encodedParams = abi.encodeParams(deployParams.types, deployParams.values).replace("0x", "");
  }
  const transactionClause = {
    to: null,
    value: 0,
    data: contractBytecode + encodedParams
  };
  if (clauseOptions?.comment !== void 0) {
    return {
      ...transactionClause,
      comment: clauseOptions.comment
    };
  } else {
    return transactionClause;
  }
}
function functionInteraction(contractAddress, functionFragment, args, value = 0, clauseOptions) {
  const transactionClause = {
    to: contractAddress,
    value,
    data: new abi.Function(functionFragment).encodeInput(args)
  };
  if (clauseOptions !== void 0) {
    return {
      ...transactionClause,
      comment: clauseOptions.comment,
      abi: clauseOptions.includeABI === true ? functionFragment.format("json") : void 0
    };
  } else {
    return transactionClause;
  }
}
function transferToken(tokenAddress, recipientAddress, amount, clauseOptions) {
  try {
    return functionInteraction(
      tokenAddress,
      coder.createInterface(VIP180_ABI).getFunction("transfer"),
      [recipientAddress, BigInt(amount)],
      void 0,
      clauseOptions
    );
  } catch (error) {
    throw new import_sdk_errors30.InvalidDataType(
      "transferToken()",
      `Invalid 'amount' parameter. Expected an integer but received ${amount}.`,
      { amount },
      error
    );
  }
}
function transferVET(recipientAddress, amount, clauseOptions) {
  try {
    const bnAmount = BigInt(amount);
    if (bnAmount < 0) {
      throw new import_sdk_errors30.InvalidDataType(
        "transferVET()",
        `Invalid 'amount' parameter. Expected a positive amount but received ${amount}.`,
        { amount }
      );
    }
    const transactionClause = {
      to: recipientAddress,
      value: `0x${BigInt(amount).toString(16)}`,
      data: "0x"
    };
    if (clauseOptions?.comment !== void 0) {
      return {
        ...transactionClause,
        comment: clauseOptions.comment
      };
    } else {
      return transactionClause;
    }
  } catch (error) {
    throw new import_sdk_errors30.InvalidDataType(
      "transferVET()",
      `Invalid 'amount' parameter. Expected an integer but received ${amount}.`,
      { amount },
      error
    );
  }
}
function transferNFT(contractAddress, senderAddress, recipientAddress, tokenId, clauseOptions) {
  if (tokenId === "") {
    throw new import_sdk_errors30.InvalidDataType(
      "transferNFT()",
      `Invalid 'tokenId' parameter. Expected an id but received ${tokenId}.`,
      { tokenId }
    );
  }
  if (!Address.isValid(senderAddress)) {
    throw new import_sdk_errors30.InvalidDataType(
      "transferNFT()",
      `Invalid 'senderAddress' parameter. Expected a contract address but received ${senderAddress}.`,
      { senderAddress }
    );
  }
  if (!Address.isValid(contractAddress)) {
    throw new import_sdk_errors30.InvalidDataType(
      "transferNFT()",
      `Invalid 'senderAddress' parameter. Expected a contract address but received ${contractAddress}.`,
      { contractAddress }
    );
  }
  const functionFragment = coder.createInterface(ERC721_ABI).getFunction("transferFrom");
  return functionInteraction(
    contractAddress,
    functionFragment,
    [senderAddress, recipientAddress, tokenId],
    void 0,
    clauseOptions
  );
}
var clauseBuilder = {
  deployContract,
  functionInteraction,
  transferToken,
  transferVET,
  transferNFT
};

// src/keystore/keystore.ts
var import_sdk_logging = require("@vechain/sdk-logging");

// src/keystore/cryptography/ethers/const/keystore.ts
var SCRYPT_PARAMS = {
  N: 131072,
  r: 8,
  p: 1
};

// src/keystore/cryptography/ethers/keystore.ts
var import_ethers4 = require("ethers");
var import_sdk_errors31 = require("@vechain/sdk-errors");
async function encrypt(privateKey, password) {
  const derivePublicKey2 = secp256k12.derivePublicKey(privateKey);
  const deriveAddress = Address.ofPublicKey(
    Buffer.from(derivePublicKey2)
  ).toString();
  const keystoreAccount = {
    address: deriveAddress,
    privateKey: Hex.of(privateKey).toString()
  };
  const encryptOptions = {
    scrypt: {
      N: SCRYPT_PARAMS.N,
      r: SCRYPT_PARAMS.r,
      p: SCRYPT_PARAMS.p
    }
  };
  const keystoreJsonString = await import_ethers4.ethers.encryptKeystoreJson(
    keystoreAccount,
    password,
    encryptOptions
  );
  return JSON.parse(keystoreJsonString);
}
async function decrypt(keystore4, password) {
  if (!isValid(keystore4)) {
    throw new import_sdk_errors31.InvalidKeystore(
      "keystore.decrypt()",
      "Invalid keystore. Ensure the keystore is properly formatted and contains the necessary data.",
      { keystore: keystore4 }
    );
  }
  try {
    return await import_ethers4.ethers.decryptKeystoreJson(
      (0, import_sdk_errors31.stringifyData)(keystore4),
      password
    );
  } catch (e) {
    throw new import_sdk_errors31.InvalidKeystoreParams(
      "keystore.decrypt()",
      "Decryption failed: Invalid Password for the given keystore.",
      // @NOTE: We are not exposing the password in the error data for security reasons.
      {
        keystore: keystore4
      }
    );
  }
}
function isValid(keystore4) {
  return import_ethers4.ethers.isKeystoreJson((0, import_sdk_errors31.stringifyData)(keystore4));
}
var keystore = { encrypt, decrypt, isValid };

// src/keystore/cryptography/experimental/keystore.ts
var import_aes = require("@noble/ciphers/aes");
var import_scrypt = require("@noble/hashes/scrypt");
var import_sdk_errors32 = require("@vechain/sdk-errors");
var KEYSTORE_CRYPTO_CIPHER = "aes-128-ctr";
var KEYSTORE_CRYPTO_PARAMS_DKLEN = 32;
var KEYSTORE_CRYPTO_KDF = "scrypt";
var KEYSTORE_VERSION = 3;
var SCRYPT_PARAMS2 = {
  N: 131072,
  r: 8,
  p: 1
};
function decodeScryptParams(keystore4) {
  const salt = hexToBytes(keystore4.crypto.kdfparams.salt);
  const N = keystore4.crypto.kdfparams.n;
  const r = keystore4.crypto.kdfparams.r;
  const p = keystore4.crypto.kdfparams.p;
  if (N <= 0 || (N & N - 1) !== 0)
    throw new import_sdk_errors32.InvalidKeystoreParams(
      "(EXPERIMENTAL) keystore.decodeScryptParams()",
      "Decryption failed: invalid  keystore.crypto.kdfparams.n parameter.",
      {
        keystore: keystore4,
        N
      }
    );
  if (r <= 0 || p <= 0)
    throw new import_sdk_errors32.InvalidKeystoreParams(
      "(EXPERIMENTAL) keystore.decodeScryptParams()",
      "Decryption failed: both keystore.crypto.kdfparams.r or keystore.crypto.kdfparams.p parameter must be > 0.",
      {
        keystore: keystore4,
        r,
        p
      }
    );
  const dkLen = keystore4.crypto.kdfparams.dklen;
  if (dkLen !== KEYSTORE_CRYPTO_PARAMS_DKLEN)
    throw new import_sdk_errors32.InvalidKeystoreParams(
      "(EXPERIMENTAL) keystore.decodeScryptParams()",
      `Decryption failed: keystore.crypto.kdfparams.dklen parameter must be ${KEYSTORE_CRYPTO_PARAMS_DKLEN}`,
      {
        keystore: keystore4,
        dkLen
      }
    );
  return {
    N,
    dkLen: KEYSTORE_CRYPTO_PARAMS_DKLEN,
    name: KEYSTORE_CRYPTO_KDF,
    p,
    r,
    salt
  };
}
function encodeScryptParams(options) {
  const salt = options.salt ?? secp256k12.randomBytes(KEYSTORE_CRYPTO_PARAMS_DKLEN);
  let N = SCRYPT_PARAMS2.N;
  let r = SCRYPT_PARAMS2.r;
  let p = SCRYPT_PARAMS2.p;
  if (options.scrypt != null) {
    if (options.scrypt.N != null) {
      N = options.scrypt.N;
    }
    if (options.scrypt.r != null) {
      r = options.scrypt.r;
    }
    if (options.scrypt.p != null) {
      p = options.scrypt.p;
    }
  }
  if (N <= 0 || (BigInt(N) & BigInt(N - 1)) !== BigInt(0))
    throw new import_sdk_errors32.InvalidKeystoreParams(
      "(EXPERIMENTAL) keystore.encodeScryptParams()",
      "Encryption failed: invalid options.scrypt.N parameter.",
      {
        options,
        N
      }
    );
  if (r <= 0 || !Number.isSafeInteger(r))
    throw new import_sdk_errors32.InvalidKeystoreParams(
      "(EXPERIMENTAL) keystore.encodeScryptParams()",
      "Encryption failed: invalid options.scrypt.r parameter.",
      {
        options,
        r
      }
    );
  if (p <= 0 || !Number.isSafeInteger(p))
    throw new import_sdk_errors32.InvalidKeystoreParams(
      "(EXPERIMENTAL) keystore.encodeScryptParams()",
      "Encryption failed: invalid options.scrypt.p parameter.",
      {
        options,
        p
      }
    );
  return {
    name: KEYSTORE_CRYPTO_KDF,
    dkLen: KEYSTORE_CRYPTO_PARAMS_DKLEN,
    N,
    p,
    r,
    salt
  };
}
function encrypt2(privateKey, password) {
  return encryptKeystore(privateKey, password, {
    scrypt: {
      N: SCRYPT_PARAMS2.N,
      r: SCRYPT_PARAMS2.r,
      p: SCRYPT_PARAMS2.p
    }
  });
}
function encryptKeystore(privateKey, password, options) {
  try {
    const kdf = encodeScryptParams(options);
    const key = (0, import_scrypt.scrypt)(password, kdf.salt, {
      N: kdf.N,
      r: kdf.r,
      p: kdf.p,
      dkLen: kdf.dkLen
    });
    const iv = options.iv ?? secp256k12.randomBytes(16);
    if (iv.length !== 16)
      throw new import_sdk_errors32.InvalidKeystoreParams(
        "(EXPERIMENTAL) keystore.encryptKeystore()",
        "Encryption failed: invalid options.iv length.",
        { iv }
      );
    const uuidRandom = options.uuid ?? secp256k12.randomBytes(16);
    if (uuidRandom.length !== 16)
      throw new import_sdk_errors32.InvalidKeystoreParams(
        "(EXPERIMENTAL) keystore.encryptKeystore()",
        "Encryption failed: invalid options.uuid length.",
        { uuidRandom }
      );
    const macPrefix = key.slice(16, 32);
    const ciphertext = (0, import_aes.ctr)(key.slice(0, 16), iv).encrypt(privateKey);
    return {
      address: Address.ofPrivateKey(privateKey).toString(),
      crypto: {
        cipher: KEYSTORE_CRYPTO_CIPHER,
        cipherparams: {
          iv: Hex.of(iv).digits
        },
        ciphertext: Hex.of(ciphertext).digits,
        kdf: "scrypt",
        kdfparams: {
          dklen: KEYSTORE_CRYPTO_PARAMS_DKLEN,
          n: kdf.N,
          p: kdf.p,
          r: kdf.r,
          salt: Hex.of(kdf.salt).digits
        },
        // Compute the message authentication code, used to check the password.
        mac: Keccak256.of(concatBytes(macPrefix, ciphertext)).digits
      },
      id: uuidV4(uuidRandom),
      version: KEYSTORE_VERSION
    };
  } finally {
    privateKey.fill(0);
    password.fill(0);
  }
}
function decrypt2(keystore4, password) {
  return decryptKeystore(keystore4, password);
}
function decryptKeystore(keystore4, password) {
  try {
    if (keystore4.crypto.cipher.toLowerCase() !== KEYSTORE_CRYPTO_CIPHER)
      throw new import_sdk_errors32.InvalidKeystoreParams(
        "(EXPERIMENTAL) keystore.decryptKeystore()",
        "Decryption failed: unsupported crypto cipher algorithm.",
        { cipher: keystore4.crypto.cipher.toLowerCase() }
      );
    if (keystore4.crypto.kdf.toLowerCase() !== KEYSTORE_CRYPTO_KDF)
      throw new import_sdk_errors32.InvalidKeystoreParams(
        "(EXPERIMENTAL) keystore.decryptKeystore()",
        "Decryption failed: unsupported crypto key derivation function.",
        { keyDerivationFunction: keystore4.crypto.kdf.toLowerCase() }
      );
    if (keystore4.version !== KEYSTORE_VERSION)
      throw new import_sdk_errors32.InvalidKeystoreParams(
        "(EXPERIMENTAL) keystore.decryptKeystore()",
        "Decryption failed: unsupported keystore version.",
        { version: keystore4.version }
      );
    const kdf = decodeScryptParams(keystore4);
    const key = (0, import_scrypt.scrypt)(password, kdf.salt, {
      N: kdf.N,
      r: kdf.r,
      p: kdf.p,
      dkLen: kdf.dkLen
    });
    const ciphertext = hexToBytes(keystore4.crypto.ciphertext);
    if (keystore4.crypto.mac !== Keccak256.of(concatBytes(key.slice(16, 32), ciphertext)).digits) {
      throw new import_sdk_errors32.InvalidKeystoreParams(
        "(EXPERIMENTAL) keystore.decryptKeystore()",
        "Decryption failed: Invalid Password for the given keystore.",
        // @NOTE: We are not exposing the password in the error data for security reasons.
        {
          keystore: keystore4
        }
      );
    }
    const privateKey = (0, import_aes.ctr)(
      key.slice(0, 16),
      hexToBytes(keystore4.crypto.cipherparams.iv)
    ).decrypt(ciphertext);
    const address = Address.ofPrivateKey(privateKey).toString();
    if (keystore4.address !== "" && address !== Address.checksum(Hex.of(keystore4.address))) {
      throw new import_sdk_errors32.InvalidKeystoreParams(
        "(EXPERIMENTAL) keystore.decryptKeystore()",
        "Decryption failed: address/password mismatch.",
        { keystoreAddress: keystore4.address }
      );
    }
    return {
      address,
      // @note: Convert the private key to a string to be compatible with ethers
      privateKey: Hex.of(privateKey).toString()
    };
  } finally {
    password.fill(0);
  }
}
function isValid2(keystore4) {
  try {
    const copy = JSON.parse((0, import_sdk_errors32.stringifyData)(keystore4));
    if (copy.crypto.cipher.toLowerCase() === KEYSTORE_CRYPTO_CIPHER && copy.crypto.kdf.toLowerCase() === KEYSTORE_CRYPTO_KDF && copy.version === KEYSTORE_VERSION) {
      return true;
    }
  } catch (error) {
  }
  return false;
}
function uuidV4(bytes) {
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const value = Hex.of(bytes).digits;
  return [
    value.substring(0, 8),
    value.substring(8, 12),
    value.substring(12, 16),
    value.substring(16, 20),
    value.substring(20, 32)
  ].join("-");
}
var keystore2 = { decrypt: decrypt2, encrypt: encrypt2, isValid: isValid2 };

// src/keystore/keystore.ts
var EXPERIMENTAL_CRYPTOGRAPHY = false;
function useExperimentalCryptography(experimentalCryptography) {
  EXPERIMENTAL_CRYPTOGRAPHY = experimentalCryptography;
}
async function encrypt3(privateKey, password) {
  if (EXPERIMENTAL_CRYPTOGRAPHY)
    (0, import_sdk_logging.VeChainSDKLogger)("warning").log({
      title: `Experimental cryptography`,
      messages: [
        `Remember, you are using an experimental cryptography library.`,
        "functions: keystore.encrypt"
      ]
    });
  return EXPERIMENTAL_CRYPTOGRAPHY ? keystore2.encrypt(privateKey, Txt.of(password).bytes) : await keystore.encrypt(privateKey, password);
}
async function decrypt3(keystore4, password) {
  if (EXPERIMENTAL_CRYPTOGRAPHY)
    (0, import_sdk_logging.VeChainSDKLogger)("warning").log({
      title: `Experimental cryptography`,
      messages: [
        `Remember, you are using an experimental cryptography library.`,
        "functions: keystore.decrypt"
      ]
    });
  return EXPERIMENTAL_CRYPTOGRAPHY ? keystore2.decrypt(keystore4, Txt.of(password).bytes) : await keystore.decrypt(keystore4, password);
}
function isValid3(keystore4) {
  if (EXPERIMENTAL_CRYPTOGRAPHY)
    (0, import_sdk_logging.VeChainSDKLogger)("warning").log({
      title: `Experimental cryptography`,
      messages: [
        `Remember, you are using an experimental cryptography library.`,
        "functions: keystore.isValid"
      ]
    });
  return EXPERIMENTAL_CRYPTOGRAPHY ? keystore2.isValid(keystore4) : keystore.isValid(keystore4);
}
var keystore3 = { encrypt: encrypt3, decrypt: decrypt3, isValid: isValid3, useExperimentalCryptography };

// src/transaction/transaction.ts
var import_sdk_errors33 = require("@vechain/sdk-errors");
var Transaction = class _Transaction {
  /**
   * Transaction body. It represents the body of the transaction.
   *
   * @note It is better to take it as a read-only property in order to avoid any external modification.
   */
  body;
  /**
   * Transaction signature. It represents the signature of the transaction.
   *
   * @note It is better to take it as a read-only property in order to avoid any external modification.
   */
  signature;
  /**
   * Constructor with parameters.
   * This constructor creates a transaction immutable object.
   *
   * @param body - Transaction body
   * @param signature - Optional signature for the transaction
   * @throws {InvalidTransactionField, InvalidSecp256k1Signature}
   */
  constructor(body, signature) {
    if (!_Transaction.isValidBody(body)) {
      throw new import_sdk_errors33.InvalidTransactionField(
        "Transaction constructor",
        "Invalid transaction body. Ensure all required fields are correctly formatted and present.",
        { fieldName: "body", body }
      );
    }
    this.body = body;
    if (signature !== void 0 && !this._isSignatureValid(signature)) {
      throw new import_sdk_errors33.InvalidSecp256k1Signature(
        "Transaction constructor",
        "Invalid transaction signature. Ensure it is correctly formatted.",
        { signature }
      );
    }
    this.signature = signature;
  }
  // ********** PUBLIC GET ONLY FUNCTIONS **********
  /**
   * Calculate intrinsic gas required for this transaction
   *
   * @returns Intrinsic gas required for this transaction
   */
  get intrinsicGas() {
    return TransactionUtils.intrinsicGas(this.body.clauses);
  }
  /**
   * Determines whether the transaction is delegated.
   *
   * @returns If transaction is delegated or not
   */
  get isDelegated() {
    return this._isDelegated(this.body);
  }
  /**
   * Get transaction delegator address from signature.
   *
   * @returns Transaction delegator address
   * @throws {NotDelegatedTransaction, UnavailableTransactionField}
   */
  get delegator() {
    if (!this.isDelegated)
      throw new import_sdk_errors33.NotDelegatedTransaction(
        "Transaction.delegator()",
        "Transaction is not delegated. Delegate information is unavailable.",
        void 0
      );
    if (!this.isSigned)
      throw new import_sdk_errors33.UnavailableTransactionField(
        "Transaction.delegator()",
        "Transaction is not signed. 'delegator' information is unavailable.",
        { fieldName: "delegator" }
      );
    const signatureSliced = this.signature.subarray(
      65,
      this.signature?.length
    );
    const delegatorPublicKey = secp256k12.recover(
      this.getSignatureHash(this.origin),
      signatureSliced
    );
    return Address.ofPublicKey(Buffer.from(delegatorPublicKey)).toString();
  }
  /**
   * Determines whether the transaction is signed or not.
   *
   * @returns If transaction is signed or not
   */
  get isSigned() {
    return this.signature !== void 0;
  }
  /**
   * Computes the signature hash for the transaction. The output is based on
   * the presence of the 'delegateFor' parameter.
   *
   * @param delegateFor - Optional address of the delegator.
   * @returns The computed hash.
   *
   * Mainly:
   *  - No 'delegateFor': return txHash
   * - 'delegateFor' return txHash +  hash('delegateFor' address)
   *
   * @remarks
   * delegateFor is used to sign a transaction on behalf of another account.
   * In fact when the delegator sign the transaction, delegator will add the address
   * of who send the transaction to sign (in this case the 'delegateFor' address parameter)
   *
   * @example
   * A is transaction origin
   * B is the delegator
   * TX is the transaction
   *
   * A sends a TX (signed by A) to B to who add his signature to TX using delegateFor parameter (that is A address)
   * on signing hash of TX computation.
   *
   * Mathematically:
   *
   * ```
   * final_signature = concat_buffer(
   *      sign(TX.signingHash(), A.privateKey),
   *      sign(TX.signingHash(A.address), B.privateKey)
   * )
   * ```
   *
   * Where:
   *
   * ```
   * TX.signatureHash() = blake2b256(TX.encoded)
   * TX.signingHash(A.address) = blake2b256(
   *      concat(
   *              blake2b256(TX.encoded),
   *              A.address
   *             )
   * )
   * ```
   *
   * @param delegateFor - Address of the delegator
   * @returns Signing hash of the transaction
   * @throws {InvalidTransactionField}
   */
  getSignatureHash(delegateFor) {
    if (delegateFor !== void 0 && !Address.isValid(delegateFor)) {
      throw new import_sdk_errors33.InvalidTransactionField(
        "Transaction.getSignatureHash()",
        "Invalid address given as input as delegateFor parameter. Ensure it is a valid address.",
        { fieldName: "delegateFor", delegateFor }
      );
    }
    const transactionHash = Blake2b256.of(this._encode(false)).bytes;
    if (delegateFor !== void 0) {
      return Buffer.from(
        Blake2b256.of(
          Buffer.concat([
            Buffer.from(transactionHash),
            Buffer.from(delegateFor.slice(2), "hex")
          ])
        ).bytes
      );
    }
    return Buffer.from(transactionHash);
  }
  /**
   * Encode a transaction
   *
   * @returns The transaction encoded
   */
  get encoded() {
    return this._encode(this.isSigned);
  }
  /**
   * Get transaction origin address from signature.
   *
   * @returns Transaction origin
   * @throws {UnavailableTransactionField}
   */
  get origin() {
    if (!this.isSigned)
      throw new import_sdk_errors33.UnavailableTransactionField(
        "Transaction.origin()",
        "Transaction is not signed. 'origin' information is unavailable.",
        { fieldName: "origin" }
      );
    const signatureSliced = this.signature.subarray(0, 65);
    const originPublicKey = secp256k12.recover(
      this.getSignatureHash(),
      signatureSliced
    );
    return Address.ofPublicKey(Buffer.from(originPublicKey)).toString();
  }
  /**
   * Get transaction ID from signature.
   *
   * @returns Transaction ID
   * @throws {UnavailableTransactionField}
   */
  get id() {
    if (!this.isSigned)
      throw new import_sdk_errors33.UnavailableTransactionField(
        "Transaction.id()",
        "Transaction is not signed. 'id' information is unavailable.",
        { fieldName: "id" }
      );
    return Blake2b256.of(
      Buffer.concat([
        this.getSignatureHash(),
        Buffer.from(this.origin.slice(2), "hex")
      ])
    ).toString();
  }
  // ********** INTERNAL PRIVATE FUNCTIONS **********
  /**
   * Internal function to check if transaction is delegated or not.
   * This function is used to check directly the transaction body.
   * @private
   *
   * @param body Transaction body to check
   * @returns Weather the transaction is delegated or not
   */
  _isDelegated(body) {
    const reserved = body.reserved ?? {};
    const features = reserved.features ?? 0;
    return (features & 1) === 1;
  }
  /**
   * Internal function to check if signature is valid or not.
   * This function is used to check directly the signature.
   * @private
   *
   * @param signature Signature to check
   * @returns Weather the signature is valid or not
   */
  _isSignatureValid(signature) {
    const expectedSignatureLength = this._isDelegated(this.body) ? SIGNATURE_LENGTH * 2 : SIGNATURE_LENGTH;
    return signature.length === expectedSignatureLength;
  }
  /**
   * Encodes the reserved field to ensure it exists in every encoding.
   *
   * Due to the fact that reserved field is optional in TransactionBody,
   * BUT mandatory in RLPProfiler, we need to have it in every encoding.
   * Fot this reason this function is needed.
   * @private
   *
   * @returns Encoding of reserved field
   */
  _encodeReservedField() {
    const reserved = this.body.reserved ?? {};
    const featuresKind = TRANSACTION_FEATURES_KIND.kind;
    const featuresList = [
      featuresKind.data(reserved.features ?? 0, TRANSACTION_FEATURES_KIND.name).encode(),
      ...reserved.unused ?? []
    ];
    while (featuresList.length > 0) {
      if (featuresList[featuresList.length - 1].length === 0) {
        featuresList.pop();
      } else {
        break;
      }
    }
    return featuresList;
  }
  /**
   * Make the RLP encoding of a transaction body.
   * @private
   *
   * @param body Body to encode
   * @param isSigned If transaction is signed or not
   * @returns RLP encoding of transaction body
   */
  _lowLevelEncodeTransactionBodyWithRLP(body, isSigned) {
    if (isSigned) {
      return SIGNED_TRANSACTION_RLP.encodeObject({
        ...body,
        signature: this.signature
      });
    }
    return UNSIGNED_TRANSACTION_RLP.encodeObject(body);
  }
  /**
   * Private utility function to encode a transaction.
   * @private
   *
   * @param isSigned If transaction is signed or not (needed to determine if encoding with SIGNED_TRANSACTION_RLP or UNSIGNED_TRANSACTION_RLP)
   * @returns Encoding of transaction
   */
  _encode(isSigned) {
    return this._lowLevelEncodeTransactionBodyWithRLP(
      {
        // Existing body (clauses, gasPrice, gasLimit, nonce, chainTag, blockRef, expiration, ... AND OPTIONALLY reserved field)
        ...this.body,
        /*
         * @note: this.body.clauses is already an array.
         * But TypeScript doesn't know that and for this reason we need to cast it.
         * Otherwise encodeObject will throw an error.
         */
        clauses: this.body.clauses,
        // New reserved field
        reserved: this._encodeReservedField()
      },
      isSigned
    );
  }
  /**
   * utility function to check transaction body validity.
   *
   * @param body Transaction body to check
   */
  static isValidBody(body) {
    return (
      // Chain tag
      body.chainTag !== void 0 && body.chainTag >= 0 && body.chainTag <= 255 && // Block reference
      body.blockRef !== void 0 && Hex.isValid0x(body.blockRef) && Buffer.from(body.blockRef.slice(2), "hex").length === BLOCK_REF_LENGTH && // Expiration
      body.expiration !== void 0 && // Clauses
      body.clauses !== void 0 && // Gas price coef
      body.gasPriceCoef !== void 0 && // Gas
      body.gas !== void 0 && // Depends on
      body.dependsOn !== void 0 && // Nonce
      body.nonce !== void 0
    );
  }
};

// src/transaction/handlers/sign.ts
var import_sdk_errors34 = require("@vechain/sdk-errors");
function sign3(transactionBody, signerPrivateKey) {
  if (!secp256k12.isValidPrivateKey(signerPrivateKey)) {
    throw new import_sdk_errors34.InvalidSecp256k1PrivateKey(
      `TransactionHandler.sign()`,
      "Invalid private key used to sign the transaction. Ensure it's a valid secp256k1 private key.",
      void 0
    );
  }
  const transactionToSign = new Transaction(transactionBody);
  if (transactionToSign.isDelegated)
    throw new import_sdk_errors34.InvalidTransactionField(
      `TransactionHandler.sign()`,
      "Transaction is delegated. Use signWithDelegator method instead.",
      { fieldName: "delegator", transactionBody }
    );
  const signature = secp256k12.sign(
    transactionToSign.getSignatureHash(),
    signerPrivateKey
  );
  return new Transaction(transactionBody, Buffer.from(signature));
}
function signWithDelegator(transactionBody, signerPrivateKey, delegatorPrivateKey) {
  if (!secp256k12.isValidPrivateKey(signerPrivateKey)) {
    throw new import_sdk_errors34.InvalidSecp256k1PrivateKey(
      `TransactionHandler.signWithDelegator()`,
      "Invalid signer private key used to sign the transaction. Ensure it's a valid secp256k1 private key.",
      void 0
    );
  }
  if (!secp256k12.isValidPrivateKey(delegatorPrivateKey)) {
    throw new import_sdk_errors34.InvalidSecp256k1PrivateKey(
      `TransactionHandler.signWithDelegator()`,
      "Invalid delegator private key used to sign the transaction. Ensure it's a valid secp256k1 private key.",
      void 0
    );
  }
  const transactionToSign = new Transaction(transactionBody);
  if (!transactionToSign.isDelegated)
    throw new import_sdk_errors34.NotDelegatedTransaction(
      "signWithDelegator()",
      "Transaction is not delegated. Use 'sign()' method instead.",
      void 0
    );
  const transactionHash = transactionToSign.getSignatureHash();
  const delegatedHash = transactionToSign.getSignatureHash(
    Address.ofPublicKey(
      Buffer.from(secp256k12.derivePublicKey(signerPrivateKey))
    ).toString()
  );
  const signature = Buffer.concat([
    secp256k12.sign(transactionHash, signerPrivateKey),
    secp256k12.sign(delegatedHash, delegatorPrivateKey)
  ]);
  return new Transaction(transactionBody, signature);
}

// src/transaction/handlers/decode.ts
var import_sdk_errors35 = require("@vechain/sdk-errors");
function decode3(rawTransaction, isSigned) {
  const decoder = isSigned ? SIGNED_TRANSACTION_RLP : UNSIGNED_TRANSACTION_RLP;
  const decodedRLPBody = decoder.decodeObject(
    rawTransaction
  );
  const bodyWithoutReservedField = {
    blockRef: decodedRLPBody.blockRef,
    chainTag: decodedRLPBody.chainTag,
    clauses: decodedRLPBody.clauses,
    dependsOn: decodedRLPBody.dependsOn,
    expiration: decodedRLPBody.expiration,
    gas: decodedRLPBody.gas,
    gasPriceCoef: decodedRLPBody.gasPriceCoef,
    nonce: decodedRLPBody.nonce
  };
  const correctTransactionBody = decodedRLPBody.reserved.length > 0 ? {
    ...bodyWithoutReservedField,
    reserved: _decodeReservedField(
      decodedRLPBody.reserved
    )
  } : bodyWithoutReservedField;
  return decodedRLPBody.signature !== void 0 ? new Transaction(
    correctTransactionBody,
    decodedRLPBody.signature
  ) : new Transaction(correctTransactionBody);
}
function _decodeReservedField(reserved) {
  if (reserved[reserved.length - 1].length === 0) {
    throw new import_sdk_errors35.InvalidTransactionField(
      "_decodeReservedField()",
      "Invalid reserved field. Fields in the reserved buffer must be properly trimmed.",
      { fieldName: "reserved", reserved }
    );
  }
  const featuresField = TRANSACTION_FEATURES_KIND.kind.buffer(reserved[0], TRANSACTION_FEATURES_KIND.name).decode();
  return reserved.length > 1 ? {
    features: featuresField,
    unused: reserved.slice(1)
  } : { features: featuresField };
}

// src/transaction/transaction-handler.ts
var TransactionHandler = {
  // Sign transaction
  sign: sign3,
  signWithDelegator,
  // Decode transaction
  decode: decode3
};

// src/utils/const/network.ts
var VECHAIN_MAINNET_CHAIN_TAG = 74;
var VECHAIN_TESTNET_CHAIN_TAG = 39;
var VECHAIN_SOLO_CHAIN_TAG = 246;
var ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
var VTHO_ADDRESS = "0x0000000000000000000000000000456e65726779";
var mainnetGenesisBlock = {
  number: 0,
  id: "0x00000000851caf3cfdb6e899cf5958bfb1ac3413d346d43539627e6be7ec1b4a",
  size: 170,
  parentID: "0xffffffff53616c757465202620526573706563742c20457468657265756d2100",
  timestamp: 1530316800,
  gasLimit: 1e7,
  beneficiary: "0x0000000000000000000000000000000000000000",
  gasUsed: 0,
  totalScore: 0,
  txsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  txsFeatures: 0,
  stateRoot: "0x09bfdf9e24dd5cd5b63f3c1b5d58b97ff02ca0490214a021ed7d99b93867839c",
  receiptsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  signer: "0x0000000000000000000000000000000000000000",
  isTrunk: true,
  transactions: []
};
var testnetGenesisBlock = {
  number: 0,
  id: "0x000000000b2bce3c70bc649a02749e8687721b09ed2e15997f466536b20bb127",
  size: 170,
  parentID: "0xffffffff00000000000000000000000000000000000000000000000000000000",
  timestamp: 1530014400,
  gasLimit: 1e7,
  beneficiary: "0x0000000000000000000000000000000000000000",
  gasUsed: 0,
  totalScore: 0,
  txsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  txsFeatures: 0,
  stateRoot: "0x4ec3af0acbad1ae467ad569337d2fe8576fe303928d35b8cdd91de47e9ac84bb",
  receiptsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  signer: "0x0000000000000000000000000000000000000000",
  isTrunk: true,
  transactions: []
};
var soloGenesisBlock = {
  number: 0,
  id: "0x00000000c05a20fbca2bf6ae3affba6af4a74b800b585bf7a4988aba7aea69f6",
  size: 170,
  parentID: "0xffffffff00000000000000000000000000000000000000000000000000000000",
  timestamp: 15264e5,
  gasLimit: 1e7,
  beneficiary: "0x0000000000000000000000000000000000000000",
  gasUsed: 0,
  totalScore: 0,
  txsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  txsFeatures: 0,
  stateRoot: "0x93de0ffb1f33bc0af053abc2a87c4af44594f5dcb1cb879dd823686a15d68550",
  receiptsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  signer: "0x0000000000000000000000000000000000000000",
  isTrunk: true,
  transactions: []
};
var MAINNET_NETWORK = {
  genesisBlock: mainnetGenesisBlock,
  chainTag: VECHAIN_MAINNET_CHAIN_TAG
};
var TESTNET_NETWORK = {
  genesisBlock: testnetGenesisBlock,
  chainTag: VECHAIN_TESTNET_CHAIN_TAG
};
var SOLO_NETWORK = {
  genesisBlock: soloGenesisBlock,
  chainTag: VECHAIN_SOLO_CHAIN_TAG
};
var networkInfo = {
  mainnet: MAINNET_NETWORK,
  testnet: TESTNET_NETWORK,
  solo: SOLO_NETWORK
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Account,
  Address,
  BLOCK_REF_LENGTH,
  Blake2b256,
  BloomFilter,
  ERC1155_ABI,
  ERC20_ABI,
  ERC721_ABI,
  HDNode,
  Hex,
  HexInt,
  HexUInt,
  INTEGER_REGEX,
  Keccak256,
  MAINNET_NETWORK,
  Mnemonic,
  NUMERIC_REGEX,
  PRIVATE_KEY_MAX_VALUE,
  Quantity,
  RLPBase,
  RLPProfiles,
  RLP_CODER,
  Revision,
  SIGNATURE_LENGTH,
  SIGNED_TRANSACTION_RLP,
  SOLO_NETWORK,
  Sha256,
  TESTNET_NETWORK,
  TRANSACTIONS_GAS_CONSTANTS,
  TRANSACTION_FEATURES_KIND,
  TRANSACTION_SIGNATURE_KIND,
  ThorId,
  Transaction,
  TransactionHandler,
  TransactionUtils,
  Txt,
  UNSIGNED_TRANSACTION_RLP,
  VET_DERIVATION_PATH,
  VIP180_ABI,
  VIP181_ABI,
  VIP210_ABI,
  VTHO_ADDRESS,
  X_PRIV_PREFIX,
  X_PUB_PREFIX,
  ZERO_ADDRESS,
  ZERO_BYTES,
  abi,
  addressUtils,
  assertCompactFixedHexBlobBuffer,
  assertFixedHexBlobKindBuffer,
  assertFixedHexBlobKindData,
  assertValidHexBlobKindBuffer,
  assertValidHexBlobKindData,
  assertValidNumericKindBuffer,
  blake2b256,
  certificate,
  clauseBuilder,
  coder,
  core,
  dataUtils,
  decodeBufferToHexWithLeadingZeros,
  decodeBufferToNumberOrHex,
  encodeBigIntToBuffer,
  encodeCompactFixedHexBlob,
  fragment,
  isDerivationPathValid,
  keccak256,
  keystore,
  mnemonic,
  networkInfo,
  revisionUtils,
  secp256k1,
  sha256,
  unitsUtils,
  validateNumericKindData,
  vechain_sdk_core_ethers
});
/*! Bundled license information:

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
