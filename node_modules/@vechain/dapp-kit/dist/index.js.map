{"version":3,"sources":["../src/dapp-kit.ts","../src/classes/wallet-manager.ts","../src/utils/logger.ts","../src/utils/convert-vendor-to-signer.ts","../src/utils/local-storage.ts","../src/constants/certificates.ts","../src/constants/genesis-blocks.ts","../src/constants/wallet-settings.ts","../src/constants/wallet-connect.ts","../src/utils/genesis.ts","../src/utils/create-wallet.ts","../src/classes/certificate-wallet.ts","../src/classes/wc-wallet.ts","../src/utils/create-wc-client.ts","../src/utils/create-wc-modal.ts","../src/utils/create-wc-signer.ts"],"sourcesContent":["import {\n    DriverNoVendor,\n    SimpleNet,\n} from '@vechain/connex-driver/dist/index.js';\nimport { Framework } from '@vechain/connex-framework';\nimport * as ThorDevkit from 'thor-devkit';\nimport { WalletManager } from './classes';\nimport { DAppKitLogger, normalizeGenesisBlock } from './utils';\nimport type { DAppKitOptions } from './types';\n\nconst cache: Record<string, DriverNoVendor | undefined> = {};\n\nconst createThorDriver = (\n    node: string,\n    genesis: Connex.Thor.Block,\n): DriverNoVendor => {\n    const key = ThorDevkit.blake2b256(\n        JSON.stringify({\n            node,\n            genesis,\n        }),\n    ).toString('hex');\n\n    let driver = cache[key];\n    if (!driver) {\n        driver = new DriverNoVendor(new SimpleNet(node), genesis);\n        cache[key] = driver;\n    }\n    return driver;\n};\n\nclass DAppKit {\n    public readonly thor: Connex.Thor;\n    public readonly vendor: Connex.Vendor;\n    public readonly wallet: WalletManager;\n\n    constructor(options: DAppKitOptions) {\n        if (options.logLevel) {\n            DAppKitLogger.configure(options.logLevel);\n            DAppKitLogger.debug('DAppKit', 'constructor', options);\n        }\n\n        const { nodeUrl, genesis } = options;\n\n        const genesisBlock = normalizeGenesisBlock(genesis);\n\n        const driver = createThorDriver(nodeUrl, genesisBlock);\n\n        const walletManager = new WalletManager(options);\n\n        driver.signTx = walletManager.signTx.bind(walletManager);\n        driver.signCert = walletManager.signCert.bind(walletManager);\n\n        const framework = new Framework(driver);\n\n        this.thor = framework.thor;\n        this.vendor = framework.vendor;\n        this.wallet = walletManager;\n    }\n}\n\nexport { DAppKit };\n","import * as ThorDevkit from 'thor-devkit';\nimport { proxy, subscribe } from 'valtio/vanilla';\nimport { subscribeKey } from 'valtio/vanilla/utils';\nimport type {\n    ConnectResponse,\n    ConnexWallet,\n    DAppKitOptions,\n    WalletManagerState,\n    WalletSource,\n} from '../types';\nimport { DAppKitLogger, Storage, createWallet } from '../utils';\nimport { DEFAULT_CONNECT_CERT_MESSAGE, WalletSources } from '../constants';\n\nclass WalletManager {\n    public readonly state: WalletManagerState;\n    private wallets: Record<string, ConnexWallet | undefined> = {};\n\n    constructor(private readonly options: DAppKitOptions) {\n        this.state = this.initState(options.usePersistence ?? false);\n        this.initPersistence(options.usePersistence ?? false);\n        DAppKitLogger.debug('WalletManager', 'constructor', this.state);\n\n        if (window.vechain?.isInAppBrowser === true) {\n            this.setSource('veworld');\n        } else if (options.useFirstDetectedSource) {\n            this.setFirstDetectedSource();\n        }\n    }\n\n    private get wallet(): ConnexWallet {\n        const source = this.state.source;\n\n        DAppKitLogger.debug(\n            'WalletManager',\n            'get wallet',\n            'current source',\n            source,\n        );\n\n        if (!source) {\n            throw new Error('No wallet has been selected');\n        }\n\n        let wallet = this.wallets[source];\n\n        if (!wallet) {\n            // If it's not a built-in wallet, we can't create it\n            if (!WalletSources.includes(source))\n                throw new Error(`No wallet found for: ${source}`);\n\n            DAppKitLogger.debug(\n                'WalletManager',\n                'get wallet',\n                'creating a new wallet',\n                source,\n            );\n\n            const opts = {\n                ...this.options,\n                source,\n                onDisconnected: () => this.disconnect(true),\n            };\n            wallet = createWallet(opts);\n\n            this.wallets[source] = wallet;\n        }\n\n        return wallet;\n    }\n\n    // this is needed for wallet connect connections when a connection certificate is required\n    signConnectionCertificate = async (): Promise<ConnectResponse> => {\n        const certificateMessage =\n            this.options.connectionCertificate?.message ||\n            DEFAULT_CONNECT_CERT_MESSAGE;\n        const certificateOptions =\n            this.options.connectionCertificate?.options || {};\n        const {\n            annex: { domain, signer, timestamp },\n            signature,\n        } = await this.wallet.signCert(certificateMessage, certificateOptions);\n\n        const connectionCertificate = {\n            ...certificateMessage,\n            signature,\n            signer,\n            domain,\n            timestamp,\n        };\n\n        try {\n            ThorDevkit.Certificate.verify(connectionCertificate);\n            this.state.address = signer;\n            this.state.connectionCertificate = connectionCertificate;\n            return {\n                account: signer,\n                verified: true,\n                connectionCertificate,\n            };\n        } catch (e) {\n            return {\n                account: signer,\n                verified: false,\n            };\n        } finally {\n            this.options.walletConnectOptions?.modal?.onConnectionCertificateSigned?.();\n        }\n    };\n\n    connect = (): Promise<ConnectResponse> =>\n        this.wallet\n            .connect()\n            .then((res) => {\n                if (\n                    this.state.source === 'wallet-connect' &&\n                    this.options.requireCertificate &&\n                    this.options.walletConnectOptions?.modal\n                        ?.askForConnectionCertificate\n                ) {\n                    this.options.walletConnectOptions.modal.askForConnectionCertificate();\n                } else {\n                    this.state.address = res.account;\n                    this.state.connectionCertificate =\n                        res.connectionCertificate ?? null;\n                }\n                return res;\n            })\n            .catch((e) => {\n                DAppKitLogger.error('WalletManager', 'connect', e);\n                throw e;\n            });\n\n    disconnect = (remote = false): void => {\n        if (!this.state.source) {\n            this.state.source = null;\n            this.state.address = null;\n            this.state.connectionCertificate = null;\n            return;\n        }\n\n        DAppKitLogger.debug(\n            'WalletManager',\n            'disconnect',\n            'current source',\n            this.state.source,\n        );\n\n        const wallet = this.wallets[this.state.source];\n\n        if (wallet && !remote && wallet.disconnect) {\n            const res = wallet.disconnect();\n\n            if (res instanceof Promise) {\n                res.catch((e) => {\n                    DAppKitLogger.error('WalletManager', 'disconnect', e);\n                });\n            }\n        }\n\n        this.state.source = null;\n        this.state.address = null;\n        this.state.connectionCertificate = null;\n    };\n\n    signTx = (\n        msg: Connex.Vendor.TxMessage,\n        options: Connex.Signer.TxOptions,\n    ): Promise<Connex.Vendor.TxResponse> =>\n        this.wallet\n            .signTx(msg, options)\n            .then((res) => {\n                // TODO: we should probably remove these assignment, because the user should be already logged in, and the address should be already defined, test it after e2e with transactions\n                this.state.address = res.signer;\n                return res;\n            })\n            .catch((e) => {\n                DAppKitLogger.error('WalletManager', 'signTx', e);\n                throw e;\n            });\n\n    signCert = (\n        msg: Connex.Vendor.CertMessage,\n        options: Connex.Signer.CertOptions,\n    ): Promise<Connex.Vendor.CertResponse> =>\n        this.wallet\n            .signCert(msg, options)\n            .then((res) => {\n                // TODO: we should probably remove these assignment, because the user should be already logged in, and the address should be already defined, test it after e2e with transactions\n                this.state.address = res.annex.signer;\n                return res;\n            })\n            .catch((e) => {\n                DAppKitLogger.error('WalletManager', 'signCert', e);\n                throw e;\n            });\n\n    setSource = (src: WalletSource): void => {\n        if (this.state.source === src) {\n            return;\n        }\n\n        if (this.state.source && this.state.source !== src) {\n            this.disconnect();\n        }\n\n        if (src === 'wallet-connect' && !this.options.walletConnectOptions) {\n            throw new Error('WalletConnect options are not provided');\n        }\n\n        if (src === 'veworld' && !window.vechain) {\n            throw new Error('VeWorld Extension is not installed');\n        }\n\n        if (src === 'sync' && !window.connex) {\n            throw new Error('User is not in a Sync wallet');\n        }\n\n        DAppKitLogger.debug('WalletManager', 'setSource', src);\n\n        this.disconnect();\n        this.state.source = src;\n    };\n\n    subscribe = (\n        listener: (state: WalletManagerState) => void,\n    ): (() => void) => {\n        return subscribe(this.state, () => {\n            listener(this.state);\n        });\n    };\n\n    subscribeToKey = <T extends keyof WalletManagerState>(\n        key: T,\n        listener: (value: WalletManagerState[T]) => void,\n    ): (() => void) => {\n        return subscribeKey(this.state, key, (value) => {\n            listener(value);\n        });\n    };\n\n    private initState = (usePersistent: boolean): WalletManagerState => {\n        const availableSources = this.getAvailableSources();\n\n        if (!usePersistent) {\n            return proxy({\n                source: null,\n                address: null,\n                availableSources,\n                connectionCertificate: null,\n            });\n        }\n\n        const address = Storage.getAccount();\n        const source = Storage.getSource();\n        const connectionCertificate = Storage.getConnectionCertificate();\n\n        return proxy({\n            source,\n            address,\n            availableSources,\n            connectionCertificate,\n        });\n    };\n\n    private initPersistence = (usePersistence: boolean): void => {\n        if (!usePersistence) {\n            return;\n        }\n        this.subscribeToKey('address', Storage.setAccount);\n        this.subscribeToKey('source', Storage.setSource);\n        this.subscribeToKey(\n            'connectionCertificate',\n            Storage.setConnectionCertificate,\n        );\n    };\n\n    private getAvailableSources = (): WalletSource[] => {\n        const wallets: WalletSource[] = [];\n\n        wallets.push('veworld');\n\n        if (this.options.walletConnectOptions) {\n            wallets.push('wallet-connect');\n        }\n\n        wallets.push('sync2');\n\n        if (window.connex) {\n            wallets.push('sync');\n        }\n\n        return wallets;\n    };\n\n    private setFirstDetectedSource = (): void => {\n        if (window.vechain) {\n            this.setSource('veworld');\n        } else if (this.options.walletConnectOptions) {\n            this.setSource('wallet-connect');\n        } else if (window.connex) {\n            this.setSource('sync');\n        } else {\n            this.setSource('sync2');\n        }\n    };\n}\n\nexport { WalletManager };\n","// eslint-disable-next-line eslint-comments/disable-enable-pair\n/* eslint-disable no-console */\n\nconst LogLevel = {\n    NONE: 0,\n    ERROR: 1,\n    WARN: 2,\n    INFO: 3,\n    DEBUG: 4,\n};\n\nlet currentLogLevel = LogLevel.NONE;\n\nexport type LogLevel = keyof typeof LogLevel;\n\nexport const DAppKitLogger = {\n    configure(level: LogLevel): void {\n        currentLogLevel = LogLevel[level];\n    },\n\n    debug(domain: string, context: string, ...args: unknown[]): void {\n        if (currentLogLevel >= LogLevel.DEBUG) {\n            console.log(`[${domain}] (${context})`, ...args);\n        }\n    },\n\n    info(domain: string, context: string, ...args: unknown[]): void {\n        if (currentLogLevel >= LogLevel.INFO) {\n            console.info(`[${domain}] (${context})`, ...args);\n        }\n    },\n\n    warn(domain: string, context: string, ...args: unknown[]): void {\n        if (currentLogLevel >= LogLevel.WARN) {\n            console.warn(`[${domain}] (${context})`, ...args);\n        }\n    },\n\n    error(domain: string, context: string, ...args: unknown[]): void {\n        if (currentLogLevel >= LogLevel.ERROR) {\n            console.error(`[${domain}] (${context})`, ...args);\n        }\n    },\n};\n","import { DAppKitLogger } from './logger';\n\nexport const convertVendorToSigner = (vendor: Connex.Vendor): Connex.Signer => {\n    return {\n        signTx: (msg, options): Promise<Connex.Vendor.TxResponse> => {\n            const service = vendor.sign('tx', msg);\n\n            if (options.gas) {\n                service.gas(options.gas);\n            }\n\n            if (options.signer) {\n                service.signer(options.signer);\n            }\n\n            if (options.dependsOn) {\n                service.dependsOn(options.dependsOn);\n            }\n\n            if (options.link) {\n                service.link(options.link);\n            }\n\n            if (options.comment) {\n                service.comment(options.comment);\n            }\n\n            if (options.delegator) {\n                service.delegate(\n                    options.delegator.url,\n                    options.delegator.signer,\n                );\n            }\n\n            if (options.onAccepted) {\n                service.accepted(options.onAccepted);\n            }\n\n            DAppKitLogger.debug('vendor', 'signTx', {\n                messages: msg.length,\n                options,\n            });\n\n            return service.request();\n        },\n\n        signCert: (msg, options): Promise<Connex.Vendor.CertResponse> => {\n            const service = vendor.sign('cert', msg);\n\n            if (options.signer) {\n                service.signer(options.signer);\n            }\n\n            if (options.link) {\n                service.link(options.link);\n            }\n\n            if (options.onAccepted) {\n                service.accepted(options.onAccepted);\n            }\n\n            DAppKitLogger.debug('vendor', 'signCert', {\n                message: msg,\n                options,\n            });\n\n            return service.request();\n        },\n    };\n};\n","import * as ThorDevkit from 'thor-devkit';\nimport type { WalletSource } from '../types';\nimport { DAppKitLogger } from './logger';\n\nconst STORAGE_PREFIX = 'dappkit@vechain';\nconst WALLET_SOURCE_KEY = `${STORAGE_PREFIX}/source`;\nconst ACCOUNT_KEY = `${STORAGE_PREFIX}/account`;\nconst CERTIFICATE_KEY = `${STORAGE_PREFIX}/connectionCertificate`;\n\nconst setSource = (source: WalletSource | null): void => {\n    DAppKitLogger.debug('LocalStorage', 'setSource', source);\n\n    if (!source) {\n        localStorage.removeItem(WALLET_SOURCE_KEY);\n    } else {\n        localStorage.setItem(WALLET_SOURCE_KEY, source);\n    }\n};\n\nconst setAccount = (account: string | null): void => {\n    DAppKitLogger.debug('LocalStorage', 'setAccount', account);\n    if (!account) {\n        localStorage.removeItem(ACCOUNT_KEY);\n    } else {\n        localStorage.setItem(ACCOUNT_KEY, account);\n    }\n};\n\nconst setConnectionCertificate = (\n    certificate: ThorDevkit.Certificate | null,\n): void => {\n    DAppKitLogger.debug(\n        'LocalStorage',\n        'setConnectionCertificate',\n        certificate,\n    );\n    if (!certificate) {\n        localStorage.removeItem(CERTIFICATE_KEY);\n    } else {\n        localStorage.setItem(CERTIFICATE_KEY, JSON.stringify(certificate));\n    }\n};\n\nconst getSource = (): WalletSource | null => {\n    const source = localStorage.getItem(WALLET_SOURCE_KEY);\n\n    if (!source) {\n        return null;\n    }\n\n    return source as WalletSource;\n};\n\nconst getAccount = (): string | null => {\n    const account = localStorage.getItem(ACCOUNT_KEY);\n\n    if (!account) {\n        return null;\n    }\n\n    return account;\n};\n\nconst getConnectionCertificate = (): ThorDevkit.Certificate | null => {\n    const connectionCertificate = localStorage.getItem(CERTIFICATE_KEY);\n\n    if (!connectionCertificate) {\n        return null;\n    }\n\n    return JSON.parse(connectionCertificate) as ThorDevkit.Certificate;\n};\n\nexport const Storage = {\n    setAccount,\n    setSource,\n    setConnectionCertificate,\n    getAccount,\n    getSource,\n    getConnectionCertificate,\n};\n","const DEFAULT_CONNECT_CERT_MESSAGE: Connex.Vendor.CertMessage = {\n    purpose: 'identification',\n    payload: {\n        type: 'text',\n        content: `The following dApp would like to see your public address: ${\n            typeof window !== 'undefined' ? window.origin : ''\n        }`,\n    },\n};\n\nexport { DEFAULT_CONNECT_CERT_MESSAGE };\n","type NetworkType = 'main' | 'test';\n\nexport const genesisBlocks: Record<NetworkType, Connex.Thor.Block> = {\n    main: {\n        number: 0,\n        id: '0x00000000851caf3cfdb6e899cf5958bfb1ac3413d346d43539627e6be7ec1b4a',\n        size: 170,\n        parentID:\n            '0xffffffff53616c757465202620526573706563742c20457468657265756d2100',\n        timestamp: 1530316800,\n        gasLimit: 10000000,\n        beneficiary: '0x0000000000000000000000000000000000000000',\n        gasUsed: 0,\n        totalScore: 0,\n        txsRoot:\n            '0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0',\n        txsFeatures: 0,\n        stateRoot:\n            '0x09bfdf9e24dd5cd5b63f3c1b5d58b97ff02ca0490214a021ed7d99b93867839c',\n        receiptsRoot:\n            '0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0',\n        signer: '0x0000000000000000000000000000000000000000',\n        isTrunk: true,\n        transactions: [],\n    },\n    test: {\n        number: 0,\n        id: '0x000000000b2bce3c70bc649a02749e8687721b09ed2e15997f466536b20bb127',\n        size: 170,\n        parentID:\n            '0xffffffff00000000000000000000000000000000000000000000000000000000',\n        timestamp: 1530014400,\n        gasLimit: 10000000,\n        beneficiary: '0x0000000000000000000000000000000000000000',\n        gasUsed: 0,\n        totalScore: 0,\n        txsRoot:\n            '0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0',\n        txsFeatures: 0,\n        stateRoot:\n            '0x4ec3af0acbad1ae467ad569337d2fe8576fe303928d35b8cdd91de47e9ac84bb',\n        receiptsRoot:\n            '0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0',\n        signer: '0x0000000000000000000000000000000000000000',\n        isTrunk: true,\n        transactions: [],\n    },\n};\n","/**\n * Wallet types\n */\n\nimport type { WalletConfig, WalletSource } from '../types';\n\nconst DEFAULT_CONFIG: WalletConfig = {\n    requiresCertificate: true,\n};\n\nconst WalletMapping: Record<WalletSource, WalletConfig> = {\n    'wallet-connect': {\n        requiresCertificate: false,\n    },\n    veworld: DEFAULT_CONFIG,\n    sync2: DEFAULT_CONFIG,\n    sync: DEFAULT_CONFIG,\n};\n\nconst WalletSources = Object.keys(WalletMapping) as WalletSource[];\n\nObject.freeze(WalletMapping);\nObject.freeze(WalletSources);\n\nexport { WalletMapping, WalletSources };\n","/**\n * The methods supported by the WalletConnect integration\n * @param RequestTransaction - Request the wallet to send a transaction\n * @param SignCertificate - Request the wallet to sign a certificate\n */\nexport enum DefaultMethods {\n    RequestTransaction = 'thor_sendTransaction',\n    SignCertificate = 'thor_signCertificate',\n}\n","import { genesisBlocks } from '../constants';\nimport type { Genesis } from '../types';\n\nconst normalizeGenesisId = (genesis?: Genesis): string => {\n    if (!genesis) return genesisBlocks.main.id;\n\n    if (genesis === 'main' || genesis === 'test')\n        return genesisBlocks[genesis].id;\n\n    return genesis.id;\n};\n\nconst normalizeGenesisBlock = (genesis?: Genesis): Connex.Thor.Block => {\n    if (!genesis) return genesisBlocks.main;\n\n    if (genesis === 'main' || genesis === 'test') return genesisBlocks[genesis];\n\n    return genesis;\n};\n\nexport { normalizeGenesisId, normalizeGenesisBlock };\n","import * as ConnexLib from '@vechain/connex';\nimport type {\n    ConnexWallet,\n    DAppKitOptions,\n    WalletSource,\n    WCClient,\n    WCModal,\n} from '../types';\nimport { CertificateBasedWallet } from '../classes/certificate-wallet';\nimport { WCWallet } from '../classes/wc-wallet';\nimport { createWcClient } from './create-wc-client';\nimport { createWcModal } from './create-wc-modal';\nimport { createWcSigner } from './create-wc-signer';\nimport { convertVendorToSigner } from './convert-vendor-to-signer';\nimport { normalizeGenesisId } from './genesis';\nimport { DAppKitLogger } from './logger';\n\ntype ICreateWallet = DAppKitOptions & {\n    source: WalletSource;\n    onDisconnected: () => void;\n};\n\nexport const createWallet = ({\n    source,\n    genesis,\n    walletConnectOptions,\n    onDisconnected,\n    connectionCertificate,\n}: ICreateWallet): ConnexWallet => {\n    const genesisId = normalizeGenesisId(genesis);\n\n    DAppKitLogger.debug('createWallet', source);\n\n    switch (source) {\n        case 'sync': {\n            if (!window.connex) {\n                throw new Error('User is not in a Sync wallet');\n            }\n\n            const vendor = new ConnexLib.Connex.Vendor(genesisId, 'sync');\n\n            return new CertificateBasedWallet(\n                convertVendorToSigner(vendor),\n                connectionCertificate,\n            );\n        }\n        case 'sync2': {\n            const vendor = new ConnexLib.Connex.Vendor(genesisId, 'sync2');\n\n            return new CertificateBasedWallet(\n                convertVendorToSigner(vendor),\n                connectionCertificate,\n            );\n        }\n        case 'veworld': {\n            if (!window.vechain) {\n                throw new Error('VeWorld Extension is not installed');\n            }\n\n            const signer = window.vechain.newConnexSigner(genesisId);\n\n            return new CertificateBasedWallet(signer, connectionCertificate);\n        }\n        case 'wallet-connect': {\n            if (!walletConnectOptions) {\n                throw new Error('WalletConnect options are not provided');\n            }\n\n            const { projectId, metadata, modal } = walletConnectOptions;\n\n            const wcClient: WCClient = createWcClient({\n                projectId,\n                metadata,\n            });\n\n            const web3Modal: WCModal = modal ?? createWcModal(projectId);\n\n            const wallet = createWcSigner({\n                genesisId,\n                wcClient,\n                web3Modal,\n                onDisconnected,\n            });\n\n            return new WCWallet(wallet);\n        }\n    }\n};\n","import * as ThorDevkit from 'thor-devkit';\nimport type { BaseWallet, ConnectResponse, ConnexWallet } from '../types';\nimport { DEFAULT_CONNECT_CERT_MESSAGE } from '../constants';\n\n/**\n * A `ConnexWallet` for wallet's that use a certificate connection\n */\nclass CertificateBasedWallet implements ConnexWallet {\n    constructor(\n        private readonly wallet: BaseWallet,\n        private readonly connectionCertificateData?: {\n            message?: Connex.Vendor.CertMessage;\n            options?: Connex.Signer.CertOptions;\n        },\n    ) {}\n\n    connect = async (): Promise<ConnectResponse> => {\n        const certificateMessage =\n            this.connectionCertificateData?.message ||\n            DEFAULT_CONNECT_CERT_MESSAGE;\n        const certificateOptions =\n            this.connectionCertificateData?.options || {};\n        const {\n            annex: { domain, signer, timestamp },\n            signature,\n        } = await this.signCert(certificateMessage, certificateOptions);\n\n        const connectionCertificate = {\n            ...certificateMessage,\n            signature,\n            signer,\n            domain,\n            timestamp,\n        };\n\n        try {\n            ThorDevkit.Certificate.verify(connectionCertificate);\n\n            return {\n                account: signer,\n                verified: true,\n                connectionCertificate,\n            };\n        } catch (e) {\n            return {\n                account: signer,\n                verified: false,\n            };\n        }\n    };\n\n    signCert = (\n        msg: Connex.Vendor.CertMessage,\n        options: Connex.Signer.CertOptions,\n    ): Promise<Connex.Vendor.CertResponse> =>\n        this.wallet.signCert(msg, options);\n\n    signTx = (\n        msg: Connex.Vendor.TxMessage,\n        options: Connex.Signer.TxOptions,\n    ): Promise<Connex.Vendor.TxResponse> => this.wallet.signTx(msg, options);\n\n    disconnect = async (): Promise<void> => this.wallet.disconnect?.();\n}\n\nexport { CertificateBasedWallet };\n","import type { ConnectResponse, ConnexWallet, WCSigner } from '../types';\n\nclass WCWallet implements ConnexWallet {\n    constructor(private readonly signer: WCSigner) {}\n\n    connect = async (): Promise<ConnectResponse> => {\n        const account = await this.signer.connect();\n\n        return {\n            account,\n            verified: false,\n        };\n    };\n\n    signCert = (\n        msg: Connex.Vendor.CertMessage,\n        options: Connex.Signer.CertOptions,\n    ): Promise<Connex.Vendor.CertResponse> =>\n        this.signer.signCert(msg, options);\n\n    signTx = (\n        msg: Connex.Vendor.TxMessage,\n        options: Connex.Signer.TxOptions,\n    ): Promise<Connex.Vendor.TxResponse> => this.signer.signTx(msg, options);\n\n    disconnect = (): Promise<void> => this.signer.disconnect();\n}\n\nexport { WCWallet };\n","import { SignClient } from '@walletconnect/sign-client';\nimport type {\n    ResolvedSignClient,\n    WalletConnectOptions,\n    WCClient,\n} from '../types/wc-types';\n\nconst _cachedClients: Record<string, WCClient | undefined> = {};\n\n/**\n * Create a new wallet connect sign client. Clients are cached by project id.\n * @param projectId - wallet connect dApp project id\n * @param metadata - dApp metadata\n */\nexport const createWcClient = ({\n    projectId,\n    metadata,\n}: WalletConnectOptions): WCClient => {\n    const cachedClient = _cachedClients[projectId];\n\n    if (cachedClient) {\n        return cachedClient;\n    }\n\n    const _signClient = SignClient.init({\n        projectId,\n        metadata,\n    });\n\n    const client: WCClient = {\n        get: async (): Promise<ResolvedSignClient> => {\n            try {\n                return await _signClient;\n            } catch (e) {\n                throw new Error(\n                    `Failed to initialise the wallet connect sign client`,\n                );\n            }\n        },\n    };\n\n    _cachedClients[projectId] = client;\n\n    return client;\n};\n","import { WalletConnectModal } from '@walletconnect/modal';\nimport type { WCModal } from '../types/wc-types';\n\nconst _cachedModals: Record<string, WalletConnectModal | undefined> = {};\n\nconst genesisIds = [\n    '0x00000000851caf3cfdb6e899cf5958bfb1ac3413d346d43539627e6be7ec1b4a',\n    '0x000000000b2bce3c70bc649a02749e8687721b09ed2e15997f466536b20bb127',\n];\n\nconst chains = genesisIds.map((id) => {\n    return `vechain:${id.slice(-32)}`;\n});\n\n/**\n * Creates a new WalletConnectModal instance\n * @param projectId - Your WalletConnect project ID\n */\nexport const createWcModal = (projectId: string): WCModal => {\n    const cached = _cachedModals[projectId];\n\n    if (cached) {\n        return cached;\n    }\n\n    const modal = new WalletConnectModal({\n        projectId,\n        explorerRecommendedWalletIds: 'NONE',\n        mobileWallets: [\n            {\n                name: 'VeWorld',\n                id: 'veworld-mobile',\n                links: {\n                    native: 'veworld://org.vechain.veworld.app/',\n                    universal: 'https://veworld.com',\n                },\n            },\n        ],\n        chains,\n        themeVariables: {\n            '--wcm-z-index': '99999999',\n        },\n        walletImages: {\n            'veworld-mobile': 'https://www.veworld.net/assets/logo/logo.svg',\n        },\n    });\n\n    _cachedModals[projectId] = modal;\n\n    return modal;\n};\n","import type {\n    EngineTypes,\n    ProposalTypes,\n    SessionTypes,\n} from '@walletconnect/types';\nimport { getSdkError } from '@walletconnect/utils';\nimport type { SignClient } from '@walletconnect/sign-client/dist/types/client';\nimport type { WCSigner, WCSignerOptions } from '../types/wc-types';\nimport { DefaultMethods } from '../constants/wallet-connect';\nimport { DAppKitLogger } from './logger';\n\ninterface SessionAccount {\n    networkIdentifier: string;\n    address: string;\n    topic: string;\n}\n\n/**\n * Creates a new WalletConnect signer\n * @param options - The signer options. See {@link WCSignerOptions}\n * @returns A new {@link WCSigner}\n */\nexport const createWcSigner = ({\n    genesisId,\n    wcClient,\n    web3Modal,\n    onDisconnected,\n}: WCSignerOptions): WCSigner => {\n    const chainId = `vechain:${genesisId.slice(-32)}`;\n    let session: SessionTypes.Struct | undefined;\n\n    wcClient\n        .get()\n        .then((clientInstance) => {\n            listenToEvents(clientInstance);\n            restoreSession(clientInstance);\n        })\n        .catch(() => {\n            throw new Error(`Failed to get the wallet connect sign client`);\n        });\n\n    // listen for session updates\n    const listenToEvents = (_client: SignClient): void => {\n        _client.on('session_update', ({ topic, params }): void => {\n            DAppKitLogger.debug('wallet connect signer', 'session_update', {\n                topic,\n                params,\n            });\n            const { namespaces } = params;\n            const _session = _client.session.get(topic);\n            session = { ..._session, namespaces };\n        });\n\n        _client.on('session_delete', () => {\n            onDisconnected();\n            disconnect().catch(() => {\n                throw new Error('Failed to disconnect');\n            });\n        });\n    };\n\n    // restore a session if undefined\n    const restoreSession = (_client: SignClient): void => {\n        if (typeof session !== 'undefined') return;\n\n        DAppKitLogger.debug('wallet connect signer', 'restore session');\n        const sessionKeys = _client.session.keys;\n\n        for (const key of sessionKeys) {\n            const _session = _client.session.get(key);\n            const accounts = _session.namespaces.vechain.accounts;\n\n            for (const acc of accounts) {\n                if (acc.split(':')[1] === genesisId.slice(-32)) {\n                    session = _session;\n                    return;\n                }\n            }\n        }\n    };\n\n    /**\n     * Validates the requested account and network against a request\n     * @param requestedAddress - The optional requested account address\n     */\n    const validateSession = (\n        requestedAddress?: string,\n    ): SessionAccount | undefined => {\n        if (!session) return;\n        DAppKitLogger.debug('wallet connect signer', 'validate session');\n\n        const firstAccount = session.namespaces.vechain.accounts[0];\n\n        const address = firstAccount.split(':')[2];\n        const networkIdentifier = firstAccount.split(':')[1];\n\n        // Return undefined if the network identifier doesn't match\n        if (networkIdentifier !== genesisId.slice(-32)) return;\n\n        // Return undefined if the address doesn't match\n        if (\n            requestedAddress &&\n            requestedAddress.toLowerCase() !== address.toLowerCase()\n        )\n            return;\n\n        return {\n            address,\n            networkIdentifier,\n            topic: session.topic,\n        };\n    };\n\n    const connect = async (): Promise<SessionTypes.Struct> => {\n        DAppKitLogger.debug('wallet connect signer', 'connect');\n        const signClient = await wcClient.get();\n\n        const namespace: ProposalTypes.RequiredNamespace = {\n            methods: Object.values(DefaultMethods),\n            chains: [chainId],\n            events: [],\n        };\n\n        try {\n            const requiredNamespaces: Record<\n                string,\n                ProposalTypes.RequiredNamespace\n            > = {\n                vechain: namespace,\n            };\n\n            const res = await signClient.connect({\n                requiredNamespaces,\n            });\n\n            if (res.uri) {\n                await web3Modal.openModal({ uri: res.uri });\n            }\n\n            return await new Promise((resolve, reject) => {\n                const endSubscription = web3Modal.subscribeModal((ev) => {\n                    if (!ev.open) {\n                        reject(new Error('User closed modal while connecting'));\n                        endSubscription();\n                    }\n                });\n\n                res.approval()\n                    .then((newSession) => {\n                        session = newSession;\n                        endSubscription();\n                        resolve(newSession);\n                    })\n                    .catch((e) => {\n                        web3Modal.closeModal();\n                        reject(e);\n                    });\n            });\n        } catch (e) {\n            throw new Error(`wc connect failed`);\n        }\n    };\n\n    const getSessionTopic = async (\n        requestedAccount?: string,\n    ): Promise<string> => {\n        const validation = validateSession(requestedAccount);\n\n        if (validation) return validation.topic;\n\n        const newSession = await connect();\n\n        return newSession.topic;\n    };\n\n    const makeRequest = async <T>(\n        params: EngineTypes.RequestParams['request'],\n        signer?: string,\n    ): Promise<T> => {\n        const sessionTopic = await getSessionTopic(signer);\n\n        const signClient = await wcClient.get();\n\n        return signClient.request({\n            topic: sessionTopic,\n            chainId,\n            request: params,\n        });\n    };\n\n    const signTx = async (\n        message: Connex.Vendor.TxMessage,\n        options: Connex.Signer.TxOptions,\n    ): Promise<Connex.Vendor.TxResponse> => {\n        return makeRequest<Connex.Vendor.TxResponse>({\n            method: DefaultMethods.RequestTransaction,\n            params: [{ message, options }],\n        });\n    };\n\n    const signCert = async (\n        message: Connex.Vendor.CertMessage,\n        options: Connex.Signer.CertOptions,\n    ): Promise<Connex.Vendor.CertResponse> => {\n        return makeRequest<Connex.Vendor.CertResponse>({\n            method: DefaultMethods.SignCertificate,\n            params: [{ message, options }],\n        });\n    };\n\n    const disconnect = async (): Promise<void> => {\n        if (!session) return;\n\n        const topic = session.topic;\n        session = undefined;\n\n        const signClient = await wcClient.get();\n\n        try {\n            await signClient.disconnect({\n                topic,\n                reason: getSdkError('USER_DISCONNECTED'),\n            });\n        } catch (e) {\n            throw new Error(`SignClient.disconnect failed`);\n        }\n    };\n\n    const connectAccount = async (): Promise<string> => {\n        if (!session) {\n            session = await connect();\n        }\n\n        const vechainNamespace = session.namespaces.vechain;\n\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!vechainNamespace) {\n            throw new Error(\n                'Failed to create a vechain session with wallet connect',\n            );\n        }\n\n        const firstAccount = vechainNamespace.accounts[0];\n\n        try {\n            return firstAccount.split(':')[2];\n        } catch (e) {\n            throw new Error('Failed to get account from session');\n        }\n    };\n\n    return {\n        signTx,\n        signCert,\n        disconnect,\n        genesisId,\n        connect: connectAccount,\n    };\n};\n"],"mappings":"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","names":["DriverNoVendor","SimpleNet","Framework","ThorDevkit","ThorDevkit","proxy","subscribe","subscribeKey","LogLevel","currentLogLevel","DAppKitLogger","level","domain","context","args","convertVendorToSigner","vendor","msg","options","service","DAppKitLogger","STORAGE_PREFIX","WALLET_SOURCE_KEY","ACCOUNT_KEY","CERTIFICATE_KEY","setSource","source","DAppKitLogger","setAccount","account","setConnectionCertificate","certificate","getSource","getAccount","getConnectionCertificate","connectionCertificate","Storage","DEFAULT_CONNECT_CERT_MESSAGE","genesisBlocks","DEFAULT_CONFIG","WalletMapping","WalletSources","DefaultMethods","normalizeGenesisId","genesis","genesisBlocks","normalizeGenesisBlock","ConnexLib","ThorDevkit","CertificateBasedWallet","wallet","connectionCertificateData","certificateMessage","DEFAULT_CONNECT_CERT_MESSAGE","certificateOptions","domain","signer","timestamp","signature","connectionCertificate","msg","options","WCWallet","signer","msg","options","SignClient","_cachedClients","createWcClient","projectId","metadata","cachedClient","_signClient","client","WalletConnectModal","_cachedModals","genesisIds","chains","id","createWcModal","projectId","cached","modal","getSdkError","createWcSigner","genesisId","wcClient","web3Modal","onDisconnected","chainId","session","clientInstance","listenToEvents","restoreSession","_client","topic","params","DAppKitLogger","namespaces","disconnect","sessionKeys","key","_session","accounts","acc","validateSession","requestedAddress","firstAccount","address","networkIdentifier","connect","signClient","namespace","DefaultMethods","requiredNamespaces","res","resolve","reject","endSubscription","ev","newSession","e","getSessionTopic","requestedAccount","validation","makeRequest","signer","sessionTopic","signTx","message","options","signCert","getSdkError","vechainNamespace","createWallet","source","genesis","walletConnectOptions","onDisconnected","connectionCertificate","genesisId","normalizeGenesisId","DAppKitLogger","vendor","CertificateBasedWallet","convertVendorToSigner","signer","projectId","metadata","modal","wcClient","createWcClient","web3Modal","createWcModal","wallet","createWcSigner","WCWallet","WalletManager","options","certificateMessage","DEFAULT_CONNECT_CERT_MESSAGE","certificateOptions","domain","signer","timestamp","signature","connectionCertificate","res","DAppKitLogger","remote","wallet","e","msg","src","listener","subscribe","key","subscribeKey","value","usePersistent","availableSources","proxy","address","Storage","source","usePersistence","wallets","WalletSources","opts","createWallet","cache","createThorDriver","node","genesis","key","driver","DriverNoVendor","SimpleNet","DAppKit","options","DAppKitLogger","nodeUrl","genesisBlock","normalizeGenesisBlock","walletManager","WalletManager","framework","Framework"]}