import * as ThorDevkit from 'thor-devkit';
import { WalletConnectOptions as WalletConnectOptions$1 } from '@vechain/dapp-kit';
import { SignClientTypes } from '@walletconnect/types';
import { SignClient } from '@walletconnect/sign-client';

declare const LogLevel: {
    NONE: number;
    ERROR: number;
    WARN: number;
    INFO: number;
    DEBUG: number;
};
type LogLevel = keyof typeof LogLevel;
declare const DAppKitLogger: {
    configure(level: LogLevel): void;
    debug(domain: string, context: string, ...args: unknown[]): void;
    info(domain: string, context: string, ...args: unknown[]): void;
    warn(domain: string, context: string, ...args: unknown[]): void;
    error(domain: string, context: string, ...args: unknown[]): void;
};

declare global {
    interface Window {
        vechain?: {
            newConnexSigner: (genesisId: string) => Connex.Signer;
            isInAppBrowser?: boolean;
        };
        connex?: unknown;
    }
}

type WalletSource = 'wallet-connect' | 'veworld' | 'sync2' | 'sync';

interface WalletConfig {
    requiresCertificate: boolean;
}

type Genesis = 'main' | 'test' | Connex.Thor.Block;

/**
 * Options for the DAppKit class
 * @param nodeUrl - The URL of the VeChain node to connect to
 * @param genesis - Optional. The genesis block of the VeChain network you want to connect to. Eg, 'main', 'test', or a Connex.Thor.Block object
 * @param onDisconnected - A callback that will be called when the session is disconnected
 * @param walletConnectOptions - Optional. Options for the WalletConnect integration
 * @param usePersistence - Optional. Whether to persist the wallet source/ account
 * @param useFirstDetectedSource - Optional. Whether to use the first detected wallet source. Defaults to false
 * @param logLevel - Optional. The log level to use for the DAppKitUI logger
 */
interface DAppKitOptions {
    nodeUrl: string;
    genesis?: Genesis;
    walletConnectOptions?: WalletConnectOptions$1;
    usePersistence?: boolean;
    useFirstDetectedSource?: boolean;
    logLevel?: LogLevel;
    requireCertificate?: boolean;
    connectionCertificate?: {
        message?: Connex.Vendor.CertMessage;
        options?: Connex.Signer.CertOptions;
    };
}

type BaseWallet = Connex.Signer & {
    disconnect?: () => Promise<void> | void;
};

/**
 * Modifies the Connex.Signer interface to include a disconnect method
 */
type ConnexWallet = BaseWallet & {
    connect: () => Promise<ConnectResponse>;
};

interface ConnectResponse {
    account: string;
    verified: boolean;
    connectionCertificate?: ThorDevkit.Certificate;
}

interface WalletManagerState {
    source: WalletSource | null;
    address: string | null;
    availableSources: WalletSource[];
    connectionCertificate: ThorDevkit.Certificate | null;
}

type ResolvedSignClient = Awaited<ReturnType<typeof SignClient.init>>;

/**
 * WCSigner is a {@link Connex.Signer} with an additional disconnect method
 *
 */
type WCSigner = Connex.Signer & {
    /**
     * Disconnects and cleans up the WalletConnect session
     */
    disconnect: () => Promise<void>;

    /**
     * The genesis ID of the current signer
     */
    genesisId: string;

    /**
     * Connects to the Wallet and return the account address
     */
    connect: () => Promise<string>;
};

interface WCClient {
    /**
     * Gets the initialized WalletConnect SignClient
     */
    get: () => Promise<ResolvedSignClient>;
}

/**
 * WCModal is a modal that can be used to display a WalletConnect QR code/ URI
 * @param openModal - A function to open the modal
 * @param closeModal - A function to close the modal
 * @param subscribeModal - A function to subscribe to modal state changes
 */
interface WCModal {
    openModal: (options: OpenOptions) => Promise<void>;
    closeModal: () => void;
    subscribeModal: (
        callback: (newState: SubscribeModalState) => void,
    ) => () => void;
    askForConnectionCertificate?: () => void;
    onConnectionCertificateSigned?: () => void;
}

/**
 * Options for the createWcClient function
 * @param projectId - Your WalletConnect project ID
 * @param relayUrl - The URL of your WalletConnect relay server
 * @param metadata - The metadata of your WalletConnect dApp
 * @param logger - The logger or log level to use
 * @param modal - {@link WCModal} can be used to provide a custom modal
 */
interface WalletConnectOptions {
    projectId: string;
    metadata: SignClientTypes.Options['metadata'];
    modal?: WCModal;
}

/**
 * Options for the {@link WCModal}
 * @param open - Whether the modal is open
 */
interface SubscribeModalState {
    open: boolean;
}

/**
 * Options for opening the {@link WCModal}
 * @param uri - The WalletConnect URI to display / open
 */
interface OpenOptions {
    uri: string;
}

/**
 * Options for the {@link WCSigner}
 * @param wcClient - See {@link WCClient}
 * @param web3Modal - See {@link WCModal}
 * @param onDisconnected - (optional) A callback that will be called when the session is disconnected
 * @param genesisId - The genesis ID of the VeChain network you want to connect to
 */
interface WCSignerOptions {
    wcClient: WCClient;
    web3Modal: WCModal;
    onDisconnected: () => void;
    genesisId: string;
}

declare class WalletManager {
    private readonly options;
    readonly state: WalletManagerState;
    private wallets;
    constructor(options: DAppKitOptions);
    private get wallet();
    signConnectionCertificate: () => Promise<ConnectResponse>;
    connect: () => Promise<ConnectResponse>;
    disconnect: (remote?: boolean) => void;
    signTx: (msg: Connex.Vendor.TxMessage, options: Connex.Signer.TxOptions) => Promise<Connex.Vendor.TxResponse>;
    signCert: (msg: Connex.Vendor.CertMessage, options: Connex.Signer.CertOptions) => Promise<Connex.Vendor.CertResponse>;
    setSource: (src: WalletSource) => void;
    subscribe: (listener: (state: WalletManagerState) => void) => (() => void);
    subscribeToKey: <T extends keyof WalletManagerState>(key: T, listener: (value: WalletManagerState[T]) => void) => (() => void);
    private initState;
    private initPersistence;
    private getAvailableSources;
    private setFirstDetectedSource;
}

/**
 * A `ConnexWallet` for wallet's that use a certificate connection
 */
declare class CertificateBasedWallet implements ConnexWallet {
    private readonly wallet;
    private readonly connectionCertificateData?;
    constructor(wallet: BaseWallet, connectionCertificateData?: {
        message?: Connex.Vendor.CertMessage | undefined;
        options?: Connex.Signer.CertOptions | undefined;
    } | undefined);
    connect: () => Promise<ConnectResponse>;
    signCert: (msg: Connex.Vendor.CertMessage, options: Connex.Signer.CertOptions) => Promise<Connex.Vendor.CertResponse>;
    signTx: (msg: Connex.Vendor.TxMessage, options: Connex.Signer.TxOptions) => Promise<Connex.Vendor.TxResponse>;
    disconnect: () => Promise<void>;
}

declare class WCWallet implements ConnexWallet {
    private readonly signer;
    constructor(signer: WCSigner);
    connect: () => Promise<ConnectResponse>;
    signCert: (msg: Connex.Vendor.CertMessage, options: Connex.Signer.CertOptions) => Promise<Connex.Vendor.CertResponse>;
    signTx: (msg: Connex.Vendor.TxMessage, options: Connex.Signer.TxOptions) => Promise<Connex.Vendor.TxResponse>;
    disconnect: () => Promise<void>;
}

declare class DAppKit {
    readonly thor: Connex.Thor;
    readonly vendor: Connex.Vendor;
    readonly wallet: WalletManager;
    constructor(options: DAppKitOptions);
}

declare const DEFAULT_CONNECT_CERT_MESSAGE: Connex.Vendor.CertMessage;

type NetworkType = 'main' | 'test';
declare const genesisBlocks: Record<NetworkType, Connex.Thor.Block>;

/**
 * Wallet types
 */

declare const WalletMapping: Record<WalletSource, WalletConfig>;
declare const WalletSources: WalletSource[];

/**
 * The methods supported by the WalletConnect integration
 * @param RequestTransaction - Request the wallet to send a transaction
 * @param SignCertificate - Request the wallet to sign a certificate
 */
declare enum DefaultMethods {
    RequestTransaction = "thor_sendTransaction",
    SignCertificate = "thor_signCertificate"
}

declare const convertVendorToSigner: (vendor: Connex.Vendor) => Connex.Signer;

declare const Storage: {
    setAccount: (account: string | null) => void;
    setSource: (source: WalletSource | null) => void;
    setConnectionCertificate: (certificate: ThorDevkit.Certificate | null) => void;
    getAccount: () => string | null;
    getSource: () => WalletSource | null;
    getConnectionCertificate: () => ThorDevkit.Certificate | null;
};

declare const normalizeGenesisId: (genesis?: Genesis) => string;
declare const normalizeGenesisBlock: (genesis?: Genesis) => Connex.Thor.Block;

type ICreateWallet = DAppKitOptions & {
    source: WalletSource;
    onDisconnected: () => void;
};
declare const createWallet: ({ source, genesis, walletConnectOptions, onDisconnected, connectionCertificate, }: ICreateWallet) => ConnexWallet;

/**
 * Create a new wallet connect sign client. Clients are cached by project id.
 * @param projectId - wallet connect dApp project id
 * @param metadata - dApp metadata
 */
declare const createWcClient: ({ projectId, metadata, }: WalletConnectOptions) => WCClient;

/**
 * Creates a new WalletConnect signer
 * @param options - The signer options. See {@link WCSignerOptions}
 * @returns A new {@link WCSigner}
 */
declare const createWcSigner: ({ genesisId, wcClient, web3Modal, onDisconnected, }: WCSignerOptions) => WCSigner;

/**
 * Creates a new WalletConnectModal instance
 * @param projectId - Your WalletConnect project ID
 */
declare const createWcModal: (projectId: string) => WCModal;

export { BaseWallet, CertificateBasedWallet, ConnectResponse, ConnexWallet, DAppKit, DAppKitLogger, DAppKitOptions, DEFAULT_CONNECT_CERT_MESSAGE, DefaultMethods, Genesis, LogLevel, OpenOptions, ResolvedSignClient, Storage, SubscribeModalState, WCClient, WCModal, WCSigner, WCSignerOptions, WCWallet, WalletConfig, WalletConnectOptions, WalletManager, WalletManagerState, WalletMapping, WalletSource, WalletSources, convertVendorToSigner, createWallet, createWcClient, createWcModal, createWcSigner, genesisBlocks, normalizeGenesisBlock, normalizeGenesisId };
