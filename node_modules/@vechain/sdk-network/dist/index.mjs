var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/network.ts
var network_exports = {};
__export(network_exports, {
  AccountsModule: () => AccountsModule,
  BUILT_IN_CONTRACTS: () => BUILT_IN_CONTRACTS,
  BlocksModule: () => BlocksModule,
  CHAIN_ID: () => CHAIN_ID,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory,
  ContractsModule: () => ContractsModule,
  DEFAULT_HTTP_TIMEOUT: () => DEFAULT_HTTP_TIMEOUT,
  DebugModule: () => DebugModule,
  DelegationHandler: () => DelegationHandler,
  ERROR_SELECTOR: () => ERROR_SELECTOR,
  GasModule: () => GasModule,
  HTTPS_REGEX: () => HTTPS_REGEX,
  HTTP_REGEX: () => HTTP_REGEX,
  HardhatVeChainProvider: () => HardhatVeChainProvider,
  HttpClient: () => HttpClient,
  JSONRPCEthersProvider: () => JSONRPCEthersProvider,
  LogsModule: () => LogsModule,
  MAINNET_URL: () => MAINNET_URL,
  NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS: () => NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS,
  NodesModule: () => NodesModule,
  PANIC_SELECTOR: () => PANIC_SELECTOR,
  POLLING_INTERVAL: () => POLLING_INTERVAL,
  Poll: () => Poll,
  ProviderInternalBaseWallet: () => ProviderInternalBaseWallet,
  ProviderInternalHDWallet: () => ProviderInternalHDWallet,
  RPCMethodsMap: () => RPCMethodsMap,
  RPC_DOCUMENTATION_URL: () => RPC_DOCUMENTATION_URL,
  RPC_METHODS: () => RPC_METHODS,
  TESTNET_URL: () => TESTNET_URL,
  THOR_SOLO_ACCOUNTS: () => THOR_SOLO_ACCOUNTS,
  THOR_SOLO_URL: () => THOR_SOLO_URL,
  ThorClient: () => ThorClient,
  TransactionsModule: () => TransactionsModule,
  VeChainAbstractSigner: () => VeChainAbstractSigner,
  VeChainPrivateKeySigner: () => VeChainPrivateKeySigner,
  VeChainProvider: () => VeChainProvider,
  blocksFormatter: () => blocksFormatter,
  buildQuery: () => buildQuery,
  debugFormatter: () => debugFormatter,
  debugGetBadBlocks: () => debugGetBadBlocks,
  debugGetRawBlock: () => debugGetRawBlock,
  debugGetRawHeader: () => debugGetRawHeader,
  debugGetRawReceipts: () => debugGetRawReceipts,
  debugGetRawTransaction: () => debugGetRawTransaction,
  debugTraceCall: () => debugTraceCall,
  debugTraceTransaction: () => debugTraceTransaction,
  engineExchangeCapabilities: () => engineExchangeCapabilities,
  engineExchangeTransitionConfigurationV1: () => engineExchangeTransitionConfigurationV1,
  engineForkchoiceUpdatedV1: () => engineForkchoiceUpdatedV1,
  engineForkchoiceUpdatedV2: () => engineForkchoiceUpdatedV2,
  engineForkchoiceUpdatedV3: () => engineForkchoiceUpdatedV3,
  engineGetPayloadBodiesByHashV1: () => engineGetPayloadBodiesByHashV1,
  engineGetPayloadBodiesByRangeV1: () => engineGetPayloadBodiesByRangeV1,
  engineGetPayloadV1: () => engineGetPayloadV1,
  engineGetPayloadV2: () => engineGetPayloadV2,
  engineGetPayloadV3: () => engineGetPayloadV3,
  engineNewPayloadV1: () => engineNewPayloadV1,
  engineNewPayloadV2: () => engineNewPayloadV2,
  engineNewPayloadV3: () => engineNewPayloadV3,
  ethAccounts: () => ethAccounts,
  ethBlockNumber: () => ethBlockNumber,
  ethCall: () => ethCall,
  ethChainId: () => ethChainId,
  ethCoinbase: () => ethCoinbase,
  ethCreateAccessList: () => ethCreateAccessList,
  ethEstimateGas: () => ethEstimateGas,
  ethFeeHistory: () => ethFeeHistory,
  ethGasPrice: () => ethGasPrice,
  ethGetBalance: () => ethGetBalance,
  ethGetBlockByHash: () => ethGetBlockByHash,
  ethGetBlockByNumber: () => ethGetBlockByNumber,
  ethGetBlockReceipts: () => ethGetBlockReceipts,
  ethGetBlockTransactionCountByHash: () => ethGetBlockTransactionCountByHash,
  ethGetBlockTransactionCountByNumber: () => ethGetBlockTransactionCountByNumber,
  ethGetCode: () => ethGetCode,
  ethGetFilterChanges: () => ethGetFilterChanges,
  ethGetFilterLogs: () => ethGetFilterLogs,
  ethGetLogs: () => ethGetLogs,
  ethGetProof: () => ethGetProof,
  ethGetStorageAt: () => ethGetStorageAt,
  ethGetTransactionByBlockHashAndIndex: () => ethGetTransactionByBlockHashAndIndex,
  ethGetTransactionByBlockNumberAndIndex: () => ethGetTransactionByBlockNumberAndIndex,
  ethGetTransactionByHash: () => ethGetTransactionByHash,
  ethGetTransactionCount: () => ethGetTransactionCount,
  ethGetTransactionReceipt: () => ethGetTransactionReceipt,
  ethGetUncleByBlockHashAndIndex: () => ethGetUncleByBlockHashAndIndex,
  ethGetUncleByBlockNumberAndIndex: () => ethGetUncleByBlockNumberAndIndex,
  ethGetUncleCountByBlockHash: () => ethGetUncleCountByBlockHash,
  ethGetUncleCountByBlockNumber: () => ethGetUncleCountByBlockNumber,
  ethGetWork: () => ethGetWork,
  ethHashrate: () => ethHashrate,
  ethMaxPriorityFeePerGas: () => ethMaxPriorityFeePerGas,
  ethMining: () => ethMining,
  ethNewBlockFilter: () => ethNewBlockFilter,
  ethNewFilter: () => ethNewFilter,
  ethNewPendingTransactionFilter: () => ethNewPendingTransactionFilter,
  ethProtocolVersion: () => ethProtocolVersion,
  ethSendRawTransaction: () => ethSendRawTransaction,
  ethSendTransaction: () => ethSendTransaction,
  ethSign: () => ethSign,
  ethSignTransaction: () => ethSignTransaction,
  ethSubmitWork: () => ethSubmitWork,
  ethSubscribe: () => ethSubscribe,
  ethSyncing: () => ethSyncing,
  ethUninstallFilter: () => ethUninstallFilter,
  ethUnsubscribe: () => ethUnsubscribe,
  evmMine: () => evmMine,
  formatToLogsRPC: () => formatToLogsRPC,
  formatToRPCStandard: () => formatToRPCStandard3,
  getCorrectBlockNumberRPCToVeChain: () => getCorrectBlockNumberRPCToVeChain,
  getCriteriaSetForInput: () => getCriteriaSetForInput,
  getNumberOfLogsAheadOfTransactionIntoBlockExpanded: () => getNumberOfLogsAheadOfTransactionIntoBlockExpanded,
  getTransactionIndexIntoBlock: () => getTransactionIndexIntoBlock,
  netListening: () => netListening,
  netPeerCount: () => netPeerCount,
  netVersion: () => netVersion,
  parityNextNonce: () => parityNextNonce,
  sanitizeWebsocketBaseURL: () => sanitizeWebsocketBaseURL,
  signerUtils: () => signerUtils,
  subscriptions: () => subscriptions,
  thorest: () => thorest,
  toQueryString: () => toQueryString,
  transactionsFormatter: () => transactionsFormatter,
  vnsUtils: () => vnsUtils,
  web3ClientVersion: () => web3ClientVersion
});

// src/provider/helpers/provider-internal-wallets/abstract-wallet/abstract-provider-internal-wallet.ts
import { Address as Address6, HexUInt as HexUInt3 } from "@vechain/sdk-core";
import { InvalidDataType as InvalidDataType11 } from "@vechain/sdk-errors";

// src/signer/signers/utils/utils.ts
function transactionBodyToTransactionRequestInput(transactionBody, from) {
  return {
    from,
    chainTag: transactionBody.chainTag,
    blockRef: transactionBody.blockRef,
    expiration: transactionBody.expiration,
    clauses: transactionBody.clauses,
    gasPriceCoef: transactionBody.gasPriceCoef,
    gas: transactionBody.gas,
    dependsOn: transactionBody.dependsOn ?? void 0,
    nonce: transactionBody.nonce,
    reserved: transactionBody.reserved
  };
}

// src/signer/signers/utils/index.ts
var signerUtils = {
  transactionBodyToTransactionRequestInput
};

// ../../node_modules/@noble/curves/esm/abstract/utils.js
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var u8a = (a) => a instanceof Uint8Array;
function concatBytes(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}

// src/signer/signers/vechain-private-key-signer/vechain-private-key-signer.ts
import {
  Address as Address5,
  Hex as Hex5,
  HexUInt as HexUInt2,
  Keccak256 as Keccak2563,
  Transaction,
  TransactionHandler as TransactionHandler3,
  Txt as Txt3,
  secp256k1,
  vechain_sdk_core_ethers as vechain_sdk_core_ethers3
} from "@vechain/sdk-core";
import {
  InvalidSecp256k1PrivateKey,
  JSONRPCInvalidParams as JSONRPCInvalidParams2
} from "@vechain/sdk-errors";

// src/thor-client/accounts/accounts-module.ts
import { InvalidDataType as InvalidDataType4 } from "@vechain/sdk-errors";
import { Address as Address2, Revision, ThorId } from "@vechain/sdk-core";

// src/utils/const/built-in/built-in.ts
import { stringifyData } from "@vechain/sdk-errors";
var PARAMS_ADDRESS = "0x0000000000000000000000000000506172616d73";
var ENERGY_ADDRESS = "0x0000000000000000000000000000456e65726779";
var PARAMS_ABI = stringifyData([
  {
    constant: false,
    inputs: [
      {
        name: "_key",
        type: "bytes32"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "set",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_key",
        type: "bytes32"
      }
    ],
    name: "get",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "executor",
    outputs: [
      {
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "key",
        type: "bytes32"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Set",
    type: "event"
  }
]);
var ENERGY_ABI = stringifyData([
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "pure",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_spender",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        name: "success",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_from",
        type: "address"
      },
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        name: "success",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ],
    payable: false,
    stateMutability: "pure",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        name: "balance",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "pure",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        name: "success",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_from",
        type: "address"
      },
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "move",
    outputs: [
      {
        name: "success",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalBurned",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      },
      {
        name: "_spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        name: "remaining",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "_from",
        type: "address"
      },
      {
        indexed: true,
        name: "_to",
        type: "address"
      },
      {
        indexed: false,
        name: "_value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "_owner",
        type: "address"
      },
      {
        indexed: true,
        name: "_spender",
        type: "address"
      },
      {
        indexed: false,
        name: "_value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  }
]);
var BUILT_IN_CONTRACTS = {
  PARAMS_ABI,
  PARAMS_ADDRESS,
  ENERGY_ABI,
  ENERGY_ADDRESS
};

// src/utils/const/client/http-client.ts
var DEFAULT_HTTP_TIMEOUT = 3e4;
var HTTP_REGEX = /^http:\/\//;
var HTTPS_REGEX = /^https:\/\//;

// src/utils/const/client/nodes.ts
var NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS = 30;

// src/utils/const/client/transactions.ts
import { Keccak256, Txt } from "@vechain/sdk-core";
var ERROR_SELECTOR = Keccak256.of(Txt.of("Error(string)").bytes).toString().slice(0, 10);
var PANIC_SELECTOR = Keccak256.of(Txt.of("Panic(uint256)").bytes).toString().slice(0, 10);

// src/utils/const/network/network.ts
var MAINNET_URL = "https://mainnet.vechain.org";
var TESTNET_URL = "https://testnet.vechain.org";
var THOR_SOLO_URL = "http://localhost:8669";

// src/utils/const/rpc/rpc.ts
var RPC_DOCUMENTATION_URL = "https://ethereum.github.io/execution-apis/api-documentation/";

// src/utils/const/thor-solo/thor-solo.ts
var THOR_SOLO_ACCOUNTS = [
  /* ----------- NEW ACCOUNTS ----------- */
  /**
   * Each new account starts with
   * - VET: 500000000
   * - VTHO: at least 500000000 (VTHO is not constant due to generation when having VET)
   */
  {
    privateKey: "7f9290cc44c5fd2b95fe21d6ad6fe5fa9c177e1cd6f3b4c96a97b13e09eaa158",
    address: "0x3db469a79593dcc67f07DE1869d6682fC1eaf535"
  },
  {
    privateKey: "ea5383ac1f9e625220039a4afac6a7f868bf1ad4f48ce3a1dd78bd214ee4ace5",
    address: "0x2669514f9fe96bc7301177ba774d3da8a06cace4"
  },
  {
    privateKey: "1758771c54938e977518e4ff1c297aca882f6598891df503030734532efa790e",
    address: "0x9e7911de289c3c856ce7f421034f66b6cde49c39"
  },
  {
    privateKey: "432f38bcf338c374523e83fdb2ebe1030aba63c7f1e81f7d76c5f53f4d42e766",
    address: "0x88b2551c3ed42ca663796c10ce68c88a65f73fe2"
  },
  {
    privateKey: "706e6acd567fdc22db54aead12cb39db01c4832f149f95299aa8dd8bef7d28ff",
    address: "0xf02f557c753edf5fcdcbfe4c1c3a448b3cc84d54"
  },
  {
    privateKey: "f9fc826b63a35413541d92d2bfb6661128cd5075fcdca583446d20c59994ba26",
    address: "0x7a28e7361fd10f4f058f9fefc77544349ecff5d6"
  },
  {
    privateKey: "0da72e8e26580d409d1837e23cc50c887358964152039e32af0c8a147c6b616d",
    address: "0xb717b660cd51109334bd10b2c168986055f58c1a"
  },
  {
    privateKey: "6e8ad4e4ffb888082d94975a58dc9a8179f8724ba22301cd8392ba5352af7e25",
    address: "0x62226ae029dabcf90f3cb66f091919d2687d5257"
  },
  {
    privateKey: "521b7793c6eb27d137b617627c6b85d57c0aa303380e9ca4e30a30302fbc6676",
    address: "0x062f167a905c1484de7e75b88edc7439f82117de"
  },
  {
    privateKey: "adc81265b0909dec70235ec973b1758e45ce5ce7cfe92eb96b79cd0ef07bc6bc",
    address: "0x3e3d79163b08502a086213cd09660721740443d7"
  },
  /* ----------- THOR SOLO GENESIS ACCOUNTS ----------- */
  /**
   * Each Thor Solo genesis account has
   * - VET: 500000000
   * - VTHO: at least 1365000000 (VTHO is not constant due to generation when having VET)
   */
  {
    privateKey: "99f0500549792796c14fed62011a51081dc5b5e68fe8bd8a13b86be829c4fd36",
    address: "0xf077b491b355e64048ce21e3a6fc4751eeea77fa"
  },
  {
    privateKey: "7b067f53d350f1cf20ec13df416b7b73e88a1dc7331bc904b92108b1e76a08b1",
    address: "0x435933c8064b4ae76be665428e0307ef2ccfbd68"
  },
  {
    privateKey: "f4a1a17039216f535d42ec23732c79943ffb45a089fbb78a14daad0dae93e991",
    address: "0x0f872421dc479f3c11edd89512731814d0598db5"
  },
  {
    privateKey: "35b5cc144faca7d7f220fca7ad3420090861d5231d80eb23e1013426847371c4",
    address: "0xf370940abdbd2583bc80bfc19d19bc216c88ccf0"
  },
  {
    privateKey: "10c851d8d6c6ed9e6f625742063f292f4cf57c2dbeea8099fa3aca53ef90aef1",
    address: "0x99602e4bbc0503b8ff4432bb1857f916c3653b85"
  },
  {
    privateKey: "2dd2c5b5d65913214783a6bd5679d8c6ef29ca9f2e2eae98b4add061d0b85ea0",
    address: "0x61e7d0c2b25706be3485980f39a3a994a8207acf"
  },
  {
    privateKey: "e1b72a1761ae189c10ec3783dd124b902ffd8c6b93cd9ff443d5490ce70047ff",
    address: "0x361277d1b27504f36a3b33d3a52d1f8270331b8c"
  },
  {
    privateKey: "35cbc5ac0c3a2de0eb4f230ced958fd6a6c19ed36b5d2b1803a9f11978f96072",
    address: "0xd7f75a0a1287ab2916848909c8531a0ea9412800"
  },
  {
    privateKey: "b639c258292096306d2f60bc1a8da9bc434ad37f15cd44ee9a2526685f592220",
    address: "0xabef6032b9176c186f6bf984f548bda53349f70a"
  },
  {
    privateKey: "9d68178cdc934178cca0a0051f40ed46be153cf23cb1805b59cc612c0ad2bbe0",
    address: "0x865306084235bf804c8bba8a8d56890940ca8f0b"
  }
];

// src/utils/helpers/request.ts
var buildQuery = (params) => {
  const definedParams = {};
  for (const key in params) {
    if (params[key] !== void 0) {
      definedParams[key] = params[key];
    }
  }
  return definedParams;
};

// src/utils/http/http-client.ts
import { InvalidHTTPRequest } from "@vechain/sdk-errors";
var HttpClient = class {
  /**
   * Instantiates an HttpClient object with a specified base URL and HTTP request timeout.
   *
   * @param baseURL - The base URL for all network requests.
   * @param options - (Optional) An object containing additional configuration options for the HTTP client, such as a request timeout.
   */
  constructor(baseURL, options) {
    this.baseURL = baseURL;
    this.timeout = options?.timeout ?? DEFAULT_HTTP_TIMEOUT;
  }
  timeout;
  /**
   * Sends an HTTP request using the Fetch API.
   *
   * @param method - The HTTP method to be used ('GET' or 'POST').
   * @param path - The path to access on the server relative to the base URL.
   * @param params - (Optional) Additional request parameters such as query parameters, request body, and custom headers.
   * @returns A promise that resolves to the response data from the HTTP request.
   * @throws {InvalidHTTPRequest}
   */
  async http(method, path, params) {
    let url;
    try {
      url = new URL(path, this.baseURL);
    } catch (error) {
      throw new InvalidHTTPRequest(
        "HttpClient.http()",
        `Invalid URL: ${this.baseURL}${path}`,
        {
          method,
          url: `${this.baseURL}${path}`,
          message: "Request failed"
        },
        error
      );
    }
    if (params?.query != null) {
      Object.entries(params.query).forEach(([key, value]) => {
        url.searchParams.append(key, String(value));
      });
    }
    const config = {
      method,
      headers: params?.headers,
      body: method !== "GET" ? JSON.stringify(params?.body) : void 0
    };
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
      controller.abort();
    }, this.timeout);
    try {
      const response = await fetch(url.toString(), {
        ...config,
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        const message = await response.text();
        throw new InvalidHTTPRequest(
          "HttpClient.http()",
          `Invalid URL: ${this.baseURL}${path}`,
          {
            method,
            url: url.toString(),
            status: response.status,
            message
          }
        );
      }
      this.validateResponseHeader(
        params,
        Object.fromEntries(response.headers.entries())
      );
      return await response.json();
    } catch (error) {
      throw new InvalidHTTPRequest(
        "HttpClient.http()",
        `Invalid URL: ${this.baseURL}${path}`,
        {
          method,
          url: url.toString(),
          message: "Request failed"
        },
        error
      );
    }
  }
  /**
   * Validates the response headers if a validation function is provided.
   *
   * @param params - (Optional) The request parameters.
   * @param headers - The response headers.
   */
  validateResponseHeader(params, headers) {
    if (params?.validateResponseHeader != null && headers != null) {
      params.validateResponseHeader(headers);
    }
  }
};

// src/utils/poll/sync.ts
import { InvalidDataType, PollExecution } from "@vechain/sdk-errors";
async function sleep(delayInMilliseconds) {
  await new Promise((resolve) => setTimeout(resolve, delayInMilliseconds));
}
function SyncPoll(pollingFunction, options) {
  if (options?.requestIntervalInMilliseconds !== void 0 && (options.requestIntervalInMilliseconds <= 0 || !Number.isInteger(options.requestIntervalInMilliseconds))) {
    throw new InvalidDataType(
      "SyncPoll()",
      'Polling failed: Invalid input for field "options?.requestIntervalInMilliseconds" it must be a positive number',
      {
        requestIntervalInMilliseconds: options.requestIntervalInMilliseconds
      }
    );
  }
  if (options?.maximumIterations !== void 0 && (options.maximumIterations <= 0 || !Number.isInteger(options.maximumIterations))) {
    throw new InvalidDataType(
      "SyncPoll()",
      'Polling failed: Invalid input for field "options?.maximumIterations" it must be a positive number',
      {
        maximumIterations: options.maximumIterations
      }
    );
  }
  if (options?.maximumWaitingTimeInMilliseconds !== void 0 && (options.maximumWaitingTimeInMilliseconds <= 0 || !Number.isInteger(options.maximumWaitingTimeInMilliseconds))) {
    throw new InvalidDataType(
      "SyncPoll()",
      'Polling failed: Invalid input for field "options?.maximumWaitingTimeInMilliseconds" it must be a positive number',
      {
        maximumWaitingTimeInMilliseconds: options.maximumWaitingTimeInMilliseconds
      }
    );
  }
  let currentIteration = 0;
  let currentResult;
  let pollingCondition = false;
  const startTime = Date.now();
  return {
    /**
     * Poll until the condition is met.
     *
     * @param condition - The condition to be met.
     * @returns The result of the poll after the condition is met.
     */
    waitUntil: async (condition) => {
      try {
        do {
          currentResult = await pollingFunction();
          await sleep(
            options?.requestIntervalInMilliseconds !== void 0 ? options.requestIntervalInMilliseconds : 1e3
          );
          currentIteration = currentIteration + 1;
          const isConditionSatisfied = condition(currentResult);
          const isMaximumIterationsReached = options?.maximumIterations !== void 0 ? currentIteration >= options.maximumIterations : false;
          const isTimeLimitReached = options?.maximumWaitingTimeInMilliseconds !== void 0 && Date.now() - startTime >= options.maximumWaitingTimeInMilliseconds;
          pollingCondition = !(isConditionSatisfied || isMaximumIterationsReached || isTimeLimitReached);
        } while (pollingCondition);
        return currentResult;
      } catch (error) {
        throw new PollExecution(
          "SyncPoll.waitUntil()",
          "Polling failed: Function execution error encountered during synchronous polling.",
          {
            functionName: pollingFunction.name
          },
          error
        );
      }
    }
  };
}

// src/utils/poll/event.ts
import { EventEmitter } from "events";
import { InvalidDataType as InvalidDataType2, PollExecution as PollExecution2 } from "@vechain/sdk-errors";
var EventPoll = class extends EventEmitter {
  /**
   * The current iteration. It counts how many iterations have been done.
   * This parameter is useful to know how many iterations have been done.
   * For example, it can be used to stop the poll after a certain number of iterations.
   */
  currentIteration = 0;
  /**
   * Error thrown during the execution of the poll.
   */
  error;
  /**
   * Indicates whether to stop execution on error of the
   * {@link _intervalLoop} function.
   *
   * @type {boolean}
   */
  hasToStopOnError;
  /**
   * The interval used to poll.
   */
  intervalId;
  /**
   * The function to be called.
   */
  pollingFunction;
  /**
   * The interval of time (in milliseconds) between each request.
   */
  requestIntervalInMilliseconds;
  /**
   * Constructor for creating an instance of EventPoll.
   *
   * @param {Function} pollingFunction - The function to be executed repeatedly.
   * @param {number} requestIntervalInMilliseconds - The interval in milliseconds between each execution of the polling function.
   * @param {boolean} [hasToStopOnError=true] - Indicates whether to stop polling if an error occurs.
   * @throws {InvalidDataType}
   */
  constructor(pollingFunction, requestIntervalInMilliseconds, hasToStopOnError) {
    super();
    this.pollingFunction = pollingFunction;
    this.hasToStopOnError = hasToStopOnError;
    if (requestIntervalInMilliseconds !== void 0 && (requestIntervalInMilliseconds <= 0 || !Number.isInteger(requestIntervalInMilliseconds))) {
      throw new InvalidDataType2(
        "SyncPoll()",
        'Polling failed: Invalid input for field "options?.maximumWaitingTimeInMilliseconds" it must be a positive number',
        {
          requestIntervalInMilliseconds
        }
      );
    }
    this.requestIntervalInMilliseconds = requestIntervalInMilliseconds;
  }
  /**
   * Get how many iterations have been done.
   *
   * @returns The number of iterations.
   */
  get getCurrentIteration() {
    return this.currentIteration;
  }
  /**
   * Basic interval loop function.
   * This function must be called into setInterval.
   * It calls the promise and emit the event.
   */
  async _intervalLoop() {
    try {
      const data = await this.pollingFunction();
      this.emit("data", { data, eventPoll: this });
    } catch (error) {
      this.error = new PollExecution2(
        "EventPoll - main interval loop function",
        `Error during the execution of the poll ${error.message}`,
        {
          functionName: this.pollingFunction.name
        }
      );
      this.emit("error", { error: this.error });
      if (this.hasToStopOnError) {
        this.stopListen();
      }
    }
    this.currentIteration = this.currentIteration + 1;
  }
  /**
   * Listen to the 'data' event.
   * This method is the redefinition of the EventEmitter.on method.
   * Because the EventEmitter.on method does not allow to specify the type of the data.
   * And we must be type safe.
   *
   * This is equivalent to:
   *
   * ```typescript
   * eventPoll.on('data', (data) => { ... });
   * ```
   * @param onDataCallback - The callback to be called when the event is emitted.
   */
  onData(onDataCallback) {
    this.on("data", (data) => {
      onDataCallback(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        data.data,
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        data.eventPoll
      );
    });
    return this;
  }
  /* --- Overloaded of 'on' event emitter start --- */
  /**
   * Listen to the 'error' event.
   * This method is the redefinition of the EventEmitter.on method.
   * Because the EventEmitter.on method does not allow to specify the type of the data.
   * And we must be type safe.
   *
   * This is equivalent to:
   *
   * ```typescript
   * eventPoll.on('error', (data) => { ... });
   * ```
   * @param onErrorCallback - The callback to be called when the event is emitted.
   */
  onError(onErrorCallback) {
    this.on("error", (error) => {
      onErrorCallback(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        error.error
      );
    });
    return this;
  }
  /**
   * Listen to the 'start' event.
   * This happens when the poll is stopped.
   *
   * @param onStartCallback - The callback to be called when the event is emitted.
   */
  onStart(onStartCallback) {
    this.on("start", (data) => {
      onStartCallback(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        data.eventPoll
      );
    });
    return this;
  }
  /**
   * Listen to the 'stop' event.
   * This happens when the poll is stopped.
   *
   * @param onStopCallback - The callback to be called when the event is emitted.
   */
  onStop(onStopCallback) {
    this.on("stop", (data) => {
      onStopCallback(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        data.eventPoll
      );
    });
    return this;
  }
  /**
   * Start listening to the event.
   */
  startListen() {
    this.emit("start", { eventPoll: this });
    void this._intervalLoop().then(() => {
      this.intervalId = setInterval(() => {
        void (async () => {
          await this._intervalLoop();
        })();
      }, this.requestIntervalInMilliseconds);
    });
  }
  /**
   * Stop listening to the event.
   */
  stopListen() {
    clearInterval(this.intervalId);
    this.emit("stop", { eventPoll: this });
  }
  /* --- Overloaded of 'on' event emitter end --- */
};
function createEventPoll(callBack, requestIntervalInMilliseconds, hasToStopOnError = true) {
  return new EventPoll(
    callBack,
    requestIntervalInMilliseconds,
    hasToStopOnError
  );
}

// src/utils/poll/index.ts
var Poll = { SyncPoll, createEventPoll };

// src/utils/thorest/helpers.ts
import { InvalidDataType as InvalidDataType3 } from "@vechain/sdk-errors";
var toQueryString = (params) => {
  const queryParts = Object.entries(params).filter(([, value]) => value !== void 0).map(
    ([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(
      value
    )}`
  );
  return queryParts.length > 0 ? `?${queryParts.join("&")}` : "";
};
var sanitizeWebsocketBaseURL = (url) => {
  url = url.trim();
  const urlRegex = /^(https?:\/\/)([a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*)(:\d+)?\/?$/;
  if (!urlRegex.test(url))
    throw new InvalidDataType3(
      "sanitizeWebsocketBaseURL()",
      `Invalid url: ${url}. Must adhere to the regex: ${urlRegex}.`,
      { url, urlRegex }
    );
  url = url.replace(/\/$/, "");
  url = HTTP_REGEX.exec(url) !== null ? url.replace(HTTP_REGEX, "ws://") : url.replace(HTTPS_REGEX, "wss://");
  return url;
};

// src/utils/thorest/thorest.ts
var thorest = {
  /**
   * Accounts related endpoints.
   */
  accounts: {
    get: {
      ACCOUNT_DETAIL: (address) => `/accounts/${address}`,
      ACCOUNT_BYTECODE: (address) => `/accounts/${address}/code`,
      STORAGE_AT: (address, position) => `/accounts/${address}/storage/${position}`
    },
    post: {
      SIMULATE_TRANSACTION: (revision) => {
        return revision != null ? `/accounts/*?revision=${revision}` : `/accounts/*`;
      }
    }
  },
  /**
   * Blocks related endpoints.
   */
  blocks: {
    get: {
      BLOCK_DETAIL: (revision) => `/blocks/${revision}`
    }
  },
  /**
   * Nodes related endpoints.
   */
  nodes: {
    get: {
      NODES: () => "/node/network/peers"
    }
  },
  /**
   * Logs related endpoints.
   */
  logs: {
    post: {
      EVENT_LOGS: () => "/logs/event",
      TRANSFER_LOGS: () => "/logs/transfer"
    }
  },
  /**
   * Transactions related endpoints.
   */
  transactions: {
    get: {
      TRANSACTION: (id) => `/transactions/${id}`,
      TRANSACTION_RECEIPT: (id) => `/transactions/${id}/receipt`
    },
    post: {
      TRANSACTION: () => `/transactions`
    }
  },
  /**
   * Subscriptions related endpoints.
   */
  subscriptions: {
    get: {
      /**
       * Subscribe to new blocks.
       *
       * @param baseURL - The URL of the node to request the subscription from.
       * @param position - (optional) The block id to start from, defaults to the best block.
       *
       * @returns The websocket subscription URL.
       */
      BLOCK: (baseURL, position) => {
        const queryParams = toQueryString({
          pos: position
        });
        return `${sanitizeWebsocketBaseURL(
          baseURL
        )}/subscriptions/block${queryParams}`;
      },
      /**
       * Subscribe to new events.
       *
       * @param baseURL - The URL of the node to request the subscription from.
       * @param options - (optional) The options for the subscription.
       *
       * @returns The websocket subscription URL.
       */
      EVENT: (baseURL, options) => {
        const queryParams = toQueryString({
          pos: options?.position,
          addr: options?.contractAddress,
          t0: options?.topic0,
          t1: options?.topic1,
          t2: options?.topic2,
          t3: options?.topic3,
          t4: options?.topic4
        });
        return `${sanitizeWebsocketBaseURL(
          baseURL
        )}/subscriptions/event${queryParams}`;
      },
      /**
       * Subscribe to new VET transfers.
       *
       * @param baseURL - The URL of the node to request the subscription from.
       * @param options - (optional) The options for the subscription.
       *
       * @returns The websocket subscription URL.
       */
      VET_TRANSFER: (baseURL, options) => {
        const queryParams = toQueryString({
          pos: options?.position,
          txOrigin: options?.signerAddress,
          sender: options?.sender,
          recipient: options?.receiver
        });
        return `${sanitizeWebsocketBaseURL(
          baseURL
        )}/subscriptions/transfer${queryParams}`;
      },
      /**
       * Subscribe to new legacy beats.
       * A beat is a notification that a new block has been added to the blockchain with a bloom filter which can be used to check if the block contains any relevant account.
       * @note This subscription has been improved with dynamic size bloom filter with the new `BEAT` subscription.
       *
       * @param baseURL - The URL of the node to request the subscription from.
       * @param position - (optional) The block id to start from, defaults to the best block.
       *
       * @returns The websocket subscription URL.
       */
      BEAT_LEGACY: (baseURL, position) => {
        const queryParams = toQueryString({
          pos: position
        });
        return `${sanitizeWebsocketBaseURL(
          baseURL
        )}/subscriptions/beat${queryParams}`;
      },
      /**
       * Subscribe to new beats.
       * A beat is a notification that a new block has been added to the blockchain with a bloom filter which can be used to check if the block contains any relevant account.
       *
       * @param baseURL - The URL of the node to request the subscription from.
       * @param position - (optional) The block id to start from, defaults to the best block.
       *
       * @returns The websocket subscription URL.
       */
      BEAT: (baseURL, position) => {
        const queryParams = toQueryString({
          pos: position
        });
        return `${sanitizeWebsocketBaseURL(
          baseURL
        )}/subscriptions/beat2${queryParams}`;
      },
      /**
       * Subscribe to new transactions.
       *
       * @returns The websocket subscription URL.
       */
      NEW_TRANSACTIONS: (baseURL) => `${sanitizeWebsocketBaseURL(baseURL)}/subscriptions/txpool`
    }
  },
  /**
   * Debug related endpoints.
   */
  debug: {
    post: {
      TRACE_TRANSACTION_CLAUSE: () => `/debug/tracers`,
      TRACE_CONTRACT_CALL: () => `/debug/tracers/call`,
      RETRIEVE_STORAGE_RANGE: () => `/debug/storage-range`
    }
  }
};

// src/utils/subscriptions/beat.ts
var getLegacyBeatSubscriptionUrl = (baseURL, options) => {
  return thorest.subscriptions.get.BEAT_LEGACY(baseURL, options?.blockID);
};
var getBeatSubscriptionUrl = (baseURL, options) => {
  return thorest.subscriptions.get.BEAT(baseURL, options?.blockID);
};

// src/utils/subscriptions/block.ts
var getBlockSubscriptionUrl = (baseURL, options) => {
  return thorest.subscriptions.get.BLOCK(baseURL, options?.blockID);
};

// src/utils/subscriptions/event.ts
import { abi, vechain_sdk_core_ethers } from "@vechain/sdk-core";
var getEventSubscriptionUrl = (baseURL, event, indexedValues, options) => {
  if (vechain_sdk_core_ethers.EventFragment.isFragment(event)) {
    event = event.format("full");
  }
  const ev = new abi.Event(event);
  const encodedTopics = ev.encodeFilterTopics(indexedValues ?? []);
  return thorest.subscriptions.get.EVENT(baseURL, {
    position: options?.blockID,
    contractAddress: options?.address,
    topic0: encodedTopics[0],
    topic1: encodedTopics[1],
    topic2: encodedTopics[2],
    topic3: encodedTopics[3],
    topic4: encodedTopics[4]
  });
};

// src/utils/subscriptions/transaction.ts
var getNewTransactionsSubscriptionUrl = (baseURL) => {
  return thorest.subscriptions.get.NEW_TRANSACTIONS(baseURL);
};

// src/utils/subscriptions/transfer.ts
var getVETtransfersSubscriptionUrl = (baseURL, options) => {
  return thorest.subscriptions.get.VET_TRANSFER(baseURL, {
    position: options?.blockID,
    signerAddress: options?.signerAddress,
    sender: options?.sender,
    receiver: options?.recipient
  });
};

// src/utils/subscriptions/index.ts
var subscriptions = {
  getEventSubscriptionUrl,
  getBlockSubscriptionUrl,
  getNewTransactionsSubscriptionUrl,
  getVETtransfersSubscriptionUrl,
  getLegacyBeatSubscriptionUrl,
  getBeatSubscriptionUrl
};

// src/utils/vns/addresses.ts
import {
  MAINNET_NETWORK,
  SOLO_NETWORK,
  TESTNET_NETWORK
} from "@vechain/sdk-core";
var NetworkContracts = {
  [MAINNET_NETWORK.genesisBlock.id]: {
    registry: "0xa9231da8BF8D10e2df3f6E03Dd5449caD600129b",
    resolveUtils: "0xA11413086e163e41901bb81fdc5617c975Fa5a1A"
  },
  [TESTNET_NETWORK.genesisBlock.id]: {
    registry: "0xcBFB30c1F267914816668d53AcBA7bA7c9806D13",
    resolveUtils: "0xc403b8EA53F707d7d4de095f0A20bC491Cf2bc94"
  },
  [SOLO_NETWORK.genesisBlock.id]: {
    registry: "0x1c4a602ed21f3d1dddd1142c81f231ef1a08c921",
    resolveUtils: "0xb2f08bbfa8a42b1fbe63feec604cb147385203d7"
  }
};

// src/utils/vns/index.ts
import {
  Address,
  ZERO_ADDRESS
} from "@vechain/sdk-core";
var resolveName = async (thorClient, name) => {
  const [address] = await vnsUtils.resolveNames(thorClient, [name]);
  return address ?? null;
};
var resolveNames = async (thorClient, names) => {
  const genesisBlock = await thorClient.blocks.getGenesisBlock();
  if (genesisBlock === null || !Address.isValid(NetworkContracts[genesisBlock.id]?.resolveUtils)) {
    return names.map(() => null);
  }
  const resolveUtilsAddress = NetworkContracts[genesisBlock.id].resolveUtils;
  const [addresses] = await thorClient.contracts.executeCall(
    resolveUtilsAddress,
    "function getAddresses(string[] names) returns (address[] addresses)",
    [names]
  );
  return addresses.map((address) => {
    if (address === ZERO_ADDRESS || !Address.isValid(address)) {
      return null;
    }
    return address;
  });
};
var lookupAddress = async (thorClient, address) => {
  const [name] = await vnsUtils.lookupAddresses(thorClient, [address]);
  return name ?? null;
};
var lookupAddresses = async (thorClient, addresses) => {
  const genesisBlock = await thorClient.blocks.getGenesisBlock();
  if (genesisBlock === null || !Address.isValid(NetworkContracts[genesisBlock.id]?.resolveUtils)) {
    return addresses.map(() => null);
  }
  const resolveUtilsAddress = NetworkContracts[genesisBlock.id].resolveUtils;
  const [names] = await thorClient.contracts.executeCall(
    resolveUtilsAddress,
    "function getNames(address[] addresses) returns (string[] names)",
    [addresses]
  );
  return names.map((name) => {
    if (name === "") {
      return null;
    }
    return name;
  });
};
var vnsUtils = { resolveName, resolveNames, lookupAddress, lookupAddresses };

// src/thor-client/accounts/accounts-module.ts
var AccountsModule = class {
  /**
   * Initializes a new instance of the `Thor` class.
   * @param thor - The Thor instance used to interact with the VeChain blockchain API.
   */
  constructor(thor) {
    this.thor = thor;
  }
  /**
   * Retrieves account details such as balance of VET, VTHO, and if the address is a smart contract.
   *
   * @param address - The account address to query details for.
   * @param options - (Optional) Other optional parameters for the request.
   * @returns A promise that resolves to an object containing the account details (balance, energy, hasCode).
   * @throws {InvalidDataType}
   */
  async getAccount(address, options) {
    if (!Address2.isValid(address)) {
      throw new InvalidDataType4(
        "AccountsModule.getAccount()",
        "Invalid address. The address must be a valid VeChainThor address.",
        { address }
      );
    }
    if (options?.revision !== null && options?.revision !== void 0 && !Revision.isValid(options.revision)) {
      throw new InvalidDataType4(
        "AccountsModule.getAccount()",
        'Invalid revision. The revision must be a string representing a block number or block id (also "best" is accepted which represents the best block & "finalized" for the finalized block).',
        { revision: options?.revision }
      );
    }
    return await this.thor.httpClient.http(
      "GET",
      thorest.accounts.get.ACCOUNT_DETAIL(address),
      {
        query: buildQuery({ revision: options?.revision })
      }
    );
  }
  /**
   * Fetches the bytecode of a contract at a given address.
   *
   * @param address - The contract address to get the bytecode for.
   * @param options - (Optional) Other optional parameters for the request.
   * @returns A promise that resolves to the contract bytecode as a string.
   * @throws {InvalidDataType}
   */
  async getBytecode(address, options) {
    if (!Address2.isValid(address)) {
      throw new InvalidDataType4(
        "AccountsModule.getBytecode()",
        "Invalid address. The address must be a valid VeChainThor address.",
        { address }
      );
    }
    if (options?.revision !== null && options?.revision !== void 0 && !Revision.isValid(options.revision)) {
      throw new InvalidDataType4(
        "AccountsModule.getBytecode()",
        'Invalid revision. The revision must be a string representing a block number or block id (also "best" is accepted which represents the best block & "finalized" for the finalized block).',
        { revision: options?.revision }
      );
    }
    const result = await this.thor.httpClient.http(
      "GET",
      thorest.accounts.get.ACCOUNT_BYTECODE(address),
      {
        query: buildQuery({ revision: options?.revision })
      }
    );
    return result.code;
  }
  /**
   * Retrieves the value from a smart contract's storage at a given position.
   *
   * @param address - The contract address to query storage from.
   * @param position - The position in the storage to retrieve the value from. Must be a 32 bytes hex string (66 characters including `0x` prefix).
   * @param options - (Optional) Other optional parameters for the request.
   * @returns A promise that resolves to the storage value in hex string format.
   * @throws {InvalidDataType}
   */
  async getStorageAt(address, position, options) {
    if (!Address2.isValid(address)) {
      throw new InvalidDataType4(
        "AccountsModule.getStorageAt()",
        "Invalid address. The address must be a valid VeChainThor address.",
        { address }
      );
    }
    if (options?.revision !== null && options?.revision !== void 0 && !Revision.isValid(options.revision)) {
      throw new InvalidDataType4(
        "AccountsModule.getStorageAt()",
        'Invalid revision. The revision must be a string representing a block number or block id (also "best" is accepted which represents the best block & "finalized" for the finalized block).',
        { revision: options?.revision }
      );
    }
    if (!ThorId.isValid(position)) {
      throw new InvalidDataType4(
        "AccountsModule.getStorageAt()",
        "Invalid `position`. The position must be a hex string of 32 bytes (66 characters including `0x` prefix).",
        { position }
      );
    }
    const result = await this.thor.httpClient.http(
      "GET",
      thorest.accounts.get.STORAGE_AT(address, position),
      {
        query: buildQuery({ position, revision: options?.revision })
      }
    );
    return result.value;
  }
};

// src/thor-client/blocks/blocks-module.ts
import { InvalidDataType as InvalidDataType5 } from "@vechain/sdk-errors";
import { Revision as Revision2 } from "@vechain/sdk-core";
var BlocksModule = class {
  /**
   * Initializes a new instance of the `Thor` class.
   * @param thor - The Thor instance used to interact with the VeChain blockchain API.
   * @param options - (Optional) Other optional parameters for polling and error handling.
   */
  constructor(thor, options) {
    this.thor = thor;
    this.onBlockError = options?.onBlockError;
    if (options?.isPollingEnabled === true) this.setupPolling();
  }
  /**
   * The head block (best block). This is updated by the event poll instance every time a new block is produced.
   * @private
   */
  headBlock = null;
  /**
   * Error handler for block-related errors.
   */
  onBlockError;
  /**
   * The Poll instance for event polling
   * @private
   */
  pollInstance;
  /**
   * Destroys the instance by stopping the event poll.
   */
  destroy() {
    if (this.pollInstance != null) {
      this.pollInstance.stopListen();
    }
  }
  /**
   * Sets up the event polling for the best block.
   * @private
   * */
  setupPolling() {
    this.pollInstance = Poll.createEventPoll(
      async () => await this.thor.blocks.getBestBlockCompressed(),
      1e4
      // Poll every 10 seconds,
    ).onData((data) => {
      this.headBlock = data;
    }).onError(this.onBlockError ?? (() => {
    }));
    this.pollInstance.startListen();
  }
  /**
   * Retrieves details of a compressed specific block identified by its revision (block number or ID).
   *
   * @param revision - The block number or ID to query details for.
   * @returns A promise that resolves to an object containing the details of the compressed block.
   * @throws {InvalidDataType}
   */
  async getBlockCompressed(revision) {
    if (revision !== null && revision !== void 0 && !Revision2.isValid(revision)) {
      throw new InvalidDataType5(
        "BlocksModule.getBlockCompressed()",
        'Invalid revision. The revision must be a string representing a block number or block id (also "best" is accepted which represents the best block & "finalized" for the finalized block).',
        { revision }
      );
    }
    return await this.thor.httpClient.http(
      "GET",
      thorest.blocks.get.BLOCK_DETAIL(revision)
    );
  }
  /**
   * Retrieves details of an expanded specific block identified by its revision (block number or ID).
   *
   * @param revision - The block number or ID to query details for.
   * @returns A promise that resolves to an object containing the details of the expanded block.
   * @throws {InvalidDataType}
   */
  async getBlockExpanded(revision) {
    if (revision !== null && revision !== void 0 && !Revision2.isValid(revision)) {
      throw new InvalidDataType5(
        "BlocksModule.getBlockExpanded()",
        'Invalid revision. The revision must be a string representing a block number or block id (also "best" is accepted which represents the best block & "finalized" for the finalized block).',
        { revision }
      );
    }
    return await this.thor.httpClient.http(
      "GET",
      thorest.blocks.get.BLOCK_DETAIL(revision),
      {
        query: buildQuery({ expanded: true })
      }
    );
  }
  /**
   * Retrieves details of the latest block.
   *
   * @returns A promise that resolves to an object containing the compressed block details.
   */
  async getBestBlockCompressed() {
    return await this.getBlockCompressed("best");
  }
  /**
   * Retrieves details of the latest block.
   *
   * @returns A promise that resolves to an object containing the expanded block details.
   */
  async getBestBlockExpanded() {
    return await this.getBlockExpanded("best");
  }
  /**
   * Asynchronously retrieves a reference to the best block in the blockchain.
   *
   * This method first calls `getBestBlockCompressed()` to obtain the current best block. If no block is found (i.e., if `getBestBlockCompressed()` returns `null`),
   * the method returns `null` indicating that there's no block to reference. Otherwise, it extracts and returns the first 18 characters of the
   * block's ID, providing the ref to the best block.
   *
   * @returns {Promise<string | null>} A promise that resolves to either a string representing the first 18 characters of the best block's ID,
   * or `null` if no best block is found.
   *
   * @Example:
   * const blockRef = await getBestBlockRef();
   * if (blockRef) {
   *     console.log(`Reference to the best block: ${blockRef}`);
   * } else {
   *     console.log("No best block found.");
   * }
   */
  async getBestBlockRef() {
    const bestBlock = await this.getBestBlockCompressed();
    if (bestBlock === null) return null;
    return bestBlock.id.slice(0, 18);
  }
  /**
   * Retrieves the finalized block.
   *
   * @returns A promise that resolves to an object containing the finalized block.
   */
  async getFinalBlockCompressed() {
    return await this.getBlockCompressed("finalized");
  }
  /**
   * Retrieves details of the finalized block.
   *
   * @returns A promise that resolves to an object containing the finalized block details.
   */
  async getFinalBlockExpanded() {
    return await this.getBlockExpanded("finalized");
  }
  /**
   * Synchronously waits for a specific block revision using polling.
   *
   * @param blockNumber - The block number to wait for.
   * @param expanded - A boolean indicating whether to wait for an expanded block.
   * @param options - (Optional) Allows to specify timeout and interval in milliseconds
   * @returns A promise that resolves to an object containing the compressed block.
   * @throws {InvalidDataType}
   */
  async _waitForBlock(blockNumber, expanded, options) {
    if (blockNumber !== void 0 && blockNumber !== null && blockNumber <= 0) {
      throw new InvalidDataType5(
        "BlocksModule.waitForBlock()",
        "Invalid blockNumber. The blockNumber must be a number representing a block number.",
        { blockNumber }
      );
    }
    return await Poll.SyncPoll(
      async () => expanded ? await this.getBestBlockCompressed() : await this.getBestBlockExpanded(),
      {
        requestIntervalInMilliseconds: options?.intervalMs,
        maximumWaitingTimeInMilliseconds: options?.timeoutMs
      }
    ).waitUntil((result) => {
      return result != null && result?.number >= blockNumber;
    });
  }
  /**
   * Synchronously waits for a specific block revision using polling.
   *
   * @param blockNumber - The block number to wait for.
   * @param options - (Optional) Allows to specify timeout and interval in milliseconds
   * @returns A promise that resolves to an object containing the compressed block.
   */
  async waitForBlockCompressed(blockNumber, options) {
    return await this._waitForBlock(
      blockNumber,
      false,
      options
    );
  }
  /**
   * Synchronously waits for a specific expanded block revision using polling.
   *
   * @param blockNumber - The block number to wait for.
   * @param options - (Optional) Allows to specify timeout and interval in milliseconds
   * @returns A promise that resolves to an object containing the expanded block details.
   */
  async waitForBlockExpanded(blockNumber, options) {
    return await this._waitForBlock(
      blockNumber,
      true,
      options
    );
  }
  /**
   * Returns the head block (best block).
   * @returns {BlockDetail | null} The head block (best block).
   */
  getHeadBlock() {
    return this.headBlock;
  }
  /**
   * Retrieves details of the genesis block.
   *
   * @returns A promise that resolves to an object containing the block details of the genesis block.
   */
  async getGenesisBlock() {
    return await this.getBlockCompressed(0);
  }
  /**
   * Retrieves all addresses involved in a given block. This includes beneficiary, signer, clauses,
   * delegator, gas payer, origin, contract addresses, event addresses, and transfer recipients and senders.
   *
   * @param {ExpandedBlockDetail} block - The block object to extract addresses from.
   *
   * @returns {string[]} - An array of addresses involved in the block, included
   * empty addresses, duplicate elements are removed.
   *
   */
  getAllAddressesIntoABlock(block) {
    const addresses = /* @__PURE__ */ new Set();
    addresses.add(block.beneficiary);
    addresses.add(block.signer);
    block.transactions.forEach(
      (transaction) => {
        transaction.clauses.forEach((clause) => {
          if (typeof clause.to === "string") {
            addresses.add(clause.to);
          }
        });
        addresses.add(transaction.delegator);
        addresses.add(transaction.gasPayer);
        addresses.add(transaction.origin);
        transaction.outputs.forEach((output) => {
          if (typeof output.contractAddress === "string") {
            addresses.add(output.contractAddress);
          }
          output.events.forEach((event) => {
            addresses.add(event.address);
          });
          output.transfers.forEach((transfer) => {
            addresses.add(transfer.recipient);
            addresses.add(transfer.sender);
          });
        });
      }
    );
    return Array.from(addresses);
  }
};

// src/thor-client/contracts/contracts-module.ts
import {
  abi as abi3,
  clauseBuilder as clauseBuilder3,
  coder as coder2,
  dataUtils
} from "@vechain/sdk-core";

// src/thor-client/contracts/model/contract-factory.ts
import {
  clauseBuilder as clauseBuilder2,
  TransactionHandler
} from "@vechain/sdk-core";

// src/thor-client/contracts/model/contract.ts
import {
  coder
} from "@vechain/sdk-core";
import { InvalidAbiFragment } from "@vechain/sdk-errors";

// src/thor-client/contracts/model/contract-proxy.ts
import { InvalidTransactionField } from "@vechain/sdk-errors";
import { clauseBuilder, fragment } from "@vechain/sdk-core";

// src/thor-client/contracts/model/contract-filter.ts
var ContractFilter = class {
  /**
   * The smart contract instance to apply the filter on.
   */
  contract;
  /**
   * A set of criteria used to filter events.
   */
  criteriaSet;
  /**
   * Constructs an instance of the `ContractFilter` class.
   *
   * @param contract - The smart contract instance to apply the filter on.
   * @param criteriaSet - A set of criteria used to filter events.
   */
  constructor(contract, criteriaSet) {
    this.contract = contract;
    this.criteriaSet = criteriaSet;
  }
  /**
   * Retrieves event logs based on the specified filter criteria, range, pagination options, and order.
   *
   * @returns An array of event logs that match the specified criteria.
   * @param param - The filter options to apply to the event logs.
   */
  async get(param) {
    const filterEventLogsOptions = {
      range: param?.range ?? {
        unit: "block",
        from: 0,
        to: (await this.contract.thor.blocks.getBestBlockCompressed())?.number
      },
      criteriaSet: this.criteriaSet,
      options: param?.options,
      order: param?.order ?? "asc"
    };
    return await this.contract.thor.logs.filterEventLogs(
      filterEventLogsOptions
    );
  }
};

// src/thor-client/contracts/model/contract-proxy.ts
function getReadProxy(contract) {
  return new Proxy(contract.read, {
    get: (_target, prop) => {
      return async (...args) => {
        const extractOptionsResult = extractAndRemoveAdditionalOptions(
          args
        );
        const clauseComment = extractOptionsResult.clauseAdditionalOptions?.comment;
        const revisionValue = extractOptionsResult.clauseAdditionalOptions?.revision;
        return await contract.thor.contracts.executeCall(
          contract.address,
          contract.getFunctionFragment(prop),
          extractOptionsResult.args,
          {
            caller: contract.getSigner() !== void 0 ? await contract.getSigner()?.getAddress() : void 0,
            ...contract.getContractReadOptions(),
            comment: clauseComment,
            revision: revisionValue,
            includeABI: true
          }
        );
      };
    }
  });
}
function getTransactProxy(contract) {
  return new Proxy(contract.transact, {
    get: (_target, prop) => {
      return async (...args) => {
        if (contract.getSigner() === void 0) {
          throw new InvalidTransactionField(
            "getTransactProxy()",
            "Caller signer is required to transact with the contract.",
            { fieldName: "signer", prop }
          );
        }
        const transactionOptions = contract.getContractTransactOptions();
        const extractAdditionalOptionsResult = extractAndRemoveAdditionalOptions(args);
        const transactionValue = extractAdditionalOptionsResult.clauseAdditionalOptions?.value;
        const clauseComment = extractAdditionalOptionsResult.clauseAdditionalOptions?.comment;
        args = extractAdditionalOptionsResult.args;
        return await contract.thor.contracts.executeTransaction(
          contract.getSigner(),
          contract.address,
          contract.getFunctionFragment(prop),
          args,
          {
            ...transactionOptions,
            value: transactionOptions.value ?? transactionValue ?? 0,
            comment: clauseComment,
            includeABI: true
          }
        );
      };
    }
  });
}
function getFilterProxy(contract) {
  return new Proxy(contract.filters, {
    get: (_target, prop) => {
      return (args) => {
        const argsArray = extractArgsArray(
          args,
          contract,
          prop
        );
        const criteriaSet = buildCriteria(contract, prop, argsArray);
        return new ContractFilter(contract, [criteriaSet]);
      };
    }
  });
}
function getClauseProxy(contract) {
  return new Proxy(contract.clause, {
    get: (_target, prop) => {
      return (...args) => {
        const transactionOptions = contract.getContractTransactOptions();
        const extractAdditionalOptionsResult = extractAndRemoveAdditionalOptions(args);
        const transactionValue = extractAdditionalOptionsResult.clauseAdditionalOptions?.value;
        const clauseComment = extractAdditionalOptionsResult.clauseAdditionalOptions?.comment;
        args = extractAdditionalOptionsResult.args;
        return {
          clause: clauseBuilder.functionInteraction(
            contract.address,
            contract.getFunctionFragment(prop),
            args,
            transactionOptions.value ?? transactionValue ?? 0,
            {
              comment: clauseComment,
              includeABI: true
            }
          ),
          functionFragment: contract.getFunctionFragment(prop)
        };
      };
    }
  });
}
function getCriteriaProxy(contract) {
  return new Proxy(contract.criteria, {
    get: (_target, prop) => {
      return (args) => {
        const argsArray = extractArgsArray(
          args,
          contract,
          prop
        );
        return buildCriteria(contract, prop, argsArray);
      };
    }
  });
}
function buildCriteria(contract, prop, args) {
  const eventFragment = new fragment.Event(contract.getEventFragment(prop));
  const topics = new Map(
    eventFragment.encodeFilterTopics(args).map((topic, index) => [index, topic])
  );
  return {
    criteria: {
      address: contract.address,
      topic0: topics.get(0),
      // the first topic is always defined since it's the event signature
      topic1: topics.has(1) ? topics.get(1) : void 0,
      topic2: topics.has(2) ? topics.get(2) : void 0,
      topic3: topics.has(3) ? topics.get(3) : void 0,
      topic4: topics.has(4) ? topics.get(4) : void 0
    },
    eventFragment: eventFragment.fragment
  };
}
function extractAndRemoveAdditionalOptions(args) {
  const transactionValue = getTransactionValue(args);
  const clauseComment = getClauseComment(args);
  const clauseRevision = getRevision(args);
  if (transactionValue !== void 0 || clauseComment !== void 0 || clauseRevision !== void 0) {
    args = args.filter(
      (arg) => !(isTransactionValue(arg) || isTransactionComment(arg) || isRevision(arg))
    );
  }
  return {
    args,
    clauseAdditionalOptions: {
      value: transactionValue?.value,
      comment: clauseComment?.comment,
      revision: clauseRevision?.revision
    }
  };
}
function getTransactionValue(args) {
  return args.find((arg) => isTransactionValue(arg));
}
function getClauseComment(args) {
  return args.find((arg) => isTransactionComment(arg));
}
function getRevision(args) {
  return args.find((arg) => isRevision(arg));
}
function isTransactionValue(obj) {
  return obj.value !== void 0;
}
function isTransactionComment(obj) {
  return obj.comment !== void 0;
}
function isRevision(obj) {
  return obj.revision !== void 0;
}
function getEventArgsMap(abi6, eventName) {
  const event = abi6.find(
    (item) => item.type === "event" && item.name === eventName
  );
  if (event == null) {
    throw new Error(`Event with name ${eventName} not found in ABI`);
  }
  const argsMap = {};
  event.inputs.forEach((input) => {
    argsMap[input.name] = input.type;
  });
  return argsMap;
}
function mapObjectToEventArgs(obj, eventArgsMap) {
  const mappedObject = {};
  for (const [argName] of Object.entries(eventArgsMap)) {
    if (Object.prototype.hasOwnProperty.call(obj, argName)) {
      mappedObject[argName] = obj[argName];
    } else {
      mappedObject[argName] = void 0;
    }
  }
  return mappedObject;
}
function extractArgsArray(args, contract, prop) {
  if (args === void 0) {
    return [];
  }
  let argsArray = [];
  if (Array.isArray(args)) {
    argsArray = args;
  } else {
    const eventsArgsMap = getEventArgsMap(contract.abi, prop);
    const mappedObj = mapObjectToEventArgs(args, eventsArgsMap);
    argsArray = Object.entries(mappedObj).map(([_key, value]) => {
      return value;
    });
  }
  return argsArray;
}

// src/thor-client/contracts/model/contract.ts
var Contract = class {
  thor;
  address;
  abi;
  signer;
  deployTransactionReceipt;
  read = {};
  transact = {};
  filters = (
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    {}
  );
  clause = {};
  criteria = {};
  contractCallOptions = {};
  contractTransactionOptions = {};
  /**
   * Initializes a new instance of the `Contract` class.
   * @param address The address of the contract.
   * @param abi The Application Binary Interface (ABI) of the contract, which defines the contract's methods and events.
   * @param thor An instance of ThorClient to interact with the blockchain.
   * @param signer The signer caller used for signing transactions.
   * @param transactionReceipt (Optional) The transaction receipt of the contract deployment.
   */
  constructor(address, abi6, thor, signer, transactionReceipt) {
    this.abi = abi6;
    this.thor = thor;
    this.address = address;
    this.deployTransactionReceipt = transactionReceipt;
    this.signer = signer;
    this.read = getReadProxy(this);
    this.transact = getTransactProxy(this);
    this.filters = getFilterProxy(this);
    this.clause = getClauseProxy(this);
    this.criteria = getCriteriaProxy(this);
  }
  /**
   * Sets the options for contract calls.
   * @param options - The contract call options to set.
   * @returns The updated contract call options.
   */
  setContractReadOptions(options) {
    this.contractCallOptions = options;
    this.read = getReadProxy(this);
    return this.contractCallOptions;
  }
  /**
   * Clears the current contract call options, resetting them to an empty object.
   * @returns The updated contract call options.
   */
  getContractReadOptions() {
    return this.contractCallOptions;
  }
  /**
   * Clears the current contract call options, resetting them to an empty object.
   */
  clearContractReadOptions() {
    this.contractCallOptions = {};
    this.read = getReadProxy(this);
  }
  /**
   * Sets the options for contract transactions.
   * @param options - The contract transaction options to set.
   * @returns The updated contract transaction options.
   */
  setContractTransactOptions(options) {
    this.contractTransactionOptions = options;
    this.transact = getTransactProxy(this);
    return this.contractTransactionOptions;
  }
  /**
   * Retrieves the options for contract transactions.
   * @returns The contract transaction options.
   */
  getContractTransactOptions() {
    return this.contractTransactionOptions;
  }
  /**
   * Clears the current contract transaction options, resetting them to an empty object.
   */
  clearContractTransactOptions() {
    this.contractTransactionOptions = {};
    this.transact = getTransactProxy(this);
  }
  /**
   * Sets the private key of the caller for signing transactions.
   * @param signer - The caller signer
   */
  setSigner(signer) {
    this.signer = signer;
    this.transact = getTransactProxy(this);
    this.read = getReadProxy(this);
    return this.signer;
  }
  /**
   * Get the caller signer used for signing transactions.
   * @returns The signer used for signing transactions.
   */
  getSigner() {
    return this.signer;
  }
  /**
   * Retrieves the function fragment for the specified function name.
   * @param prop - The name of the function.
   * @private
   * @throws {InvalidAbiFragment}
   *
   */
  getFunctionFragment(prop) {
    const functionFragment = coder.createInterface(this.abi).getFunction(prop.toString());
    if (functionFragment == null) {
      throw new InvalidAbiFragment(
        "Contract.getFunctionFragment()",
        `Function '${prop.toString()}' not found in contract ABI.`,
        {
          type: "event",
          fragment: prop
        }
      );
    }
    return functionFragment;
  }
  /**
   * Retrieves the event fragment for the specified event name.
   * @param eventName - The name of the event.
   * @return The event fragment for the specified event name.
   * @throws {InvalidAbiFragment}
   */
  getEventFragment(eventName) {
    const eventFragment = coder.createInterface(this.abi).getEvent(eventName.toString());
    if (eventFragment == null) {
      throw new InvalidAbiFragment(
        "Contract.getEventFragment()",
        `Function '${eventName.toString()}' not found in contract ABI.`,
        {
          type: "event",
          fragment: eventName
        }
      );
    }
    return eventFragment;
  }
};

// src/thor-client/contracts/model/contract-factory.ts
import {
  CannotFindTransaction,
  ContractDeploymentFailed
} from "@vechain/sdk-errors";
var ContractFactory = class {
  /**
   * The ABI (Application Binary Interface) of the contract.
   */
  abi;
  /**
   * The bytecode of the smart contract.
   */
  bytecode;
  /**
   * The signer used for signing transactions.
   */
  signer;
  /**
   * An instance of ThorClient to interact with the blockchain.
   */
  thor;
  /**
   * The result of the deployment transaction, undefined until a deployment is started.
   */
  deployTransaction;
  /**
   * Initializes a new instance of the `ContractFactory` class.
   * @param abi The Application Binary Interface (ABI) of the contract, which defines the contract's methods and events.
   * @param bytecode The compiled bytecode of the contract, representing the contract's executable code.
   * @param signer The signer used for signing transactions during contract deployment, ensuring the deployer's identity.
   * @param thor An instance of ThorClient to interact with the blockchain.
   */
  constructor(abi6, bytecode, signer, thor) {
    this.abi = abi6;
    this.bytecode = bytecode;
    this.signer = signer;
    this.thor = thor;
  }
  /**
   * Initiates the deployment of a smart contract.
   *
   * This method performs several steps to deploy a smart contract:
   * 1. Builds a transaction clause for deploying the contract.
   * 2. Estimates the gas cost required for the transaction.
   * 3. Constructs the transaction body with the estimated gas cost.
   * 4. Signs the transaction using the provided signer.
   * 5. Sends the signed transaction to the blockchain.
   *
   * @param {DeployParams?} deployParams (Optional) parameters for contract deployment.
   * @param {ContractTransactionOptions?} options (Optional) transaction options, such as gas limit.
   * @returns {Promise<ContractFactory>} A promise that resolves to the instance of `ContractFactory`,
   *          allowing for fluent chaining of further actions or queries.
   * @throws {Error} Throws an error if any step in the deployment process fails.
   */
  async startDeployment(deployParams, options) {
    const deployContractClause = clauseBuilder2.deployContract(
      this.bytecode,
      deployParams
    );
    const gasResult = await this.thor.gas.estimateGas(
      [deployContractClause],
      await this.signer.getAddress()
    );
    const txBody = await this.thor.transactions.buildTransactionBody(
      [deployContractClause],
      gasResult.totalGas,
      options
    );
    const signedTx = await this.signer.signTransaction(
      signerUtils.transactionBodyToTransactionRequestInput(
        txBody,
        await this.signer.getAddress()
      )
    );
    this.deployTransaction = await this.thor.transactions.sendTransaction(
      TransactionHandler.decode(
        Buffer.from(signedTx.slice(2), "hex"),
        true
      )
    );
    return this;
  }
  /**
   * Waits for the completion of a contract deployment transaction.
   *
   * This method checks for the presence of a deployed transaction result and then
   * waits for the transaction to be processed. Upon successful processing, it
   * constructs and returns a new `Contract` instance based on the transaction receipt.
   *
   * @returns {Promise<Contract>} A promise that resolves to a `Contract` instance
   *          once the deployment transaction is completed.
   * @throws {CannotFindTransaction, ContractDeploymentFailed}
   */
  async waitForDeployment() {
    if (this.deployTransaction?.id === void 0) {
      throw new CannotFindTransaction(
        "ContractFactory.waitForDeployment()",
        "Cannot find a contract deployment transaction",
        {
          networkUrl: this.thor.httpClient.baseURL
        }
      );
    }
    const transactionReceipt = await this.deployTransaction.wait();
    if (transactionReceipt?.outputs[0]?.contractAddress === null || transactionReceipt?.outputs[0]?.contractAddress === void 0) {
      throw new ContractDeploymentFailed(
        "ContractFactory.waitForDeployment()",
        "Contract deployment failed.",
        {
          deployTransaction: this.deployTransaction
        }
      );
    }
    return new Contract(
      transactionReceipt?.outputs[0].contractAddress,
      this.abi,
      this.thor,
      this.signer,
      transactionReceipt
    );
  }
  /**
   * Returns the deploy transaction result, if available.
   */
  getDeployTransaction() {
    return this.deployTransaction;
  }
};

// src/thor-client/gas/helpers/decode-evm-error.ts
import { abi as abi2 } from "@vechain/sdk-core";

// src/thor-client/gas/helpers/const.ts
import { Keccak256 as Keccak2562, Txt as Txt2 } from "@vechain/sdk-core";
var SOLIDITY_ERROR_SELECTOR = Keccak2562.of(Txt2.of("Error(string)").bytes).toString().slice(0, 10);
var SOLIDITY_PANIC_SELECTOR = Keccak2562.of(Txt2.of("Panic(uint256)").bytes).toString().slice(0, 10);

// src/thor-client/gas/helpers/decode-evm-error.ts
function decodeRevertReason(data) {
  if (data.startsWith(SOLIDITY_ERROR_SELECTOR))
    return abi2.decode(
      "string",
      "0x" + data.slice(SOLIDITY_ERROR_SELECTOR.length)
    );
  if (data.startsWith(SOLIDITY_PANIC_SELECTOR)) {
    const decoded = abi2.decode(
      "uint256",
      "0x" + data.slice(SOLIDITY_PANIC_SELECTOR.length)
    );
    return `Panic(0x${parseInt(decoded).toString(16).padStart(2, "0")})`;
  }
}

// src/thor-client/contracts/contracts-module.ts
var ContractsModule = class {
  /**
   * Initializes a new instance of the `Thor` class.
   * @param thor - The Thor instance used to interact with the VeChain blockchain API.
   */
  constructor(thor) {
    this.thor = thor;
  }
  /**
   * Creates a new instance of `ContractFactory` configured with the specified ABI, bytecode, and signer.
   * This factory is used to deploy new smart contracts to the blockchain network managed by this instance.
   *
   * @param abi - The Application Binary Interface (ABI) of the contract, which defines the contract's methods and events.
   * @param bytecode - The compiled bytecode of the contract, representing the contract's executable code.
   * @param signer - The signer used for signing transactions during contract deployment, ensuring the deployer's identity.
   * @returns An instance of `ContractFactory` configured with the provided ABI, bytecode, and signer, ready for deploying contracts.
   */
  createContractFactory(abi6, bytecode, signer) {
    return new ContractFactory(
      abi6,
      bytecode,
      signer,
      this.thor
    );
  }
  /**
   * Initializes and returns a new Contract instance with the provided parameters.
   *
   * @param address - The blockchain address of the contract to load.
   * @param abi - The Application Binary Interface (ABI) of the contract, which defines the contract's methods and structures.
   * @param signer - Optional. The signer caller, used for signing transactions when interacting with the contract.
   * @returns A new instance of the Contract, initialized with the provided address, ABI, and optionally, a signer.
   */
  load(address, abi6, signer) {
    return new Contract(
      address,
      abi6,
      this.thor,
      signer
    );
  }
  /**
   * Executes a read-only call to a smart contract function, simulating the transaction to obtain the result.
   *
   * @param contractAddress - The address of the smart contract to interact with.
   * @param functionFragment - The function fragment, including the name and types of the function to be called, derived from the contract's ABI.
   * @param functionData - An array of arguments to be passed to the smart contract function, corresponding to the function's parameters.
   * @param contractCallOptions - (Optional) Additional options for the contract call, such as the sender's address, gas limit, and gas price, which can affect the simulation's context.
   * @returns A promise that resolves to the decoded output of the smart contract function call, the format of which depends on the function's return types.
   *
   * The function simulates a transaction using the provided parameters without submitting it to the blockchain, allowing read-only operations to be tested without incurring gas costs or modifying the blockchain state.
   */
  async executeCall(contractAddress, functionFragment, functionData, contractCallOptions) {
    const response = await this.thor.transactions.simulateTransaction(
      [
        {
          to: contractAddress,
          value: "0",
          data: new abi3.Function(functionFragment).encodeInput(
            functionData
          )
        }
      ],
      contractCallOptions
    );
    if (response[0].reverted) {
      return decodeRevertReason(response[0].data) ?? "";
    } else {
      return new abi3.Function(functionFragment).decodeOutput(
        response[0].data
      );
    }
  }
  /**
   * Executes a read-only call to multiple smart contract functions, simulating the transaction to obtain the results.
   * @param clauses - An array of contract clauses to interact with the contract functions.
   * @param options - (Optional) Additional options for the contract call, such as the sender's address, gas limit, and gas price, which can affect the simulation's context.
   */
  async executeMultipleClausesCall(clauses, options) {
    const response = await this.thor.transactions.simulateTransaction(
      clauses.map((clause) => clause.clause),
      options
    );
    return response.map((res, index) => {
      return new abi3.Function(
        clauses[index].functionFragment
      ).decodeOutput(res.data);
    });
  }
  /**
   * Executes a transaction to interact with a smart contract function.
   *
   * @param signer - The signer used for signing the transaction.
   * @param contractAddress - The address of the smart contract.
   * @param functionFragment - The function fragment, including the name and types of the function to be called, derived from the contract's ABI.
   * @param functionData - The input data for the function.
   * @param options - (Optional) An object containing options for the transaction body. Includes all options of the `buildTransactionBody` method
   *                  besides `isDelegated`.
   *                  @see {@link TransactionsModule.buildTransactionBody}
   *
   * @returns A promise resolving to a SendTransactionResult object.
   */
  async executeTransaction(signer, contractAddress, functionFragment, functionData, options) {
    const id = await signer.sendTransaction({
      clauses: [
        // Build a clause to interact with the contract function
        clauseBuilder3.functionInteraction(
          contractAddress,
          functionFragment,
          functionData,
          options?.value ?? 0
        )
      ]
    });
    return {
      id,
      wait: async () => await this.thor.transactions.waitForTransaction(id)
    };
  }
  /**
   * Executes a transaction to interact with multiple smart contract functions.
   * @param clauses - An array of transaction clauses to interact with the contract functions.
   * @param signer - The signer used to signing the transaction.
   */
  async executeMultipleClausesTransaction(clauses, signer) {
    const id = await signer.sendTransaction({
      clauses: clauses.map((clause) => clause.clause)
    });
    return {
      id,
      wait: async () => await this.thor.transactions.waitForTransaction(id)
    };
  }
  /**
   * Gets the base gas price in wei.
   * The base gas price is the minimum gas price that can be used for a transaction.
   * It is used to obtain the VTHO (energy) cost of a transaction.
   *
   * @link [Total Gas Price](https://docs.vechain.org/core-concepts/transactions/transaction-calculation#total-gas-price)
   *
   * @returns The base gas price in wei.
   */
  async getBaseGasPrice() {
    return await this.executeCall(
      BUILT_IN_CONTRACTS.PARAMS_ADDRESS,
      coder2.createInterface(BUILT_IN_CONTRACTS.PARAMS_ABI).getFunction("get"),
      [dataUtils.encodeBytes32String("base-gas-price", "left")]
    );
  }
};

// src/thor-client/debug/debug-module.ts
import { Address as Address3, Hex, ThorId as ThorId2 } from "@vechain/sdk-core";
import { InvalidDataType as InvalidDataType6 } from "@vechain/sdk-errors";
var DebugModule = class {
  /**
   * Initializes a new instance of the `Thor` class.
   * @param thor - The Thor instance used to interact with the VeChain blockchain API.
   */
  constructor(thor) {
    this.thor = thor;
  }
  /**
   * Trace transaction clause.
   *
   * This endpoint allows you to create a tracer for a specific clause.
   * Tracers are instrumental in monitoring and analyzing the execution flow within the EVM.
   * You can customize the tracer using various options to tailor it to your specific debugging needs.
   *
   * @param input - The input for the trace transaction clause. It has:
   * * target - The target of the tracer. It is a combination of blockID, transaction (transaction ID or index into block), and clauseIndex.
   * * config - The configuration of the tracer. It is specific to the name of the tracer.
   * @param name - The name of the tracer to use. It determines Output and Input configuration.
   */
  async traceTransactionClause(input, name) {
    this.validateTarget(input.target, "traceTransactionClause");
    const parsedTarget = `${input.target.blockID}/${input.target.transaction}/${input.target.clauseIndex}`;
    return await this.thor.httpClient.http(
      "POST",
      thorest.debug.post.TRACE_TRANSACTION_CLAUSE(),
      {
        query: {},
        body: {
          target: parsedTarget,
          name,
          config: input.config
        },
        headers: {}
      }
    );
  }
  /**
   * Trace a contract call.
   *
   * This endpoint enables clients to create a tracer for a specific function call.
   * You can customize the tracer using various options to suit your debugging requirements.
   *
   * @param input - The input for the trace contract call. It has:
   * * contractInput - The contract call information.
   * * config - The configuration of the tracer. It is specific to the name of the tracer.
   * * transactionOptions - The transaction options.
   * @param name - The name of the tracer to use. It determines Output and Input configuration.
   * @returns The trace result.
   * @throws{InvalidDataType}
   */
  async traceContractCall(input, name) {
    if (input.contractInput?.to !== void 0 && input.contractInput.to !== null && !Address3.isValid(input.contractInput.to)) {
      throw new InvalidDataType6(
        "DebugModule.traceContractCall()",
        `Invalid address '${input.contractInput.to}' given as input for traceContractCall.`,
        { address: input.contractInput.to }
      );
    }
    if (input.contractInput?.data !== void 0 && !Hex.isValid(input.contractInput.data))
      throw new InvalidDataType6(
        "DebugModule.traceContractCall()",
        `Invalid data '${input.contractInput?.data}' given as input for traceContractCall.`,
        { data: input.contractInput?.data }
      );
    if (input.contractInput?.value !== void 0 && !Hex.isValid0x(input.contractInput.value)) {
      throw new InvalidDataType6(
        "DebugModule.traceContractCall()",
        `Invalid value '${input.contractInput?.value}' given as input for traceContractCall.`,
        { value: input.contractInput?.value }
      );
    }
    return await this.thor.httpClient.http(
      "POST",
      thorest.debug.post.TRACE_CONTRACT_CALL(),
      {
        query: {},
        body: {
          to: input.contractInput?.to,
          data: input.contractInput?.data,
          value: input.contractInput?.value,
          name,
          gas: input.transactionOptions?.gas,
          gasPrice: input.transactionOptions?.gasPrice,
          caller: input.transactionOptions?.caller,
          provedWork: input.transactionOptions?.provedWork,
          gasPayer: input.transactionOptions?.gasPayer,
          expiration: input.transactionOptions?.expiration,
          blockRef: input.transactionOptions?.blockRef,
          config: input.config
        },
        headers: {}
      }
    );
  }
  /**
   * Retrieve the storage range.
   *
   * This endpoint enables clients to retrieve the storage range for the
   * coordinates specified in the `input` parameter.
   *
   * @param input - the coordinates to retrieve the storage range. It has:
   * * target - {@link TransactionTraceTarget} specifies `blockID`,
   *           `transaction` address and `clauseIndex` number.
   * * options - {@link RetrieveStorageRangeInputOptions} specified the
   *           `address` if the contract or account to retrieve the
   *           storage range for. Nullable.
   */
  async retrieveStorageRange(input) {
    this.validateTarget(input.target, "retrieveStorageRange");
    const parsedTarget = `${input.target.blockID}/${input.target.transaction}/${input.target.clauseIndex}`;
    return await this.thor.httpClient.http(
      "POST",
      thorest.debug.post.RETRIEVE_STORAGE_RANGE(),
      {
        query: {},
        body: {
          target: parsedTarget,
          address: input.options?.address,
          keyStart: input.options?.keyStart,
          maxResult: input.options?.maxResult
        },
        headers: {}
      }
    );
  }
  /**
   * Validate target of traceTransactionClause and retrieveStorageRange.
   *
   * @param target - Target of traceTransactionClause and retrieveStorageRange to validate.
   * @param functionName - The name of the function.
   * @throws{InvalidDataType}
   * @private
   */
  validateTarget(target, functionName) {
    if (!ThorId2.isValid(target.blockID)) {
      throw new InvalidDataType6(
        "DebugModule.validateTarget()",
        `Invalid block ID '${target.blockID}' given as input for ${functionName}.`,
        { blockId: target.blockID }
      );
    }
    if (typeof target.transaction === "string") {
      if (!ThorId2.isValid(target.transaction))
        throw new InvalidDataType6(
          "DebugModule.validateTarget()",
          `Invalid transaction id '${target.transaction}' given as input for ${functionName}.`,
          { transaction: target.transaction }
        );
    } else {
      if (target.transaction < 0) {
        throw new InvalidDataType6(
          "DebugModule.validateTarget()",
          `Invalid transaction index '${target.transaction}' given as input for ${functionName}.`,
          { transaction: target.transaction }
        );
      }
    }
    if (target.clauseIndex < 0) {
      throw new InvalidDataType6(
        "DebugModule.validateTarget()",
        `Invalid clause index '${target.clauseIndex}' given as input for ${functionName}.`,
        { clauseIndex: target.clauseIndex }
      );
    }
  }
};

// src/thor-client/gas/gas-module.ts
import { InvalidDataType as InvalidDataType7 } from "@vechain/sdk-errors";
import { TransactionUtils } from "@vechain/sdk-core";
var GasModule = class {
  /**
   * Initializes a new instance of the `Thor` class.
   * @param thor - The Thor instance used to interact with the VeChain blockchain API.
   */
  constructor(thor) {
    this.thor = thor;
  }
  /**
   * Simulates a transaction and returns an object containing information regarding the gas used and whether the transaction reverted.
   *
   * @note The caller option is suggested as estimation without this parameter may not be accurate.
   *
   * @param clauses - The clauses of the transaction to simulate.
   * @param caller - The address of the account sending the transaction.
   * @param options - Optional parameters for the request. Includes all options of the `simulateTransaction` method excluding the `caller` option.
   *                  @see {@link TransactionsClient#simulateTransaction}
   *                  Also, includes the `gasPadding` option which is a percentage of gas to add on top of the estimated gas. The value must be between (0, 1].
   * @returns An object containing information regarding the gas used and whether the transaction reverted, together with the decoded revert reason and VM errors.
   * @throws{InvalidDataType}
   */
  async estimateGas(clauses, caller, options) {
    if (clauses.length <= 0) {
      throw new InvalidDataType7(
        "GasModule.estimateGas()",
        "Invalid clauses. Clauses must be an array of clauses with at least one clause.",
        { clauses, caller, options }
      );
    }
    if (options?.gasPadding !== void 0 && (options.gasPadding <= 0 || options.gasPadding > 1)) {
      throw new InvalidDataType7(
        "GasModule.estimateGas()",
        "Invalid gasPadding. gasPadding must be a number between (0, 1].",
        { gasPadding: options?.gasPadding }
      );
    }
    const simulations = await this.thor.transactions.simulateTransaction(
      clauses,
      {
        caller,
        ...options
      }
    );
    const isReverted = simulations.some((simulation) => {
      return simulation.reverted;
    });
    const intrinsicGas = TransactionUtils.intrinsicGas(clauses);
    const totalSimulatedGas = simulations.reduce((sum, simulation) => {
      return sum + simulation.gasUsed;
    }, 0);
    const totalGas = (intrinsicGas + (totalSimulatedGas !== 0 ? totalSimulatedGas + 15e3 : 0)) * (1 + (options?.gasPadding ?? 0));
    return isReverted ? {
      totalGas,
      reverted: true,
      revertReasons: simulations.map((simulation) => {
        return decodeRevertReason(simulation.data) ?? "";
      }),
      vmErrors: simulations.map((simulation) => {
        return simulation.vmError;
      })
    } : {
      totalGas,
      reverted: false,
      revertReasons: [],
      vmErrors: []
    };
  }
};

// src/thor-client/logs/logs-module.ts
import { abi as abi4 } from "@vechain/sdk-core";
var LogsModule = class {
  /**
   * Initializes a new instance of the `Thor` class.
   * @param thor - The Thor instance used to interact with the VeChain blockchain API.
   */
  constructor(thor) {
    this.thor = thor;
  }
  /**
   * Filters event logs based on the provided criteria. Raw event logs are not decoded.
   *
   * @param filterOptions - An object specifying filtering criteria for event logs.
   * @returns A promise that resolves to filtered event logs.
   */
  async filterRawEventLogs(filterOptions) {
    return await this.thor.httpClient.http(
      "POST",
      thorest.logs.post.EVENT_LOGS(),
      {
        query: {},
        body: filterOptions,
        headers: {}
      }
    );
  }
  /**
   * Filters event logs based on the provided criteria and decodes them using the provided fragments.
   * The decoded data is added to the event logs as a new property.
   * @param filterOptions - An object specifying filtering criteria for event logs.
   */
  async filterEventLogs(filterOptions) {
    const fragments = filterOptions.criteriaSet?.map(
      (c) => c.eventFragment
    );
    const eventLogs = await this.getRawEventLogs(filterOptions);
    const result = [];
    if (fragments !== void 0) {
      const uniqueFragments = this.removeDuplicatedFragments(fragments);
      eventLogs.forEach((log) => {
        const eventFragment = new abi4.Event(
          uniqueFragments.get(log.topics[0])
        );
        log.decodedData = eventFragment.decodeEventLog(log);
        result.push(log);
      });
    }
    return result;
  }
  /**
   * Filters event logs based on the provided criteria and decodes them using the provided fragments.
   * The decoded data is added to the event logs as a new property.
   * The result is an array of event logs grouped by the event topic hash.
   * @param filterOptions
   * @returns A promise that resolves to an array of event logs grouped by event.
   */
  async filterGroupedEventLogs(filterOptions) {
    const fragments = filterOptions.criteriaSet?.map(
      (c) => c.eventFragment
    );
    const eventLogs = await this.getRawEventLogs(filterOptions);
    const result = /* @__PURE__ */ new Map();
    if (fragments !== void 0) {
      const uniqueFragments = this.removeDuplicatedFragments(fragments);
      uniqueFragments.forEach((f) => result.set(f.topicHash, []));
      eventLogs.forEach((log) => {
        const eventFragment = new abi4.Event(
          uniqueFragments.get(log.topics[0])
        );
        log.decodedData = eventFragment.decodeEventLog(log);
        result.get(log.topics[0])?.push(log);
      });
    }
    return Array.from(result.values());
  }
  /**
   * Filters event logs based on the provided criteria without decoding them.
   * @param filterOptions - An object specifying filtering criteria for event logs.
   * @private Returns a promise that resolves to filtered non decoded event logs.
   */
  async getRawEventLogs(filterOptions) {
    const criteriaSet = filterOptions.criteriaSet?.map((c) => c.criteria);
    const filterRawEventLogsOptions = {
      range: filterOptions.range ?? {
        unit: "block",
        from: 0,
        to: (await this.thor.blocks.getBestBlockCompressed())?.number
      },
      criteriaSet,
      options: filterOptions.options,
      order: filterOptions.order ?? "asc"
    };
    return await this.filterRawEventLogs(filterRawEventLogsOptions);
  }
  /**
   * Removes duplicated fragments from the provided array. Fragments are considered duplicated if they have the same topic hash.
   * @param fragments - An array of event fragments.
   * @private Returns a map of unique fragments.
   */
  removeDuplicatedFragments(fragments) {
    const uniqueFragments = /* @__PURE__ */ new Map();
    fragments.forEach((obj) => {
      if (!uniqueFragments.has(obj.topicHash)) {
        uniqueFragments.set(obj.topicHash, obj);
      }
    });
    return uniqueFragments;
  }
  /**
   * Filters transfer logs based on the provided criteria.
   *
   * @param filterOptions - An object specifying filtering criteria for transfer logs.
   * @returns A promise that resolves to filtered transfer logs.
   */
  async filterTransferLogs(filterOptions) {
    return await this.thor.httpClient.http(
      "POST",
      thorest.logs.post.TRANSFER_LOGS(),
      {
        query: {},
        body: filterOptions,
        headers: {}
      }
    );
  }
};

// src/thor-client/nodes/nodes-module.ts
import { InvalidDataType as InvalidDataType8 } from "@vechain/sdk-errors";
var NodesModule = class {
  /**
   * Initializes a new instance of the `Thor` class.
   * @param thor - The Thor instance used to interact with the VeChain blockchain API.
   */
  constructor(thor) {
    this.thor = thor;
  }
  /**
   * Retrieves connected peers of a node.
   *
   * @returns A promise that resolves to the list of connected peers.
   */
  async getNodes() {
    return await this.thor.httpClient.http(
      "GET",
      thorest.nodes.get.NODES()
    );
  }
  /**
   * Checks the health of a node using the following algorithm:
   * 1. Make an HTTP GET request to retrieve the last block timestamp.
   * 2. Calculates the difference between the current time and the last block timestamp.
   * 3. If the difference is less than the tolerance, the node is healthy.
   * Note, we could also check '/node/network/peers since' but the difficulty with this approach is
   * if you consider a scenario where the node is connected to 20+ peers, which is healthy, and it receives the new blocks as expected.
   * But what if the node's disk is full, and it's not writing the new blocks to its database? In this case the node is off-sync even
   * though it's technically alive and connected
   * @returns A boolean indicating whether the node is healthy.
   * @throws {InvalidDataTypeError} - if the timestamp key does not exist in the response from the API call to the node
   * @throws {InvalidDataTypeError} - if the timestamp key exists in the response from the API call to the node but the value is not a number
   * @throws {InvalidDataTypeError} - if the response from the API call to the node is not an object
   * @throws {InvalidDataTypeError} - if the response from the API call to the node is null or undefined
   */
  async isHealthy() {
    const response = await this.thor.blocks.getBestBlockCompressed();
    const lastBlockTimestamp = this.getTimestampFromBlock(response);
    const secondsSinceLastBlock = Math.floor(Date.now() / 1e3) - lastBlockTimestamp;
    return Math.abs(secondsSinceLastBlock) < NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS;
  }
  /**
   * Extracts the timestamp from the block
   * @remarks
   * This function throws an error if the timestamp key does not exist in the response from the API call to the node
   * @param response the response from the API call to the node
   * @returns the timestamp from the block
   * @throws{InvalidDataType}
   */
  getTimestampFromBlock = (response) => {
    if (response === null || response === void 0 || typeof response !== "object" || !("timestamp" in response) || typeof response.timestamp !== "number") {
      throw new InvalidDataType8(
        "NodesModule.getTimestampFromBlock()",
        "Sending failed: Input must be a valid raw transaction in hex format.",
        { response }
      );
    }
    return response?.timestamp;
  };
};

// src/thor-client/transactions/transactions-module.ts
import { InvalidDataType as InvalidDataType9, InvalidTransactionField as InvalidTransactionField2 } from "@vechain/sdk-errors";
import {
  Hex as Hex2,
  ThorId as ThorId3,
  TransactionHandler as TransactionHandler2,
  abi as abi5,
  Revision as Revision3,
  vechain_sdk_core_ethers as vechain_sdk_core_ethers2
} from "@vechain/sdk-core";
var TransactionsModule = class {
  /**
   * Initializes a new instance of the `Thor` class.
   * @param thor - The Thor instance used to interact with the VeChain blockchain API.
   */
  constructor(thor) {
    this.thor = thor;
  }
  /**
   * Retrieves the details of a transaction.
   *
   * @param id - Transaction ID of the transaction to retrieve.
   * @param options - (Optional) Other optional parameters for the request.
   * @returns A promise that resolves to the details of the transaction.
   * @throws {InvalidDataType}
   */
  async getTransaction(id, options) {
    if (!ThorId3.isValid(id)) {
      throw new InvalidDataType9(
        "TransactionsModule.getTransaction()",
        "Invalid transaction ID given as input. Input must be an hex string of length 64.",
        { id }
      );
    }
    if (options?.head !== void 0 && !ThorId3.isValid(options.head))
      throw new InvalidDataType9(
        "TransactionsModule.getTransaction()",
        "Invalid head given as input. Input must be an hex string of length 64.",
        { head: options?.head }
      );
    return await this.thor.httpClient.http(
      "GET",
      thorest.transactions.get.TRANSACTION(id),
      {
        query: buildQuery({
          raw: false,
          head: options?.head,
          pending: options?.pending
        })
      }
    );
  }
  /**
   * Retrieves the details of a transaction.
   *
   * @param id - Transaction ID of the transaction to retrieve.
   * @param options - (Optional) Other optional parameters for the request.
   * @returns A promise that resolves to the details of the transaction.
   * @throws {InvalidDataType}
   */
  async getTransactionRaw(id, options) {
    if (!ThorId3.isValid(id)) {
      throw new InvalidDataType9(
        "TransactionsModule.getTransactionRaw()",
        "Invalid transaction ID given as input. Input must be an hex string of length 64.",
        { id }
      );
    }
    if (options?.head !== void 0 && !ThorId3.isValid(options.head))
      throw new InvalidDataType9(
        "TransactionsModule.getTransaction()",
        "Invalid head given as input. Input must be an hex string of length 64.",
        { head: options?.head }
      );
    return await this.thor.httpClient.http(
      "GET",
      thorest.transactions.get.TRANSACTION(id),
      {
        query: buildQuery({
          raw: true,
          head: options?.head,
          pending: options?.pending
        })
      }
    );
  }
  /**
   * Retrieves the receipt of a transaction.
   *
   * @param id - Transaction ID of the transaction to retrieve.
   * @param options - (Optional) Other optional parameters for the request.
   *                  If `head` is not specified, the receipt of the transaction at the best block is returned.
   * @returns A promise that resolves to the receipt of the transaction.
   * @throws {InvalidDataType}
   */
  async getTransactionReceipt(id, options) {
    if (!ThorId3.isValid(id)) {
      throw new InvalidDataType9(
        "TransactionsModule.getTransactionReceipt()",
        "Invalid transaction ID given as input. Input must be an hex string of length 64.",
        { id }
      );
    }
    if (options?.head !== void 0 && !ThorId3.isValid(options.head))
      throw new InvalidDataType9(
        "TransactionsModule.getTransaction()",
        "Invalid head given as input. Input must be an hex string of length 64.",
        { head: options?.head }
      );
    return await this.thor.httpClient.http(
      "GET",
      thorest.transactions.get.TRANSACTION_RECEIPT(id),
      {
        query: buildQuery({ head: options?.head })
      }
    );
  }
  /**
   * Retrieves the receipt of a transaction.
   *
   * @param raw - The raw transaction.
   * @returns The transaction id of send transaction.
   * @throws {InvalidDataType}
   */
  async sendRawTransaction(raw) {
    if (!Hex2.isValid0x(raw)) {
      throw new InvalidDataType9(
        "TransactionsModule.sendRawTransaction()",
        "Sending failed: Input must be a valid raw transaction in hex format.",
        { raw }
      );
    }
    try {
      TransactionHandler2.decode(Buffer.from(raw.slice(2), "hex"), true);
    } catch (error) {
      throw new InvalidDataType9(
        "TransactionsModule.sendRawTransaction()",
        "Sending failed: Input must be a valid raw transaction in hex format. Decoding error encountered.",
        { raw },
        error
      );
    }
    const transactionResult = await this.thor.httpClient.http(
      "POST",
      thorest.transactions.post.TRANSACTION(),
      {
        body: { raw }
      }
    );
    return {
      id: transactionResult.id,
      wait: async () => await this.waitForTransaction(transactionResult.id)
    };
  }
  /**
   * Sends a signed transaction to the network.
   *
   * @param signedTx - the transaction to send. It must be signed.
   * @returns A promise that resolves to the transaction ID of the sent transaction.
   * @throws {InvalidDataType}
   */
  async sendTransaction(signedTx) {
    if (!signedTx.isSigned) {
      throw new InvalidDataType9(
        "TransactionsModule.sendTransaction()",
        "Invalid transaction given as input. Transaction must be signed.",
        { signedTx }
      );
    }
    const rawTx = Hex2.of(signedTx.encoded).toString();
    return await this.sendRawTransaction(rawTx);
  }
  /**
   * Waits for a transaction to be included in a block.
   *
   * @param txID - The transaction ID of the transaction to wait for.
   * @param options - Optional parameters for the request. Includes the timeout and interval between requests.
   *                  Both parameters are in milliseconds. If the timeout is not specified, the request will not time out!
   * @returns A promise that resolves to the transaction receipt of the transaction. If the transaction is not included in a block before the timeout,
   *          the promise will resolve to `null`.
   * @throws {InvalidDataType}
   */
  async waitForTransaction(txID, options) {
    if (!ThorId3.isValid(txID)) {
      throw new InvalidDataType9(
        "TransactionsModule.waitForTransaction()",
        "Invalid transaction ID given as input. Input must be an hex string of length 64.",
        { txID }
      );
    }
    return await Poll.SyncPoll(
      async () => await this.thor.transactions.getTransactionReceipt(txID),
      {
        requestIntervalInMilliseconds: options?.intervalMs,
        maximumWaitingTimeInMilliseconds: options?.timeoutMs
      }
    ).waitUntil((result) => {
      return result !== null;
    });
  }
  /**
   * Builds a transaction body with the given clauses without having to
   * specify the chainTag, expiration, gasPriceCoef, gas, dependsOn and reserved fields.
   *
   * @param clauses - The clauses of the transaction.
   * @param gas - The gas to be used to perform the transaction.
   * @param options - Optional parameters for the request. Includes the expiration, gasPriceCoef, dependsOn and isDelegated fields.
   *                  If the `expiration` is not specified, the transaction will expire after 32 blocks.
   *                  If the `gasPriceCoef` is not specified, the transaction will use the default gas price coef of 127.
   *                  If the `dependsOn is` not specified, the transaction will not depend on any other transaction.
   *                  If the `isDelegated` is not specified, the transaction will not be delegated.
   *
   * @returns A promise that resolves to the transaction body.
   *
   * @throws an error if the genesis block or the latest block cannot be retrieved.
   */
  async buildTransactionBody(clauses, gas, options) {
    const genesisBlock = await this.thor.blocks.getBlockCompressed(0);
    if (genesisBlock === null)
      throw new InvalidTransactionField2(
        "TransactionsModule.buildTransactionBody()",
        "Error while building transaction body: Cannot get genesis block.",
        { fieldName: "genesisBlock", genesisBlock, clauses, options }
      );
    const blockRef = options?.blockRef ?? await this.thor.blocks.getBestBlockRef();
    if (blockRef === null)
      throw new InvalidTransactionField2(
        "TransactionsModule.buildTransactionBody()",
        "Error while building transaction body: Cannot get blockRef.",
        { fieldName: "blockRef", blockRef, clauses, options }
      );
    const chainTag = options?.chainTag ?? Number(`0x${genesisBlock.id.slice(64)}`);
    return {
      blockRef,
      chainTag,
      clauses: await this.resolveNamesInClauses(clauses),
      dependsOn: options?.dependsOn ?? null,
      expiration: options?.expiration ?? 32,
      gas,
      gasPriceCoef: options?.gasPriceCoef ?? 0,
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access
      nonce: options?.nonce ?? Hex2.random(8).toString(),
      reserved: options?.isDelegated === true ? { features: 1 } : void 0
    };
  }
  /**
   * Ensures that names in clauses are resolved to addresses
   *
   * @param clauses - The clauses of the transaction.
   * @returns A promise that resolves to clauses with resolved addresses
   */
  async resolveNamesInClauses(clauses) {
    const uniqueNames = clauses.reduce((map, clause) => {
      if (typeof clause.to === "string" && !map.has(clause.to) && clause.to.includes(".")) {
        map.set(clause.to, clause.to);
      }
      return map;
    }, /* @__PURE__ */ new Map());
    const nameList = [...uniqueNames.keys()];
    if (uniqueNames.size === 0) {
      return clauses;
    }
    const addresses = await vnsUtils.resolveNames(this.thor, nameList);
    addresses.forEach((address, index) => {
      if (address !== null) {
        uniqueNames.set(nameList[index], address);
      }
    });
    return clauses.map((clause) => {
      if (typeof clause.to !== "string") {
        return clause;
      }
      return {
        to: uniqueNames.get(clause.to) ?? clause.to,
        data: clause.data,
        value: clause.value
      };
    });
  }
  /**
   * Simulates the execution of a transaction.
   * Allows to estimate the gas cost of a transaction without sending it, as well as to retrieve the return value(s) of the transaction.
   *
   * @param clauses - The clauses of the transaction to simulate.
   * @param options - (Optional) The options for simulating the transaction.
   * @returns A promise that resolves to an array of simulation results.
   *          Each element of the array represents the result of simulating a clause.
   * @throws {InvalidDataType}
   */
  async simulateTransaction(clauses, options) {
    const {
      revision,
      caller,
      gasPrice,
      gasPayer,
      gas,
      blockRef,
      expiration,
      provedWork
    } = options ?? {};
    if (revision !== void 0 && revision !== null && !Revision3.isValid(revision)) {
      throw new InvalidDataType9(
        "TransactionsModule.simulateTransaction()",
        "Invalid revision given as input. Input must be a valid revision (i.e., a block number or block ID).",
        { revision }
      );
    }
    return await this.thor.httpClient.http(
      "POST",
      thorest.accounts.post.SIMULATE_TRANSACTION(revision),
      {
        query: buildQuery({ revision }),
        body: {
          clauses: await this.resolveNamesInClauses(
            clauses.map((clause) => {
              return {
                to: clause.to,
                data: clause.data,
                value: BigInt(clause.value).toString()
              };
            })
          ),
          gas,
          gasPrice,
          caller,
          provedWork,
          gasPayer,
          expiration,
          blockRef
        }
      }
    );
  }
  /**
   * Decode the revert reason from the encoded revert reason into a transaction.
   *
   * @param encodedRevertReason - The encoded revert reason to decode.
   * @param errorFragment - (Optional) The error fragment to use to decode the revert reason (For Solidity custom errors).
   * @returns A promise that resolves to the decoded revert reason.
   * Revert reason can be a string error or Panic(error_code)
   */
  decodeRevertReason(encodedRevertReason, errorFragment) {
    if (encodedRevertReason.startsWith(ERROR_SELECTOR))
      return abi5.decode(
        "string",
        `0x${encodedRevertReason.slice(ERROR_SELECTOR.length)}`
      );
    else if (encodedRevertReason.startsWith(PANIC_SELECTOR)) {
      const decoded = abi5.decode(
        "uint256",
        `0x${encodedRevertReason.slice(PANIC_SELECTOR.length)}`
      );
      return `Panic(0x${parseInt(decoded).toString(16).padStart(2, "0")})`;
    } else {
      if (errorFragment !== void 0) {
        const errorInterface = new vechain_sdk_core_ethers2.Interface([
          vechain_sdk_core_ethers2.ErrorFragment.from(errorFragment)
        ]);
        return errorInterface.decodeErrorResult(
          vechain_sdk_core_ethers2.ErrorFragment.from(
            errorFragment
          ),
          encodedRevertReason
        ).toArray()[0];
      }
    }
    return ``;
  }
  /**
   * Get the revert reason of an existing transaction.
   *
   * @param transactionHash - The hash of the transaction to get the revert reason for.
   * @param errorFragment - (Optional) The error fragment to use to decode the revert reason (For Solidity custom errors).
   * @returns A promise that resolves to the revert reason of the transaction.
   */
  async getRevertReason(transactionHash, errorFragment) {
    const blocksModule = this.thor.blocks;
    const debugModule = this.thor.debug;
    const transaction = await this.getTransaction(transactionHash);
    const block = transaction !== null ? await blocksModule.getBlockExpanded(
      transaction.meta.blockID
    ) : null;
    if (block === null || transaction === null) return null;
    const transactionIndex = getTransactionIndexIntoBlock(
      blocksFormatter.formatToRPCStandard(block, ""),
      transactionHash
    );
    for (let transactionClauseIndex = 0; transactionClauseIndex < transaction.clauses.length; transactionClauseIndex++) {
      const debuggedClause = await debugModule.traceTransactionClause(
        {
          target: {
            blockID: block.id,
            transaction: transactionIndex,
            clauseIndex: transactionClauseIndex
          },
          // Optimized for top call
          config: {
            OnlyTopCall: true
          }
        },
        "call"
      );
      if (debuggedClause.output !== void 0) {
        return this.decodeRevertReason(
          debuggedClause.output,
          errorFragment
        );
      }
    }
    return null;
  }
};

// src/thor-client/transactions/helpers/delegation-handler.ts
import { Hex as Hex3 } from "@vechain/sdk-core";
import { NotDelegatedTransaction } from "@vechain/sdk-errors";
var _getDelegationSignature = async (tx, delegatorUrl, originAddress, httpClient) => {
  const rawTx = Hex3.of(tx.encoded).toString();
  const sponsorRequestBody = {
    origin: originAddress,
    raw: rawTx
  };
  try {
    const response = await httpClient.http("POST", delegatorUrl, {
      body: sponsorRequestBody
    });
    return Buffer.from(response.signature.slice(2), "hex");
  } catch (error) {
    throw new NotDelegatedTransaction(
      "_getDelegationSignature()",
      "Delegation failed: Cannot get signature from delegator.",
      {
        delegatorUrl
      },
      error
    );
  }
};
var DelegationHandler = (delegator) => {
  const delegatorIsUndefined = delegator === void 0 || delegator === null;
  const isDelegatedWithUrl = !delegatorIsUndefined && delegator?.delegatorUrl !== void 0;
  const isDelegatedWithPrivateKey = !delegatorIsUndefined && delegator?.delegatorPrivateKey !== void 0;
  return {
    /**
     * Check if the transaction is delegated.
     *
     * @returns true if the transaction is delegated, false otherwise.
     */
    isDelegated: () => isDelegatedWithUrl || isDelegatedWithPrivateKey,
    /**
     * Get the delegator options or undefined.
     * (if delegator is undefined or null).
     *
     * @returns The delegator options or undefined.
     */
    delegatorOrUndefined: () => delegatorIsUndefined ? void 0 : delegator,
    /**
     * Get the delegator options or null.
     * (if delegator is undefined or null).
     *
     * @returns The delegator options or null.
     */
    delegatorOrNull: () => delegatorIsUndefined ? null : delegator,
    /**
     * Retrieves the signature of a delegation transaction from a delegator given the endpoint
     * from which to retrieve the signature.
     *
     * @see [Simple Gas Payer Standard](https://github.com/vechain/VIPs/blob/master/vips/VIP-201.md)
     *
     * @param tx - The transaction to delegate.
     * @param originAddress - The address of the origin account.
     * @param httpClient - The HTTP client instance used for making HTTP requests.
     * @returns A promise that resolves to the signature of the delegation transaction.
     * @throws {NotDelegatedTransaction}
     */
    getDelegationSignatureUsingUrl: async (tx, originAddress, httpClient) => {
      if (!isDelegatedWithUrl) {
        throw new NotDelegatedTransaction(
          "DelegationHandler.getDelegationSignatureUsingUrl()",
          "Delegation with url failed: delegatorUrl is not defined.",
          void 0
        );
      }
      return await _getDelegationSignature(
        tx,
        delegator?.delegatorUrl,
        originAddress,
        httpClient
      );
    }
  };
};

// src/thor-client/thor-client.ts
var ThorClient = class _ThorClient {
  /**
   * Constructs a new `ThorClient` instance with a given HTTP client.
   *
   * @param httpClient - The HTTP client instance used for making network requests.
   * @param options - (Optional) Other optional parameters for polling and error handling.
   */
  constructor(httpClient, options) {
    this.httpClient = httpClient;
    this.accounts = new AccountsModule(this);
    this.nodes = new NodesModule(this);
    this.blocks = new BlocksModule(this, options);
    this.logs = new LogsModule(this);
    this.transactions = new TransactionsModule(this);
    this.contracts = new ContractsModule(this);
    this.gas = new GasModule(this);
    this.debug = new DebugModule(this);
  }
  /**
   * The `AccountsModule` instance
   */
  accounts;
  /**
   * The `NodesModule` instance
   */
  nodes;
  /**
   * The `BlocksModule` instance
   */
  blocks;
  /**
   * The `LogsModule` instance used for interacting with log-related endpoints.
   */
  logs;
  /*
   * The `TransactionsModule` instance
   */
  transactions;
  /**
   * The 'ContractClient' instance
   */
  contracts;
  /**
   * The `GasModule` instance
   */
  gas;
  /**
   * The `DebugModule` instance
   */
  debug;
  /**
   * Creates a new `ThorClient` instance from a given URL.
   *
   * @param networkUrl - The URL of the network to connect to.
   * @param options - (Optional) Other optional parameters for polling and error handling.
   * @returns A new `ThorClient` instance.
   */
  static fromUrl(networkUrl, options) {
    return new _ThorClient(new HttpClient(networkUrl), options);
  }
  /**
   * Destroys the `ThorClient` instance by stopping the event polling
   * and any other cleanup.
   */
  destroy() {
    this.blocks.destroy();
  }
};

// src/signer/signers/vechain-abstract-signer/vechain-abstract-signer.ts
import {
  Address as Address4,
  clauseBuilder as clauseBuilder4,
  Hex as Hex4,
  HexUInt
} from "@vechain/sdk-core";
import { InvalidDataType as InvalidDataType10, JSONRPCInvalidParams } from "@vechain/sdk-errors";
var VeChainAbstractSigner = class {
  /**
   * The provider attached to this Signer (if any).
   */
  provider;
  /**
   * Create a new VeChainPrivateKeySigner.
   * A signer can be initialized using a private key.
   *
   * @param provider - The provider to connect to
   */
  constructor(provider) {
    this.provider = provider;
  }
  /**
   *  Prepares a {@link TransactionRequestInput} for calling:
   *  - resolves ``to`` and ``from`` addresses
   *  - if ``from`` is specified, check that it matches this Signer
   *
   *  @note: Here the base support of multi-clause transaction is added.
   *  So, if clauses are provided in the transaction, it will be used as it is.
   *  Otherwise, standard transaction will be prepared.
   *
   *  @param transactionToPopulate - The call to prepare
   *  @returns the prepared call transaction
   * @throws {InvalidDataType}
   */
  async populateCall(transactionToPopulate) {
    if (transactionToPopulate.from === void 0 || transactionToPopulate.from === null)
      transactionToPopulate.from = Address4.checksum(
        HexUInt.of(await this.getAddress())
      );
    else {
      if (Address4.checksum(HexUInt.of(transactionToPopulate.from)) !== Address4.checksum(HexUInt.of(await this.getAddress()))) {
        throw new InvalidDataType10(
          "VeChainAbstractSigner.populateCall()",
          "From address does not match the signer address.",
          {
            signerAddress: Address4.checksum(
              HexUInt.of(await this.getAddress())
            ),
            fromAddress: Address4.checksum(
              HexUInt.of(transactionToPopulate.from)
            )
          }
        );
      }
    }
    if (transactionToPopulate.to === void 0)
      transactionToPopulate.to = null;
    if (transactionToPopulate.clauses !== void 0 && transactionToPopulate.clauses.length > 0) {
      transactionToPopulate.to = transactionToPopulate.clauses[0].to;
      transactionToPopulate.value = transactionToPopulate.clauses[0].value;
      transactionToPopulate.data = transactionToPopulate.clauses[0].data;
    }
    return transactionToPopulate;
  }
  /**
   *  Prepares a {@link TransactionRequestInput} for sending to the network by
   *  populating any missing properties:
   *  - resolves ``to`` and ``from`` addresses
   *  - if ``from`` is specified , check that it matches this Signer
   *  - populates ``nonce`` via ``signer.getNonce("pending")``
   *  - populates gas parameters via ``signer.estimateGas(tx)``
   *  - ... and other necessary properties
   *
   *  @param transactionToPopulate - The call to prepare
   *  @returns the prepared transaction
   *  @throws {JSONRPCInvalidParams}
   */
  async populateTransaction(transactionToPopulate) {
    if (this.provider === null) {
      throw new JSONRPCInvalidParams(
        "VechainAbstractSigner.populateTransaction()",
        -32602,
        "Thor client not found into the signer. Please attach a Provider with a thor client to your signer instance.",
        { provider: this.provider }
      );
    }
    const thorClient = this.provider.thorClient;
    const populatedTransaction = await this.populateCall(
      transactionToPopulate
    );
    const totalGasResult = transactionToPopulate.gas !== void 0 ? Number(transactionToPopulate.gas) : await this.estimateGas(transactionToPopulate);
    return await thorClient.transactions.buildTransactionBody(
      populatedTransaction.clauses ?? this._buildClauses(populatedTransaction),
      totalGasResult,
      {
        isDelegated: this.provider?.enableDelegation,
        nonce: populatedTransaction.nonce ?? await this.getNonce("pending"),
        blockRef: populatedTransaction.blockRef ?? void 0,
        chainTag: populatedTransaction.chainTag ?? void 0,
        dependsOn: populatedTransaction.dependsOn ?? void 0,
        expiration: populatedTransaction.expiration,
        gasPriceCoef: populatedTransaction.gasPriceCoef ?? void 0
      }
    );
  }
  /**
   * Estimates the required gas required to execute //tx// on the Blockchain. This
   * will be the expected amount a transaction will require
   * to successfully run all the necessary computations and store the needed state
   * that the transaction intends.
   *
   * @param transactionToEstimate - The transaction to estimate gas for
   * @returns the total estimated gas required
   * @throws {JSONRPCInvalidParams}
   */
  async estimateGas(transactionToEstimate) {
    if (this.provider === null) {
      throw new JSONRPCInvalidParams(
        "VechainAbstractSigner.estimateGas()",
        -32602,
        "Thor client not found into the signer. Please attach a Provider with a thor client to your signer instance.",
        { provider: this.provider }
      );
    }
    const thorClient = this.provider.thorClient;
    const populatedTransaction = await this.populateCall(
      transactionToEstimate
    );
    const gasEstimation = await thorClient.gas.estimateGas(
      populatedTransaction.clauses ?? this._buildClauses(populatedTransaction),
      populatedTransaction.from
    );
    return gasEstimation.totalGas;
  }
  /**
   * Evaluates the //tx// by running it against the current Blockchain state. This
   * cannot change state and has no cost, as it is effectively simulating
   * execution.
   *
   * This can be used to have the Blockchain perform computations based on its state
   * (e.g. running a Contract's getters) or to simulate the effect of a transaction
   * before actually performing an operation.
   *
   * @param transactionToEvaluate - The transaction to evaluate
   * @param revision - The block number or block ID of which the transaction simulation is based on
   * @returns the result of the evaluation
   * @throws {JSONRPCInvalidParams}
   */
  async call(transactionToEvaluate, revision) {
    if (this.provider === null) {
      throw new JSONRPCInvalidParams(
        "VechainAbstractSigner.call()",
        -32602,
        "Thor client not found into the signer. Please attach a Provider with a thor client to your signer instance.",
        { provider: this.provider }
      );
    }
    const thorClient = this.provider.thorClient;
    const populatedTransaction = await this.populateCall(
      transactionToEvaluate
    );
    const simulation = await thorClient.transactions.simulateTransaction(
      populatedTransaction.clauses ?? this._buildClauses(populatedTransaction),
      {
        revision: revision ?? void 0,
        gas: populatedTransaction.gas ?? void 0,
        gasPrice: populatedTransaction.gasPrice ?? void 0,
        caller: populatedTransaction.from,
        provedWork: populatedTransaction.provedWork ?? void 0,
        gasPayer: populatedTransaction.gasPayer ?? void 0,
        expiration: populatedTransaction.expiration ?? void 0,
        blockRef: populatedTransaction.blockRef ?? void 0
      }
    );
    return simulation[0].data;
  }
  /**
   *  Gets the next nonce required for this Signer to send a transaction.
   *
   *  @param blockTag - The blocktag to base the transaction count on, keep in mind
   *         many nodes do not honour this value and silently ignore it [default: ``"latest"``]
   *
   *  @NOTE: This method generates a random number as nonce. It is because the nonce in VeChain is a 6-byte number.
   */
  async getNonce(blockTag) {
    if (this.provider !== null) {
      return await this.provider.request({
        method: "eth_getTransactionCount" /* eth_getTransactionCount */,
        params: [await this.getAddress(), blockTag]
      });
    }
    return Hex4.random(6).toString();
  }
  /**
   * Use vet.domains to resolve name to address
   * @param vnsName - The name to resolve
   * @returns the address for a name or null
   */
  async resolveName(vnsName) {
    if (this.provider === null) {
      return null;
    }
    return await vnsUtils.resolveName(this.provider.thorClient, vnsName);
  }
  /**
   * Build the transaction clauses
   * form a transaction given as input
   *
   * @param transaction - The transaction to sign
   * @returns The transaction clauses
   */
  _buildClauses(transaction) {
    return transaction.to !== void 0 && transaction.to !== null ? (
      // Normal transaction
      [
        {
          to: transaction.to,
          data: transaction.data ?? "0x",
          value: transaction.value ?? "0x0"
        }
      ]
    ) : (
      // If 'to' address is not provided, it will be assumed that the transaction is a contract creation transaction.
      [clauseBuilder4.deployContract(transaction.data ?? "0x")]
    );
  }
};

// src/signer/signers/vechain-private-key-signer/vechain-private-key-signer.ts
var VeChainPrivateKeySigner = class _VeChainPrivateKeySigner extends VeChainAbstractSigner {
  /**
   * Create a new VeChainPrivateKeySigner.
   * A signer can be initialized using a private key.
   *
   * @param privateKey - The private key of the signer
   * @param provider - The provider to connect to
   */
  constructor(privateKey, provider) {
    if (!secp256k1.isValidPrivateKey(privateKey)) {
      throw new InvalidSecp256k1PrivateKey(
        `VeChainPrivateKeySigner.constructor()`,
        "Invalid private key used to sign initialize the signer. Ensure it's a valid secp256k1 private key.",
        void 0
      );
    }
    super(provider);
    this.privateKey = privateKey;
  }
  MESSAGE_PREFIX = Txt3.of("Ethereum Signed Message:\n").bytes;
  /**
   *  Returns a new instance of this Signer connected to //provider// or detached
   *  from any Provider if null.
   *
   * @param provider - The provider to connect to
   * @returns a new instance of this Signer connected to //provider// or detached
   */
  connect(provider) {
    return new _VeChainPrivateKeySigner(this.privateKey, provider);
  }
  /**
   * Get the address of the Signer.
   *
   * @returns the address of the signer
   */
  async getAddress() {
    return Address5.checksum(
      HexUInt2.of(
        await Promise.resolve(
          Address5.ofPrivateKey(this.privateKey).toString()
        )
      )
    );
  }
  /**
   * Signs %%transactionToSign%%, returning the fully signed transaction. This does not
   * populate any additional properties with eth_getTransactionCount: RPC_METHODS, p0: (string | undefined)[], args: EIP1193RequestArguments* @param transactionToSign - The transaction to sign
   * @returns The fully signed transaction
   */
  async signTransaction(transactionToSign) {
    if (this.provider === null) {
      throw new JSONRPCInvalidParams2(
        "VeChainPrivateKeySigner.signTransaction()",
        -32602,
        "Thor provider is not found into the signer. Please attach a Provider to your signer instance.",
        { transactionToSign }
      );
    }
    return await this._signFlow(
      transactionToSign,
      DelegationHandler(
        await this.provider?.wallet?.getDelegator()
      ).delegatorOrNull(),
      this.provider.thorClient
    );
  }
  /**
   * --- START: TEMPORARY COMMENT ---
   * Probably add in the future with vechain_sdk_core_ethers.TransactionRequest as a return type
   * --- END: TEMPORARY COMMENT ---
   *
   *  Sends %%transactionToSend%% to the Network. The ``signer.populateTransaction(transactionToSend)``
   *  is called first to ensure all necessary properties for the
   *  transaction to be valid have been populated first.
   *
   *  @param transactionToSend - The transaction to send
   *  @returns The transaction response
   * @throws {JSONRPCInvalidParams}
   */
  async sendTransaction(transactionToSend) {
    if (this.provider === null) {
      throw new JSONRPCInvalidParams2(
        "VeChainPrivateKeySigner.sendTransaction()",
        -32602,
        "Thor provider is not found into the signer. Please attach a Provider to your signer instance.",
        { transactionToSend }
      );
    }
    const provider = this.provider;
    const signedTransaction = await this.signTransaction(transactionToSend);
    return await provider.request({
      method: "eth_sendRawTransaction" /* eth_sendRawTransaction */,
      params: [signedTransaction]
    });
  }
  /**
   * Signs an [EIP-191](https://eips.ethereum.org/EIPS/eip-191) prefixed a personal message.
   *
   * This function is a drop-in replacement for {@link ethers.BaseWallet.signMessage} function.
   *
   * @param {string|Uint8Array} message - The message to be signed.
   *                                      If the %%message%% is a string, it is signed as UTF-8 encoded bytes.
   *                                      It is **not** interpreted as a [[BytesLike]];
   *                                      so the string ``"0x1234"`` is signed as six characters, **not** two bytes.
   * @return {Promise<string>} - A Promise that resolves to the signature as a string.
   */
  async signMessage(message) {
    return await new Promise((resolve, reject) => {
      try {
        const body = typeof message === "string" ? Txt3.of(message).bytes : message;
        const sign = secp256k1.sign(
          Keccak2563.of(
            concatBytes(
              this.MESSAGE_PREFIX,
              Txt3.of(body.length).bytes,
              body
            )
          ).bytes,
          new Uint8Array(this.privateKey)
        );
        sign[sign.length - 1] += 27;
        resolve(Hex5.of(sign).toString());
      } catch (e) {
        reject(e);
      }
    });
  }
  /**
   * Signs the [[link-eip-712]] typed data.
   *
   * This function is a drop-in replacement for {@link ethers.BaseWallet.signTypedData} function,
   * albeit Ethereum Name Services are not resolved because he resolution depends on **ethers** provider implementation.
   *
   * @param {ethers.TypedDataDomain} domain - The domain parameters used for signing.
   * @param {Record<string, ethers.TypedDataField[]>} types - The types used for signing.
   * @param {Record<string, unknown>} value - The value data to be signed.
   *
   * @return {Promise<string>} - A promise that resolves with the signature string.
   */
  async signTypedData(domain, types, value) {
    return await new Promise((resolve, reject) => {
      try {
        const hash = Hex5.of(
          vechain_sdk_core_ethers3.TypedDataEncoder.hash(
            domain,
            types,
            value
          )
        ).bytes;
        const sign = secp256k1.sign(
          hash,
          new Uint8Array(this.privateKey)
        );
        sign[sign.length - 1] += 27;
        resolve(Hex5.of(sign).toString());
      } catch (e) {
        reject(e);
      }
    });
  }
  /**
   * Signs a transaction internal method
   *
   * @param transaction - The transaction to sign
   * @param delegator - The delegator to use
   * @param thorClient - The ThorClient instance
   * @returns The fully signed transaction
   * @throws {InvalidSecp256k1PrivateKey, InvalidDataType}
   */
  async _signFlow(transaction, delegator, thorClient) {
    const populatedTransaction = await this.populateTransaction(transaction);
    return delegator !== null ? await this._signWithDelegator(
      populatedTransaction,
      this.privateKey,
      thorClient,
      delegator
    ) : Hex5.of(
      TransactionHandler3.sign(populatedTransaction, this.privateKey).encoded
    ).toString();
  }
  /**
   * Signs a transaction where the gas fee is paid by a delegator.
   *
   * @param unsignedTransactionBody - The unsigned transaction body to sign.
   * @param originPrivateKey - The private key of the origin account.
   * @param  - (Optional) The private key of the delegator account.
   * @param thorClient - The ThorClient instance.
   * @param delegatorOptions - Optional parameters for the request. Includes the `delegatorUrl` and `delegatorPrivateKey` fields.
   *                  Only one of the following options can be specified: `delegatorUrl`, `delegatorPrivateKey`.
   * @returns A promise that resolves to the signed transaction.
   * @throws {NotDelegatedTransaction}
   */
  async _signWithDelegator(unsignedTransactionBody, originPrivateKey, thorClient, delegatorOptions) {
    const originAddress = Address5.ofPrivateKey(originPrivateKey).toString();
    const unsignedTx = new Transaction(unsignedTransactionBody);
    if (delegatorOptions?.delegatorPrivateKey !== void 0)
      return Hex5.of(
        TransactionHandler3.signWithDelegator(
          unsignedTransactionBody,
          originPrivateKey,
          Buffer.from(delegatorOptions?.delegatorPrivateKey, "hex")
        ).encoded
      ).toString();
    const delegatorSignature = await DelegationHandler(
      delegatorOptions
    ).getDelegationSignatureUsingUrl(
      unsignedTx,
      originAddress,
      thorClient.httpClient
    );
    const originSignature = secp256k1.sign(
      unsignedTx.getSignatureHash(),
      originPrivateKey
    );
    const signature = Buffer.concat([originSignature, delegatorSignature]);
    return Hex5.of(
      new Transaction(unsignedTx.body, signature).encoded
    ).toString();
  }
};

// src/provider/helpers/provider-internal-wallets/abstract-wallet/abstract-provider-internal-wallet.ts
var AbstractProviderInternalWallet = class {
  /**
   * List of accounts in the wallet.
   */
  accounts;
  /**
   * Options for signing a transaction with delegator.
   */
  delegator;
  /**
   * Create a new wallet.
   *
   * @param accounts List of accounts in the wallet.
   * @param options Optional options for signing a transaction with delegator.
   */
  constructor(accounts, options) {
    this.accounts = accounts;
    this.delegator = options?.delegator;
  }
  /**
   * SYNC Version of getSigner()
   *
   * Get a signer into the internal wallet provider
   * for the given address.
   *
   * @param parentProvider - The parent provider of the Internal Wallet.
   * @param addressOrIndex - Address or index of the account.
   * @returns The signer for the given address.
   */
  getSignerSync(parentProvider, addressOrIndex) {
    const signerAccount = this.getAccountSync(addressOrIndex);
    if (signerAccount?.privateKey !== void 0) {
      return new VeChainPrivateKeySigner(
        signerAccount.privateKey,
        parentProvider
      );
    }
    return null;
  }
  /**
   * SYNC Version of getAddresses()
   *
   * Get the list of addresses in the wallet.
   *
   * @returns The list of addresses in the wallet.
   */
  getAddressesSync() {
    return this.accounts.map((account) => account.address);
  }
  /**
   * SYNC Version of getAccount()
   *
   * Get an account given an address or an index.
   *
   * @param addressOrIndex - Address or index of the account.
   * @returns The account with the given address, or null if not found.
   * @throws {InvalidDataType}
   */
  getAccountSync(addressOrIndex) {
    if (addressOrIndex === void 0 || typeof addressOrIndex === "number") {
      return this.accounts[addressOrIndex ?? 0] ?? null;
    }
    if (!Address6.isValid(addressOrIndex)) {
      throw new InvalidDataType11(
        "AbstractProviderInternalWallet.getAccountSync()",
        "Invalid params expected an address.",
        { addressOrIndex }
      );
    }
    const account = this.accounts.find(
      (account2) => Address6.checksum(HexUInt3.of(account2.address)) === Address6.checksum(HexUInt3.of(addressOrIndex))
    );
    return account ?? null;
  }
  /**
   * SYNC Version of getDelegator()
   *
   * Get the options for signing a transaction with delegator (if any).
   *
   * @returns The options for signing a transaction with delegator.
   */
  getDelegatorSync() {
    return DelegationHandler(this.delegator).delegatorOrNull();
  }
};

// src/provider/helpers/provider-internal-wallets/base-wallet/provider-internal-base-wallet.ts
var ProviderInternalBaseWallet = class extends AbstractProviderInternalWallet {
  /**
   * Get a signer into the internal wallet provider
   * for the given address.
   *
   * @param parentProvider - The parent provider of the Internal Wallet.
   * @param addressOrIndex - Address of the account.
   * @returns The signer for the given address.
   */
  async getSigner(parentProvider, addressOrIndex) {
    return await Promise.resolve(
      this.getSignerSync(parentProvider, addressOrIndex)
    );
  }
  /**
   * Get the list of addresses in the wallet.
   *
   * @returns The list of addresses in the wallet.
   */
  async getAddresses() {
    return await Promise.resolve(this.getAddressesSync());
  }
  /**
   * Get an account given an address or an index.
   *
   * @param addressOrIndex - Address or index of the account.
   * @returns The account with the given address, or null if not found.
   */
  async getAccount(addressOrIndex) {
    return await Promise.resolve(this.getAccountSync(addressOrIndex));
  }
  /**
   * Get the options for signing a transaction with delegator (if any).
   *
   * @returns The options for signing a transaction with delegator.
   */
  async getDelegator() {
    return await Promise.resolve(this.getDelegatorSync());
  }
};

// src/provider/helpers/provider-internal-wallets/hd-wallet/provider-internal-hd-wallet.ts
import {
  Address as Address7,
  HDNode,
  secp256k1 as secp256k12,
  VET_DERIVATION_PATH
} from "@vechain/sdk-core";
var ProviderInternalHDWallet = class extends ProviderInternalBaseWallet {
  /**
   * Mnemonic of the wallet.
   */
  mnemonic;
  /**
   * Derivation path of the wallet.
   */
  derivationPath;
  /**
   * Number of accounts to generate.
   */
  count;
  /**
   * Initial index of the accounts to generate.
   */
  initialIndex;
  /**
   * Create a new HD wallet.
   *
   * @param mnemonic - Mnemonic of the wallet as an array of words.
   * @param count - Number of accounts to generate.
   * @param initialIndex - Initial index of the accounts to generate.
   * @param derivationPath - Derivation path of the wallet.
   * @param options - Options for signing a transaction with delegator.
   */
  constructor(mnemonic, count = 1, initialIndex = 0, derivationPath = VET_DERIVATION_PATH, options) {
    super(
      [...Array(count).keys()].map((path) => {
        const privateKeyBuffer = HDNode.fromMnemonic(
          mnemonic,
          derivationPath
        ).deriveChild(path + initialIndex).privateKey;
        return {
          privateKey: privateKeyBuffer,
          publicKey: Buffer.from(
            secp256k12.derivePublicKey(privateKeyBuffer)
          ),
          address: Address7.ofPrivateKey(privateKeyBuffer).toString()
        };
      }),
      options
    );
    this.mnemonic = mnemonic;
    this.derivationPath = derivationPath;
    this.count = count;
    this.initialIndex = initialIndex;
  }
};

// src/provider/providers/ethers-provider/json-rpc-ethers-provider.ts
import { vechain_sdk_core_ethers as vechain_sdk_core_ethers4 } from "@vechain/sdk-core";
import { stringifyData as stringifyData2 } from "@vechain/sdk-errors";
var JSONRPCEthersProvider = class extends vechain_sdk_core_ethers4.JsonRpcApiProvider {
  /**
   * Instance of Hardhat VeChain provider to wrap
   */
  hardhatProvider;
  /**
   * Constructor with parameters.
   *
   * @param chainId - The chain id of the network
   * @param networkName - The name of the network
   * @param hardhatProvider - The hardhat provider to wrap
   */
  constructor(chainId, networkName, hardhatProvider) {
    super({ name: networkName, chainId });
    this.hardhatProvider = hardhatProvider;
  }
  /**
   * Override the send method to use the hardhat provider and to call _start method.
   *
   * @param method - The method to call
   * @param params - The parameters of the method
   */
  async send(method, params) {
    this._start();
    return await super.send(method, params);
  }
  /**
   * Internal method to send the payload to the hardhat provider.
   * This method is able to send multiple payloads. (send in batch)
   *
   * @param payload - The payload to send (request and method)'s
   */
  async _send(payload) {
    const requestPayloadArray = Array.isArray(payload) ? payload : [payload];
    const responses = [];
    for (const jsonRpcPayload of requestPayloadArray) {
      try {
        const result = await this.hardhatProvider.send(
          jsonRpcPayload.method,
          jsonRpcPayload.params
        );
        responses.push({
          id: jsonRpcPayload.id,
          result
        });
      } catch (e) {
        responses.push({
          id: jsonRpcPayload.id,
          error: {
            code: -32603,
            message: stringifyData2(e)
          }
        });
      }
    }
    return responses;
  }
};

// src/provider/providers/vechain-provider/vechain-provider.ts
import { EventEmitter as EventEmitter2 } from "events";
import {
  JSONRPCInvalidParams as JSONRPCInvalidParams22,
  JSONRPCMethodNotFound
} from "@vechain/sdk-errors";

// src/provider/utils/const/rpc-mapper/rpc-methods.ts
var RPC_METHODS = /* @__PURE__ */ ((RPC_METHODS2) => {
  RPC_METHODS2["eth_blockNumber"] = "eth_blockNumber";
  RPC_METHODS2["eth_chainId"] = "eth_chainId";
  RPC_METHODS2["eth_getBalance"] = "eth_getBalance";
  RPC_METHODS2["eth_getCode"] = "eth_getCode";
  RPC_METHODS2["eth_getStorageAt"] = "eth_getStorageAt";
  RPC_METHODS2["eth_estimateGas"] = "eth_estimateGas";
  RPC_METHODS2["eth_call"] = "eth_call";
  RPC_METHODS2["eth_sendRawTransaction"] = "eth_sendRawTransaction";
  RPC_METHODS2["eth_getLogs"] = "eth_getLogs";
  RPC_METHODS2["eth_getBlockByHash"] = "eth_getBlockByHash";
  RPC_METHODS2["eth_getBlockByNumber"] = "eth_getBlockByNumber";
  RPC_METHODS2["eth_accounts"] = "eth_accounts";
  RPC_METHODS2["eth_requestAccounts"] = "eth_requestAccounts";
  RPC_METHODS2["eth_gasPrice"] = "eth_gasPrice";
  RPC_METHODS2["eth_getTransactionByHash"] = "eth_getTransactionByHash";
  RPC_METHODS2["eth_getTransactionCount"] = "eth_getTransactionCount";
  RPC_METHODS2["eth_getTransactionReceipt"] = "eth_getTransactionReceipt";
  RPC_METHODS2["eth_sendTransaction"] = "eth_sendTransaction";
  RPC_METHODS2["eth_syncing"] = "eth_syncing";
  RPC_METHODS2["net_version"] = "net_version";
  RPC_METHODS2["web3_clientVersion"] = "web3_clientVersion";
  RPC_METHODS2["eth_subscribe"] = "eth_subscribe";
  RPC_METHODS2["eth_unsubscribe"] = "eth_unsubscribe";
  RPC_METHODS2["debug_traceTransaction"] = "debug_traceTransaction";
  RPC_METHODS2["debug_traceCall"] = "debug_traceCall";
  RPC_METHODS2["evm_mine"] = "evm_mine";
  RPC_METHODS2["eth_coinbase"] = "eth_coinbase";
  RPC_METHODS2["eth_feeHistory"] = "eth_feeHistory";
  RPC_METHODS2["eth_getBlockTransactionCountByHash"] = "eth_getBlockTransactionCountByHash";
  RPC_METHODS2["eth_getBlockTransactionCountByNumber"] = "eth_getBlockTransactionCountByNumber";
  RPC_METHODS2["eth_getTransactionByBlockHashAndIndex"] = "eth_getTransactionByBlockHashAndIndex";
  RPC_METHODS2["eth_getTransactionByBlockNumberAndIndex"] = "eth_getTransactionByBlockNumberAndIndex";
  RPC_METHODS2["eth_getUncleByBlockHashAndIndex"] = "eth_getUncleByBlockHashAndIndex";
  RPC_METHODS2["eth_getUncleByBlockNumberAndIndex"] = "eth_getUncleByBlockNumberAndIndex";
  RPC_METHODS2["eth_getUncleCountByBlockHash"] = "eth_getUncleCountByBlockHash";
  RPC_METHODS2["eth_getUncleCountByBlockNumber"] = "eth_getUncleCountByBlockNumber";
  RPC_METHODS2["eth_getWork"] = "eth_getWork";
  RPC_METHODS2["eth_mining"] = "eth_mining";
  RPC_METHODS2["eth_hashrate"] = "eth_hashrate";
  RPC_METHODS2["eth_protocolVersion"] = "eth_protocolVersion";
  RPC_METHODS2["eth_sign"] = "eth_sign";
  RPC_METHODS2["eth_submitWork"] = "eth_submitWork";
  RPC_METHODS2["net_listening"] = "net_listening";
  RPC_METHODS2["net_peerCount"] = "net_peerCount";
  RPC_METHODS2["parity_nextNonce"] = "parity_nextNonce";
  RPC_METHODS2["eth_newFilter"] = "eth_newFilter";
  RPC_METHODS2["eth_newBlockFilter"] = "eth_newBlockFilter";
  RPC_METHODS2["eth_newPendingTransactionFilter"] = "eth_newPendingTransactionFilter";
  RPC_METHODS2["eth_getFilterLogs"] = "eth_getFilterLogs";
  RPC_METHODS2["eth_getFilterChanges"] = "eth_getFilterChanges";
  RPC_METHODS2["eth_uninstallFilter"] = "eth_uninstallFilter";
  RPC_METHODS2["debug_getBadBlocks"] = "debug_getBadBlocks";
  RPC_METHODS2["debug_getRawBlock"] = "debug_getRawBlock";
  RPC_METHODS2["debug_getRawHeader"] = "debug_getRawHeader";
  RPC_METHODS2["debug_getRawReceipts"] = "debug_getRawReceipts";
  RPC_METHODS2["debug_getRawTransaction"] = "debug_getRawTransaction";
  RPC_METHODS2["engine_exchangeCapabilities"] = "engine_exchangeCapabilities";
  RPC_METHODS2["engine_exchangeTransitionConfigurationV1"] = "engine_exchangeTransitionConfigurationV1";
  RPC_METHODS2["engine_forkchoiceUpdatedV1"] = "engine_forkchoiceUpdatedV1";
  RPC_METHODS2["engine_forkchoiceUpdatedV2"] = "engine_forkchoiceUpdatedV2";
  RPC_METHODS2["engine_forkchoiceUpdatedV3"] = "engine_forkchoiceUpdatedV3";
  RPC_METHODS2["engine_getPayloadBodiesByHashV1"] = "engine_getPayloadBodiesByHashV1";
  RPC_METHODS2["engine_getPayloadBodiesByRangeV1"] = "engine_getPayloadBodiesByRangeV1";
  RPC_METHODS2["engine_getPayloadV1"] = "engine_getPayloadV1";
  RPC_METHODS2["engine_getPayloadV2"] = "engine_getPayloadV2";
  RPC_METHODS2["engine_getPayloadV3"] = "engine_getPayloadV3";
  RPC_METHODS2["engine_newPayloadV1"] = "engine_newPayloadV1";
  RPC_METHODS2["engine_newPayloadV2"] = "engine_newPayloadV2";
  RPC_METHODS2["engine_newPayloadV3"] = "engine_newPayloadV3";
  RPC_METHODS2["eth_createAccessList"] = "eth_createAccessList";
  RPC_METHODS2["eth_getBlockReceipts"] = "eth_getBlockReceipts";
  RPC_METHODS2["eth_getProof"] = "eth_getProof";
  RPC_METHODS2["eth_maxPriorityFeePerGas"] = "eth_maxPriorityFeePerGas";
  RPC_METHODS2["eth_signTransaction"] = "eth_signTransaction";
  return RPC_METHODS2;
})(RPC_METHODS || {});

// src/provider/utils/const/providers/const.ts
var POLLING_INTERVAL = 5e3;

// src/provider/utils/const/blocks/blocks.ts
import { Hex as Hex6 } from "@vechain/sdk-core";
var getCorrectBlockNumberRPCToVeChain = (block) => {
  if (typeof block === "string") {
    if (block === "latest" || block === "finalized" || block === "safe" || block === "pending")
      return "best";
    if (block === "earliest") return Hex6.of(0).toString();
    return block;
  }
  if (block.blockNumber !== void 0) {
    return Hex6.of(block.blockNumber).toString();
  }
  return block.blockHash;
};

// src/provider/utils/const/chain-id/chain-id.ts
var CHAIN_ID = {
  MAINNET: "0x186a9",
  TESTNET: "0x186aa"
};

// src/provider/utils/formatter/blocks/formatter.ts
import { HexUInt as HexUInt5, Quantity as Quantity2, ZERO_BYTES as ZERO_BYTES2 } from "@vechain/sdk-core";

// src/provider/utils/formatter/transactions/formatter.ts
import { Hex as Hex7, HexUInt as HexUInt4, Quantity, ZERO_BYTES } from "@vechain/sdk-core";

// src/provider/utils/helpers/transaction/transaction-helpers.ts
import { InvalidDataType as InvalidDataType12 } from "@vechain/sdk-errors";
var getTransactionIndexIntoBlock = (block, hash) => {
  const idx = typeof block.transactions[0] === "string" ? block.transactions.findIndex(
    (tx) => tx === hash
  ) : block.transactions.findIndex(
    (tx) => tx.hash === hash
  );
  if (idx === -1) {
    throw new InvalidDataType12(
      "getTransactionIndexIntoBlock()",
      "Transaction not found in block.",
      { block, hash }
    );
  }
  return idx;
};
var getNumberOfLogsAheadOfTransactionIntoBlockExpanded = (blockExpanded, transactionId, chainId) => {
  const transactionIndex = getTransactionIndexIntoBlock(
    blocksFormatter.formatToRPCStandard(blockExpanded, chainId),
    transactionId
  );
  let logIndex = 0;
  for (let i = 0; i < transactionIndex; i++) {
    const currentTransaction = blockExpanded.transactions[i];
    for (const output of currentTransaction.outputs) {
      logIndex += output.events.length;
    }
  }
  return logIndex;
};

// src/provider/utils/formatter/transactions/formatter.ts
var _formatTransactionToRPC = (tx, blockHash, blockNumber, chainId, txIndex) => {
  return {
    // Supported fields
    blockHash,
    blockNumber: Quantity.of(blockNumber).toString(),
    from: tx.origin,
    gas: Quantity.of(HexUInt4.of(tx.gas).bi).toString(),
    chainId,
    hash: tx.id,
    nonce: tx.nonce,
    transactionIndex: Quantity.of(txIndex).toString(),
    /**
     * `input`, `to`, `value` are being referred to the first clause.
     *VeChain supports multiple clauses in one transaction, thus the actual data should be obtained by looking into each clause.
     * Due to the single clause limitation of Ethereum, we assume the first clause is the clause from which we obtain the data.
     */
    input: tx.clauses[0]?.data !== void 0 ? tx.clauses[0].data : "",
    to: tx.clauses[0]?.to !== void 0 ? tx.clauses[0].to : null,
    value: tx.clauses[0]?.value !== void 0 ? Quantity.of(HexUInt4.of(tx.clauses[0].value).bi).toString() : "",
    // Unsupported fields
    gasPrice: "0x0",
    type: "0x0",
    v: "0x0",
    r: "0x0",
    s: "0x0",
    accessList: [],
    maxFeePerGas: "0x0",
    maxPriorityFeePerGas: "0x0",
    yParity: "0x0"
  };
};
var formatToRPCStandard = (tx, chainId, txIndex) => {
  return _formatTransactionToRPC(
    tx,
    tx.meta.blockID,
    tx.meta.blockNumber,
    chainId,
    txIndex
  );
};
var formatExpandedBlockToRPCStandard = (tx, block, txIndex, chainId) => {
  return _formatTransactionToRPC(
    tx,
    block.id,
    block.number,
    chainId,
    txIndex
  );
};
function formatTransactionReceiptToRPCStandard(transactionHash, receipt, transaction, blockContainsTransaction, chainId) {
  const transactionIndex = getTransactionIndexIntoBlock(
    blocksFormatter.formatToRPCStandard(blockContainsTransaction, chainId),
    transactionHash
  );
  const logIndexOffset = getNumberOfLogsAheadOfTransactionIntoBlockExpanded(
    blockContainsTransaction,
    transactionHash,
    chainId
  );
  const logs = [];
  let logIndex = logIndexOffset;
  receipt.outputs.forEach((output) => {
    output.events.forEach((event) => {
      logs.push({
        blockHash: receipt.meta.blockID,
        blockNumber: Quantity.of(receipt.meta.blockNumber).toString(),
        transactionHash: receipt.meta.txID,
        address: event.address,
        topics: event.topics.map((topic) => topic),
        data: event.data,
        removed: false,
        transactionIndex: Quantity.of(transactionIndex).toString(),
        logIndex: Quantity.of(logIndex).toString()
      });
      logIndex++;
    });
  });
  return {
    blockHash: receipt.meta.blockID,
    blockNumber: Quantity.of(receipt.meta.blockNumber).toString(),
    contractAddress: receipt.outputs.length > 0 ? receipt.outputs[0].contractAddress : null,
    from: transaction.origin,
    gasUsed: Quantity.of(receipt.gasUsed).toString(),
    logs,
    status: receipt.reverted ? "0x0" : "0x1",
    to: transaction.clauses[0].to,
    transactionHash: receipt.meta.txID,
    transactionIndex: Quantity.of(transactionIndex).toString(),
    // Incompatible fields
    logsBloom: Hex7.of(ZERO_BYTES(256)).toString(),
    cumulativeGasUsed: "0x0",
    effectiveGasPrice: "0x0",
    type: "0x0"
  };
}

// src/provider/utils/formatter/transactions/index.ts
var transactionsFormatter = {
  formatToRPCStandard,
  formatExpandedBlockToRPCStandard,
  formatTransactionReceiptToRPCStandard
};

// src/provider/utils/formatter/blocks/formatter.ts
var formatToRPCStandard2 = (block, chainId) => {
  const transactions = typeof block.transactions[0] === "string" ? block.transactions : block.transactions.map((tx, index) => {
    return transactionsFormatter.formatExpandedBlockToRPCStandard(
      tx,
      block,
      index,
      chainId
    );
  });
  return {
    // Supported fields converted to RPC standard
    hash: block.id,
    parentHash: block.parentID,
    number: Quantity2.of(block.number).toString(),
    size: Quantity2.of(block.size).toString(),
    stateRoot: block.stateRoot,
    receiptsRoot: block.receiptsRoot,
    transactionsRoot: block.txsRoot,
    timestamp: Quantity2.of(block.timestamp).toString(),
    gasLimit: Quantity2.of(block.gasLimit).toString(),
    gasUsed: Quantity2.of(block.gasUsed).toString(),
    transactions,
    miner: block.beneficiary,
    // Unsupported fields
    difficulty: "0x0",
    totalDifficulty: "0x0",
    uncles: [],
    sha3Uncles: HexUInt5.of(ZERO_BYTES2(32)).toString(),
    nonce: HexUInt5.of(ZERO_BYTES2(8)).toString(),
    logsBloom: HexUInt5.of(ZERO_BYTES2(256)).toString(),
    extraData: "0x",
    baseFeePerGas: "0x0",
    mixHash: HexUInt5.of(ZERO_BYTES2(32)).toString()
  };
};

// src/provider/utils/formatter/blocks/index.ts
var blocksFormatter = { formatToRPCStandard: formatToRPCStandard2 };

// src/provider/utils/formatter/debug/formatter.ts
function formatToRPCStandard3(tracerName, debugDetails) {
  if (tracerName === "call") {
    return {
      ...debugDetails,
      // Empty revert reason
      revertReason: ""
    };
  }
  return Object.fromEntries(
    Object.entries(debugDetails).map(
      ([key, value]) => {
        const valueWithoutEnergy = {
          balance: value.balance,
          code: value.code,
          storage: value.storage
        };
        return [key, { ...valueWithoutEnergy, nonce: 0 }];
      }
    )
  );
}

// src/provider/utils/formatter/debug/index.ts
var debugFormatter = {
  formatToRPCStandard: formatToRPCStandard3
};

// src/provider/utils/formatter/logs/formatter.ts
import { HexInt } from "@vechain/sdk-core";
var formatToLogsRPC = (eventLogs) => {
  return eventLogs.map((eventLog) => {
    return {
      address: eventLog.address,
      blockHash: eventLog.meta.blockID,
      blockNumber: HexInt.of(eventLog.meta.blockNumber).toString(),
      data: eventLog.data,
      logIndex: "0x0",
      // Always false for now
      removed: false,
      topics: eventLog.topics,
      transactionHash: eventLog.meta.txID,
      transactionIndex: "0x0"
      // @NOTE: logIndex and transactionIndex are not implemented yet. This for performance reasons.
      //
      /**
       * @NOTE: These two fields are not implemented yet.
       * This for performance reasons.
       * We can implement them later if needed.
       *
       * To have these two fields, we need to query a block for each entry into the logs.
       * After from the block, we can get the transaction index and the log index.
       * This is a performance issue because we have to query a block for each entry into the logs.
       */
    };
  });
};
var _scatterArrayTopic = (criteriaTopicsArray, address) => {
  return {
    address,
    topic0: criteriaTopicsArray[0] ?? void 0,
    topic1: criteriaTopicsArray[1] ?? void 0,
    topic2: criteriaTopicsArray[2] ?? void 0,
    topic3: criteriaTopicsArray[3] ?? void 0,
    topic4: criteriaTopicsArray[4] ?? void 0
  };
};
var getCriteriaSetForInput = (criteria) => {
  let criteriaAddress = [];
  if (criteria.address !== void 0) {
    criteriaAddress = typeof criteria.address === "string" ? [criteria.address] : criteria.address;
  } else {
    criteriaAddress = [void 0];
  }
  const eventsCriteriaToFlat = criteriaAddress.map(
    (addr) => {
      return getTopicsPerAddress(addr, criteria.topics ?? []);
    }
  );
  return eventsCriteriaToFlat.flat();
};
var getTopicsPerAddress = (address, topics) => {
  const notArrayTopics = [];
  const arrayTopics = [];
  topics.forEach((topic) => {
    if (!Array.isArray(topic)) {
      notArrayTopics.push(topic);
    }
    if (Array.isArray(topic)) {
      arrayTopics.push(topic);
    }
  });
  const criteriaSet = [];
  if (notArrayTopics.length > 0) {
    criteriaSet.push(_scatterArrayTopic(notArrayTopics, address));
  }
  arrayTopics.forEach((topics2) => {
    topics2.forEach((topic) => {
      criteriaSet.push({
        address,
        topic0: topic,
        topic1: void 0,
        topic2: void 0,
        topic3: void 0,
        topic4: void 0
      });
    });
  });
  if (criteriaSet.length === 0) {
    criteriaSet.push({
      address,
      topic0: void 0,
      topic1: void 0,
      topic2: void 0,
      topic3: void 0,
      topic4: void 0
    });
  }
  return criteriaSet;
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_blockNumber/eth_blockNumber.ts
import { JSONRPCInternalError, stringifyData as stringifyData3 } from "@vechain/sdk-errors";
var ethBlockNumber = async (thorClient) => {
  try {
    const latestBlock = await thorClient.blocks.getBestBlockCompressed();
    return latestBlock?.number !== void 0 ? `0x${latestBlock.number.toString(16)}` : "0x0";
  } catch (e) {
    throw new JSONRPCInternalError(
      "eth_blockNumber()",
      -32603,
      'Method "eth_blockNumber" failed.',
      {
        url: thorClient.httpClient.baseURL,
        innerError: stringifyData3(e)
      }
    );
  }
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_chainId/eth_chainId.ts
import {
  JSONRPCInternalError as JSONRPCInternalError2,
  JSONRPCInvalidParams as JSONRPCInvalidParams3,
  stringifyData as stringifyData4
} from "@vechain/sdk-errors";
import { networkInfo } from "@vechain/sdk-core";
var ethChainId = async (thorClient) => {
  try {
    const genesisBlock = await thorClient.blocks.getGenesisBlock();
    if (genesisBlock?.id === null || genesisBlock?.id === void 0) {
      throw new JSONRPCInvalidParams3(
        "eth_chainId()",
        -32602,
        "The genesis block id is null or undefined. Unable to get the chain id.",
        {
          url: thorClient.httpClient.baseURL
        }
      );
    }
    if (genesisBlock.id === networkInfo.mainnet.genesisBlock.id)
      return CHAIN_ID.MAINNET;
    return CHAIN_ID.TESTNET;
  } catch (e) {
    throw new JSONRPCInternalError2(
      "eth_chainId()",
      -32603,
      'Method "eth_chainId" failed.',
      {
        url: thorClient.httpClient.baseURL,
        innerError: stringifyData4(e)
      }
    );
  }
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getBalance/eth_getBalance.ts
import {
  JSONRPCInternalError as JSONRPCInternalError3,
  JSONRPCInvalidParams as JSONRPCInvalidParams4,
  stringifyData as stringifyData5
} from "@vechain/sdk-errors";
var ethGetBalance = async (thorClient, params) => {
  if (params.length !== 2 || typeof params[0] !== "string" || typeof params[1] !== "object" && typeof params[1] !== "string")
    throw new JSONRPCInvalidParams4(
      "eth_getBalance",
      -32602,
      `Invalid input params for "eth_getBalance" method. See ${RPC_DOCUMENTATION_URL} for details.`,
      { params }
    );
  try {
    const [address, block] = params;
    const accountDetails = await thorClient.accounts.getAccount(address, {
      revision: getCorrectBlockNumberRPCToVeChain(block)
    });
    return accountDetails.balance;
  } catch (e) {
    throw new JSONRPCInternalError3(
      "eth_getBalance()",
      -32603,
      'Method "eth_getBalance" failed.',
      {
        params: stringifyData5(params),
        url: thorClient.httpClient.baseURL,
        innerError: stringifyData5(e)
      }
    );
  }
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getCode/eth_getCode.ts
import {
  JSONRPCInternalError as JSONRPCInternalError4,
  JSONRPCInvalidParams as JSONRPCInvalidParams5,
  stringifyData as stringifyData6
} from "@vechain/sdk-errors";
var ethGetCode = async (thorClient, params) => {
  if (params.length !== 2 || typeof params[0] !== "string" || typeof params[1] !== "object" && typeof params[1] !== "string")
    throw new JSONRPCInvalidParams5(
      "eth_getCode",
      -32602,
      `Invalid input params for "eth_getCode" method. See ${RPC_DOCUMENTATION_URL} for details.`,
      { params }
    );
  try {
    const [address, block] = params;
    return await thorClient.accounts.getBytecode(address, {
      revision: getCorrectBlockNumberRPCToVeChain(block)
    });
  } catch (e) {
    throw new JSONRPCInternalError4(
      "eth_getCode()",
      -32603,
      'Method "eth_getCode" failed.',
      {
        params: stringifyData6(params),
        url: thorClient.httpClient.baseURL,
        innerError: stringifyData6(e)
      }
    );
  }
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getStorageAt/eth_getStorageAt.ts
import { ThorId as ThorId4 } from "@vechain/sdk-core";
import {
  JSONRPCInternalError as JSONRPCInternalError5,
  JSONRPCInvalidParams as JSONRPCInvalidParams6,
  stringifyData as stringifyData7
} from "@vechain/sdk-errors";
var ethGetStorageAt = async (thorClient, params) => {
  if (params.length !== 3 || typeof params[0] !== "string" || typeof params[1] !== "string" || typeof params[2] !== "object" && typeof params[2] !== "string")
    throw new JSONRPCInvalidParams6(
      "eth_getStorageAt",
      -32602,
      `Invalid input params for "eth_getStorageAt" method. See ${RPC_DOCUMENTATION_URL} for details.`,
      { params }
    );
  try {
    const [address, storagePosition, block] = params;
    return await thorClient.accounts.getStorageAt(
      address,
      ThorId4.of(storagePosition).toString(),
      {
        revision: getCorrectBlockNumberRPCToVeChain(block)
      }
    );
  } catch (e) {
    throw new JSONRPCInternalError5(
      "eth_getStorageAt()",
      -32603,
      'Method "eth_getStorageAt" failed.',
      {
        params: stringifyData7(params),
        url: thorClient.httpClient.baseURL,
        innerError: stringifyData7(e)
      }
    );
  }
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_estimateGas/eth_estimateGas.ts
import {
  JSONRPCInternalError as JSONRPCInternalError6,
  JSONRPCInvalidParams as JSONRPCInvalidParams7,
  stringifyData as stringifyData8
} from "@vechain/sdk-errors";
var ethEstimateGas = async (thorClient, params) => {
  if (![1, 2].includes(params.length) || typeof params[0] !== "object")
    throw new JSONRPCInvalidParams7(
      "eth_estimateGas",
      -32602,
      `Invalid input params for "eth_estimateGas" method. See ${RPC_DOCUMENTATION_URL} for details.`,
      { params }
    );
  try {
    const [inputOptions, revision] = params;
    const estimatedGas = await thorClient.gas.estimateGas(
      [
        {
          to: inputOptions.to ?? null,
          value: inputOptions.value ?? "0x0",
          data: inputOptions.data ?? "0x0"
        }
      ],
      inputOptions.from,
      {
        revision: revision !== void 0 ? getCorrectBlockNumberRPCToVeChain(revision) : void 0
      }
    );
    return await Promise.resolve("0x" + estimatedGas.totalGas.toString(16));
  } catch (e) {
    throw new JSONRPCInternalError6(
      "eth_estimateGas()",
      -32603,
      'Method "eth_estimateGas" failed.',
      {
        params: stringifyData8(params),
        url: thorClient.httpClient.baseURL,
        innerError: stringifyData8(e)
      }
    );
  }
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_call/eth_call.ts
import {
  JSONRPCInternalError as JSONRPCInternalError7,
  JSONRPCInvalidParams as JSONRPCInvalidParams8,
  stringifyData as stringifyData9
} from "@vechain/sdk-errors";
var ethCall = async (thorClient, params) => {
  if (params.length !== 2 || typeof params[0] !== "object" || typeof params[1] !== "object" && typeof params[1] !== "string")
    throw new JSONRPCInvalidParams8(
      "eth_call",
      -32602,
      `Invalid input params for "eth_call" method. See ${RPC_DOCUMENTATION_URL} for details.`,
      { params }
    );
  try {
    const [inputOptions, block] = params;
    const simulatedTx = await thorClient.transactions.simulateTransaction(
      [
        {
          to: inputOptions.to ?? null,
          value: inputOptions.value ?? "0x0",
          data: inputOptions.data ?? "0x0"
        }
      ],
      {
        revision: getCorrectBlockNumberRPCToVeChain(block),
        gas: inputOptions.gas !== void 0 ? parseInt(inputOptions.gas, 16) : void 0,
        gasPrice: inputOptions.gasPrice ?? inputOptions.gasPrice,
        caller: inputOptions.from
      }
    );
    return simulatedTx[0].data;
  } catch (e) {
    throw new JSONRPCInternalError7(
      "eth_call()",
      -32603,
      'Method "eth_call" failed.',
      {
        params: stringifyData9(params),
        url: thorClient.httpClient.baseURL,
        innerError: stringifyData9(e)
      }
    );
  }
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_sendRawTransaction/eth_sendRawTransaction.ts
import {
  JSONRPCInternalError as JSONRPCInternalError8,
  JSONRPCInvalidParams as JSONRPCInvalidParams9,
  stringifyData as stringifyData10
} from "@vechain/sdk-errors";
import { Hex as Hex8 } from "@vechain/sdk-core";
var ethSendRawTransaction = async (thorClient, params) => {
  if (params.length !== 1 || typeof params[0] !== "string")
    throw new JSONRPCInvalidParams9(
      "eth_sendRawTransaction()",
      -32602,
      `Invalid input params for "eth_sendRawTransaction" method. See ${RPC_DOCUMENTATION_URL} for details.`,
      { params }
    );
  if (!Hex8.isValid0x(params[0])) {
    throw new JSONRPCInvalidParams9(
      "eth_sendRawTransaction()",
      -32602,
      "Invalid transaction encoded data given as input. Input must be a hex string.",
      { params }
    );
  }
  try {
    const [signedTransactionData] = params;
    const sentTransaction = await thorClient.transactions.sendRawTransaction(
      signedTransactionData
    );
    return sentTransaction.id;
  } catch (e) {
    throw new JSONRPCInternalError8(
      "eth_sendRawTransaction()",
      -32603,
      'Method "eth_sendRawTransaction" failed.',
      {
        params: stringifyData10(params),
        url: thorClient.httpClient.baseURL,
        innerError: stringifyData10(e)
      }
    );
  }
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getLogs/eth_getLogs.ts
import {
  JSONRPCInternalError as JSONRPCInternalError9,
  JSONRPCInvalidParams as JSONRPCInvalidParams10,
  stringifyData as stringifyData11
} from "@vechain/sdk-errors";
var ethGetLogs = async (thorClient, params) => {
  if (params.length !== 1 || typeof params[0] !== "object")
    throw new JSONRPCInvalidParams10(
      "eth_getLogs",
      -32602,
      `Invalid input params for "eth_getLogs" method. See ${RPC_DOCUMENTATION_URL} for details.`,
      { params }
    );
  const MAX_LIMIT = 1e3;
  const [filterOptions] = params;
  try {
    const latestBlock = await thorClient.blocks.getBestBlockCompressed();
    const criteriaSet = getCriteriaSetForInput({
      address: filterOptions.address !== null ? filterOptions.address : void 0,
      topics: filterOptions.topics
    });
    const logs = await thorClient.logs.filterRawEventLogs({
      range: {
        unit: "block",
        from: filterOptions.fromBlock !== void 0 ? parseInt(filterOptions.fromBlock, 16) : latestBlock.number,
        to: filterOptions.toBlock !== void 0 ? parseInt(filterOptions.toBlock, 16) : latestBlock.number
      },
      criteriaSet,
      order: "asc",
      options: {
        offset: 0,
        limit: MAX_LIMIT
      }
    });
    return formatToLogsRPC(logs);
  } catch (e) {
    throw new JSONRPCInternalError9(
      "ethGetLogs()",
      -32603,
      'Method "ethGetLogs" failed.',
      {
        params: stringifyData11(params),
        url: thorClient.httpClient.baseURL,
        innerError: stringifyData11(e)
      }
    );
  }
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getBlockByHash/eth_getBlockByHash.ts
import { ThorId as ThorId5 } from "@vechain/sdk-core";

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getBlockByNumber/eth_getBlockByNumber.ts
import {
  JSONRPCInternalError as JSONRPCInternalError10,
  JSONRPCInvalidParams as JSONRPCInvalidParams12,
  stringifyData as stringifyData13
} from "@vechain/sdk-errors";

// src/provider/utils/rpc-mapper/methods-map/methods/eth_accounts/eth_accounts.ts
var ethAccounts = async (provider) => {
  if (provider?.wallet !== void 0)
    return await provider?.wallet.getAddresses();
  return [];
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_requestAccounts/eth_requestAccounts.ts
import { JSONRPCInvalidParams as JSONRPCInvalidParams11, stringifyData as stringifyData12 } from "@vechain/sdk-errors";
var ethRequestAccounts = async (provider) => {
  const accounts = await ethAccounts(provider);
  if (accounts.length === 0)
    throw new JSONRPCInvalidParams11(
      "eth_getTransactionReceipt()",
      -32602,
      'Method "ethRequestAccounts" failed.',
      {
        provider: stringifyData12(provider)
      }
    );
  return accounts;
};

// src/provider/utils/rpc-mapper/rpc-mapper.ts
var RPCMethodsMap = (thorClient, provider) => {
  return {
    ["eth_blockNumber" /* eth_blockNumber */]: async () => {
      return await ethBlockNumber(thorClient);
    },
    ["eth_chainId" /* eth_chainId */]: async () => {
      return await ethChainId(thorClient);
    },
    ["eth_getBalance" /* eth_getBalance */]: async (params) => {
      return await ethGetBalance(thorClient, params);
    },
    ["eth_getCode" /* eth_getCode */]: async (params) => {
      return await ethGetCode(thorClient, params);
    },
    ["eth_getStorageAt" /* eth_getStorageAt */]: async (params) => {
      return await ethGetStorageAt(thorClient, params);
    },
    ["eth_estimateGas" /* eth_estimateGas */]: async (params) => {
      return await ethEstimateGas(thorClient, params);
    },
    ["eth_call" /* eth_call */]: async (params) => {
      return await ethCall(thorClient, params);
    },
    ["eth_sendRawTransaction" /* eth_sendRawTransaction */]: async (params) => {
      return await ethSendRawTransaction(thorClient, params);
    },
    ["eth_getLogs" /* eth_getLogs */]: async (params) => {
      return await ethGetLogs(thorClient, params);
    },
    ["eth_getBlockByHash" /* eth_getBlockByHash */]: async (params) => {
      return await ethGetBlockByHash(thorClient, params);
    },
    ["eth_getBlockByNumber" /* eth_getBlockByNumber */]: async (params) => {
      return await ethGetBlockByNumber(thorClient, params);
    },
    ["eth_accounts" /* eth_accounts */]: async () => {
      return await ethAccounts(provider);
    },
    ["eth_gasPrice" /* eth_gasPrice */]: async () => {
      return await ethGasPrice(thorClient);
    },
    ["eth_getTransactionByHash" /* eth_getTransactionByHash */]: async (params) => {
      return await ethGetTransactionByHash(thorClient, params);
    },
    ["eth_getTransactionCount" /* eth_getTransactionCount */]: async (params) => {
      return await ethGetTransactionCount(params);
    },
    ["eth_getTransactionReceipt" /* eth_getTransactionReceipt */]: async (params) => {
      return await ethGetTransactionReceipt(thorClient, params);
    },
    ["eth_sendTransaction" /* eth_sendTransaction */]: async (params) => {
      return await ethSendTransaction(thorClient, params, provider);
    },
    ["eth_syncing" /* eth_syncing */]: async () => {
      return await ethSyncing(thorClient);
    },
    ["net_version" /* net_version */]: async () => {
      return await netVersion(thorClient);
    },
    ["web3_clientVersion" /* web3_clientVersion */]: async () => {
      return await web3ClientVersion();
    },
    ["eth_subscribe" /* eth_subscribe */]: async (params) => {
      return await ethSubscribe(thorClient, params, provider);
    },
    ["eth_unsubscribe" /* eth_unsubscribe */]: async (params) => {
      return await ethUnsubscribe(params, provider);
    },
    ["debug_traceTransaction" /* debug_traceTransaction */]: async (params) => {
      return await debugTraceTransaction(thorClient, params);
    },
    ["debug_traceCall" /* debug_traceCall */]: async (params) => {
      return await debugTraceCall(thorClient, params);
    },
    ["evm_mine" /* evm_mine */]: async () => {
      return await evmMine(thorClient);
    },
    ["eth_coinbase" /* eth_coinbase */]: async (params) => {
      await ethCoinbase(thorClient, params);
    },
    ["eth_feeHistory" /* eth_feeHistory */]: async (params) => {
      await ethFeeHistory(thorClient, params);
    },
    ["eth_getBlockTransactionCountByHash" /* eth_getBlockTransactionCountByHash */]: async (params) => {
      await ethGetBlockTransactionCountByHash(thorClient, params);
    },
    ["eth_getBlockTransactionCountByNumber" /* eth_getBlockTransactionCountByNumber */]: async (params) => {
      await ethGetBlockTransactionCountByNumber(thorClient, params);
    },
    ["eth_getTransactionByBlockHashAndIndex" /* eth_getTransactionByBlockHashAndIndex */]: async (params) => {
      await ethGetTransactionByBlockHashAndIndex(thorClient, params);
    },
    ["eth_getTransactionByBlockNumberAndIndex" /* eth_getTransactionByBlockNumberAndIndex */]: async (params) => {
      await ethGetTransactionByBlockNumberAndIndex(thorClient, params);
    },
    ["eth_getUncleByBlockHashAndIndex" /* eth_getUncleByBlockHashAndIndex */]: async (params) => {
      await ethGetUncleByBlockHashAndIndex(thorClient, params);
    },
    ["eth_getUncleByBlockNumberAndIndex" /* eth_getUncleByBlockNumberAndIndex */]: async (params) => {
      await ethGetUncleByBlockNumberAndIndex(thorClient, params);
    },
    ["eth_getUncleCountByBlockHash" /* eth_getUncleCountByBlockHash */]: async (params) => {
      await ethGetUncleCountByBlockHash(thorClient, params);
    },
    ["eth_getUncleCountByBlockNumber" /* eth_getUncleCountByBlockNumber */]: async (params) => {
      await ethGetUncleCountByBlockNumber(thorClient, params);
    },
    ["eth_getWork" /* eth_getWork */]: async (params) => {
      await ethGetWork(thorClient, params);
    },
    ["eth_mining" /* eth_mining */]: async (params) => {
      await ethMining(thorClient, params);
    },
    ["eth_hashrate" /* eth_hashrate */]: async (params) => {
      await ethHashrate(thorClient, params);
    },
    ["eth_protocolVersion" /* eth_protocolVersion */]: async (params) => {
      await ethProtocolVersion(thorClient, params);
    },
    ["eth_requestAccounts" /* eth_requestAccounts */]: async () => {
      return await ethRequestAccounts(provider);
    },
    ["eth_sign" /* eth_sign */]: async (params) => {
      await ethSign(thorClient, params);
    },
    ["eth_submitWork" /* eth_submitWork */]: async (params) => {
      await ethSubmitWork(thorClient, params);
    },
    ["net_listening" /* net_listening */]: async (params) => {
      await netListening(thorClient, params);
    },
    ["net_peerCount" /* net_peerCount */]: async (params) => {
      await netPeerCount(thorClient, params);
    },
    ["parity_nextNonce" /* parity_nextNonce */]: async (params) => {
      await parityNextNonce(thorClient, params);
    },
    ["eth_newFilter" /* eth_newFilter */]: async (params) => {
      await ethNewFilter(thorClient, params);
    },
    ["eth_newBlockFilter" /* eth_newBlockFilter */]: async (params) => {
      await ethNewBlockFilter(thorClient, params);
    },
    ["eth_newPendingTransactionFilter" /* eth_newPendingTransactionFilter */]: async (params) => {
      await ethNewPendingTransactionFilter(thorClient, params);
    },
    ["eth_getFilterLogs" /* eth_getFilterLogs */]: async (params) => {
      await ethGetFilterLogs(thorClient, params);
    },
    ["eth_getFilterChanges" /* eth_getFilterChanges */]: async (params) => {
      await ethGetFilterChanges(thorClient, params);
    },
    ["eth_uninstallFilter" /* eth_uninstallFilter */]: async (params) => {
      await ethUninstallFilter(thorClient, params);
    },
    ["debug_getBadBlocks" /* debug_getBadBlocks */]: async (params) => {
      await debugGetBadBlocks(thorClient, params);
    },
    ["debug_getRawBlock" /* debug_getRawBlock */]: async (params) => {
      await debugGetRawBlock(thorClient, params);
    },
    ["debug_getRawHeader" /* debug_getRawHeader */]: async (params) => {
      await debugGetRawHeader(thorClient, params);
    },
    ["debug_getRawReceipts" /* debug_getRawReceipts */]: async (params) => {
      await debugGetRawReceipts(thorClient, params);
    },
    ["debug_getRawTransaction" /* debug_getRawTransaction */]: async (params) => {
      await debugGetRawTransaction(thorClient, params);
    },
    ["engine_exchangeCapabilities" /* engine_exchangeCapabilities */]: async (params) => {
      await engineExchangeCapabilities(thorClient, params);
    },
    ["engine_exchangeTransitionConfigurationV1" /* engine_exchangeTransitionConfigurationV1 */]: async (params) => {
      await engineExchangeTransitionConfigurationV1(thorClient, params);
    },
    ["engine_forkchoiceUpdatedV1" /* engine_forkchoiceUpdatedV1 */]: async (params) => {
      await engineForkchoiceUpdatedV1(thorClient, params);
    },
    ["engine_forkchoiceUpdatedV2" /* engine_forkchoiceUpdatedV2 */]: async (params) => {
      await engineForkchoiceUpdatedV2(thorClient, params);
    },
    ["engine_forkchoiceUpdatedV3" /* engine_forkchoiceUpdatedV3 */]: async (params) => {
      await engineForkchoiceUpdatedV3(thorClient, params);
    },
    ["engine_getPayloadBodiesByHashV1" /* engine_getPayloadBodiesByHashV1 */]: async (params) => {
      await engineGetPayloadBodiesByHashV1(thorClient, params);
    },
    ["engine_getPayloadBodiesByRangeV1" /* engine_getPayloadBodiesByRangeV1 */]: async (params) => {
      await engineGetPayloadBodiesByRangeV1(thorClient, params);
    },
    ["engine_getPayloadV1" /* engine_getPayloadV1 */]: async (params) => {
      await engineGetPayloadV1(thorClient, params);
    },
    ["engine_getPayloadV2" /* engine_getPayloadV2 */]: async (params) => {
      await engineGetPayloadV2(thorClient, params);
    },
    ["engine_getPayloadV3" /* engine_getPayloadV3 */]: async (params) => {
      await engineGetPayloadV3(thorClient, params);
    },
    ["engine_newPayloadV1" /* engine_newPayloadV1 */]: async (params) => {
      await engineNewPayloadV1(thorClient, params);
    },
    ["engine_newPayloadV2" /* engine_newPayloadV2 */]: async (params) => {
      await engineNewPayloadV2(thorClient, params);
    },
    ["engine_newPayloadV3" /* engine_newPayloadV3 */]: async (params) => {
      await engineNewPayloadV3(thorClient, params);
    },
    ["eth_createAccessList" /* eth_createAccessList */]: async (params) => {
      await ethCreateAccessList(thorClient, params);
    },
    ["eth_getBlockReceipts" /* eth_getBlockReceipts */]: async (params) => {
      return await ethGetBlockReceipts(thorClient, params);
    },
    ["eth_getProof" /* eth_getProof */]: async (params) => {
      await ethGetProof(thorClient, params);
    },
    ["eth_maxPriorityFeePerGas" /* eth_maxPriorityFeePerGas */]: async (params) => {
      await ethMaxPriorityFeePerGas(thorClient, params);
    },
    ["eth_signTransaction" /* eth_signTransaction */]: async (params) => {
      await ethSignTransaction(thorClient, params);
    }
  };
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getBlockByNumber/eth_getBlockByNumber.ts
var ethGetBlockByNumber = async (thorClient, params) => {
  if (params.length !== 2 || typeof params[0] !== "string" || typeof params[1] !== "boolean")
    throw new JSONRPCInvalidParams12(
      "eth_getBlockByNumber",
      -32602,
      `Invalid input params for "eth_getBlockByNumber" method. See ${RPC_DOCUMENTATION_URL} for details.`,
      { params }
    );
  try {
    const [blockNumber, isTxDetail] = params;
    let chainId = "0x0";
    if (isTxDetail)
      chainId = await RPCMethodsMap(thorClient)["eth_chainId" /* eth_chainId */](
        []
      );
    const block = isTxDetail ? await thorClient.blocks.getBlockExpanded(
      getCorrectBlockNumberRPCToVeChain(blockNumber)
    ) : await thorClient.blocks.getBlockCompressed(
      getCorrectBlockNumberRPCToVeChain(blockNumber)
    );
    return block !== null ? blocksFormatter.formatToRPCStandard(block, chainId) : null;
  } catch (e) {
    throw new JSONRPCInternalError10(
      "eth_getBlockByNumber()",
      -32603,
      'Method "eth_getBlockByNumber" failed.',
      {
        params: stringifyData13(params),
        url: thorClient.httpClient.baseURL,
        innerError: stringifyData13(e)
      }
    );
  }
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getBlockByHash/eth_getBlockByHash.ts
import {
  JSONRPCInternalError as JSONRPCInternalError11,
  JSONRPCInvalidParams as JSONRPCInvalidParams13,
  stringifyData as stringifyData14
} from "@vechain/sdk-errors";
var ethGetBlockByHash = async (thorClient, params) => {
  if (params.length !== 2 || typeof params[0] !== "string" || !ThorId5.isValid(params[0]) || typeof params[1] !== "boolean")
    throw new JSONRPCInvalidParams13(
      "eth_getBlockByHash",
      -32602,
      `Invalid input params for "eth_getBlockByHash" method. See ${RPC_DOCUMENTATION_URL} for details.`,
      { params }
    );
  try {
    return await ethGetBlockByNumber(thorClient, params);
  } catch (e) {
    throw new JSONRPCInternalError11(
      "eth_getBlockByHash()",
      -32603,
      'Method "eth_getBlockByHash" failed.',
      {
        params: stringifyData14(params),
        url: thorClient.httpClient.baseURL,
        innerError: stringifyData14(e)
      }
    );
  }
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_gasPrice/eth_gasPrice.ts
var ethGasPrice = async (thorClient) => {
  const result = BigInt(
    await Promise.resolve(
      thorClient.contracts.getBaseGasPrice()
    )
  );
  return "0x" + result.toString(16);
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getTransactionByHash/eth_getTransactionByHash.ts
import {
  JSONRPCInternalError as JSONRPCInternalError12,
  JSONRPCInvalidParams as JSONRPCInvalidParams14,
  stringifyData as stringifyData15
} from "@vechain/sdk-errors";
var ethGetTransactionByHash = async (thorClient, params) => {
  if (params.length !== 1 || typeof params[0] !== "string")
    throw new JSONRPCInvalidParams14(
      "eth_getTransactionByHash",
      -32602,
      `Invalid input params for "eth_getTransactionByHash" method. See ${RPC_DOCUMENTATION_URL} for details.`,
      { params }
    );
  try {
    const [hash] = params;
    const tx = await thorClient.transactions.getTransaction(hash);
    if (tx === null) return null;
    const block = await RPCMethodsMap(thorClient)["eth_getBlockByNumber" /* eth_getBlockByNumber */]([tx.meta.blockID, false]);
    const txIndex = getTransactionIndexIntoBlock(block, hash);
    const chainId = await RPCMethodsMap(thorClient)["eth_chainId" /* eth_chainId */]([]);
    return transactionsFormatter.formatToRPCStandard(tx, chainId, txIndex);
  } catch (e) {
    throw new JSONRPCInternalError12(
      "eth_getTransactionByHash()",
      -32603,
      'Method "eth_getTransactionByHash" failed.',
      {
        params: stringifyData15(params),
        url: thorClient.httpClient.baseURL,
        innerError: stringifyData15(e)
      }
    );
  }
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getTransactionCount/eth_getTransactionCount.ts
import { JSONRPCInvalidParams as JSONRPCInvalidParams15 } from "@vechain/sdk-errors";
import { Hex as Hex9, Address as Address8, secp256k1 as secp256k13 } from "@vechain/sdk-core";
var ethGetTransactionCount = async (params) => {
  if (typeof params[0] !== "string" || typeof params[1] !== "object" && typeof params[1] !== "string")
    throw new JSONRPCInvalidParams15(
      "eth_getTransactionCount",
      -32602,
      `Invalid input params for "eth_getTransactionCount" method. See ${RPC_DOCUMENTATION_URL} for details.`,
      { params }
    );
  if (!Address8.isValid(params[0])) {
    throw new JSONRPCInvalidParams15(
      "eth_getTransactionCount",
      -32602,
      "Invalid address, expected a 20 bytes address string.",
      { params }
    );
  }
  return Hex9.of(secp256k13.randomBytes(6)).toString();
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getTransactionReceipt/eth_getTransactionReceipt.ts
import { ThorId as ThorId6 } from "@vechain/sdk-core";
import {
  JSONRPCInternalError as JSONRPCInternalError13,
  JSONRPCInvalidParams as JSONRPCInvalidParams16,
  stringifyData as stringifyData16
} from "@vechain/sdk-errors";
var ethGetTransactionReceipt = async (thorClient, params) => {
  if (params.length !== 1 || typeof params[0] !== "string")
    throw new JSONRPCInvalidParams16(
      "eth_getTransactionReceipt",
      -32602,
      `Invalid input params for "eth_getTransactionReceipt" method. See ${RPC_DOCUMENTATION_URL} for details.`,
      { params }
    );
  if (!ThorId6.isValid(params[0])) {
    throw new JSONRPCInvalidParams16(
      "eth_getTransactionReceipt",
      -32602,
      "Invalid transaction ID given as input. Input must be an hex string of length 64.",
      { params }
    );
  }
  try {
    const [hash] = params;
    const receipt = await thorClient.transactions.getTransactionReceipt(hash);
    if (receipt !== null) {
      const blockContainsTransaction = await thorClient.blocks.getBlockExpanded(
        receipt.meta.blockID
      );
      const transactionDetail = await thorClient.transactions.getTransaction(hash);
      const chainId = await RPCMethodsMap(thorClient)["eth_chainId" /* eth_chainId */]([]);
      if (transactionDetail !== null)
        return transactionsFormatter.formatTransactionReceiptToRPCStandard(
          hash,
          receipt,
          transactionDetail,
          blockContainsTransaction,
          chainId
        );
      else return null;
    } else {
      return null;
    }
  } catch (e) {
    throw new JSONRPCInternalError13(
      "eth_getTransactionReceipt()",
      -32603,
      'Method "eth_getTransactionReceipt" failed.',
      {
        params: stringifyData16(params),
        url: thorClient.httpClient.baseURL,
        innerError: stringifyData16(e)
      }
    );
  }
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_sendTransaction/eth_sendTransaction.ts
import {
  JSONRPCInternalError as JSONRPCInternalError14,
  JSONRPCInvalidParams as JSONRPCInvalidParams17,
  stringifyData as stringifyData17
} from "@vechain/sdk-errors";
var ethSendTransaction = async (thorClient, params, provider) => {
  if (params.length !== 1 || typeof params[0] !== "object")
    throw new JSONRPCInvalidParams17(
      "eth_sendTransaction",
      -32602,
      `Invalid input params for "eth_sendTransaction" method. See ${RPC_DOCUMENTATION_URL} for details.`,
      { params }
    );
  if (provider?.wallet === void 0) {
    throw new JSONRPCInvalidParams17(
      "eth_sendTransaction",
      -32602,
      "Provider must be defined with a wallet. Ensure that the provider is defined and connected to the network.",
      { provider }
    );
  }
  if (params[0].from === void 0) {
    throw new JSONRPCInvalidParams17(
      "eth_sendTransaction",
      -32602,
      "From field is required in the transaction object.",
      { provider }
    );
  }
  const [transaction] = params;
  try {
    const signer = await provider.getSigner(
      transaction.from
    );
    return await signer.sendTransaction(transaction);
  } catch (e) {
    throw new JSONRPCInternalError14(
      "eth_sendTransaction()",
      -32603,
      'Method "eth_sendTransaction" failed.',
      {
        params: stringifyData17(params),
        url: thorClient.httpClient.baseURL,
        innerError: stringifyData17(e)
      }
    );
  }
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_syncing/eth_syncing.ts
import { JSONRPCInternalError as JSONRPCInternalError15, stringifyData as stringifyData18 } from "@vechain/sdk-errors";
import { HexInt as HexInt2 } from "@vechain/sdk-core";
var _isBlockNotOutOfSyncInTime = (block) => {
  return Math.floor(Date.now() / 1e3) - block.timestamp < 11e3;
};
var ethSyncing = async (thorClient) => {
  try {
    const bestBlock = await thorClient.blocks.getBestBlockCompressed();
    const genesisBlock = await thorClient.blocks.getGenesisBlock();
    const highestBlockNumber = genesisBlock !== null ? HexInt2.of(
      Math.floor((Date.now() - genesisBlock.timestamp) / 1e4)
    ).toString() : null;
    if (bestBlock !== null) {
      if (_isBlockNotOutOfSyncInTime(bestBlock)) return false;
      const chainId = await RPCMethodsMap(thorClient)["eth_chainId" /* eth_chainId */]([]);
      return {
        currentBlock: blocksFormatter.formatToRPCStandard(
          bestBlock,
          chainId
        ),
        highestBlock: highestBlockNumber,
        // Not supported field
        startingBlock: null
      };
    }
    return {
      currentBlock: null,
      highestBlock: highestBlockNumber,
      // Not supported field
      startingBlock: null
    };
  } catch (e) {
    throw new JSONRPCInternalError15(
      "eth_syncing()",
      -32603,
      'Method "eth_syncing" failed.',
      {
        url: thorClient.httpClient.baseURL,
        innerError: stringifyData18(e)
      }
    );
  }
};

// src/provider/utils/rpc-mapper/methods-map/methods/web3_clientVersion/web3_clientVersion.ts
var web3ClientVersion = async () => {
  return await Promise.resolve("thor");
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_subscribe/eth_subscribe.ts
import { Hex as Hex10 } from "@vechain/sdk-core";
import {
  JSONRPCInternalError as JSONRPCInternalError16,
  JSONRPCInvalidParams as JSONRPCInvalidParams18,
  JSONRPCServerError,
  stringifyData as stringifyData19
} from "@vechain/sdk-errors";
var ethSubscribe = async (thorClient, params, provider) => {
  if (provider === void 0) {
    throw new JSONRPCInternalError16(
      "ethSubscribe()",
      -32603,
      'Method "ethSubscribe" failed. Provider is not defined.',
      {
        url: thorClient.httpClient.baseURL,
        params: stringifyData19(params)
      }
    );
  }
  if (params[0] !== "newHeads" /* NEW_HEADS */ && params[0] !== "logs" /* LOGS */) {
    throw new JSONRPCInvalidParams18(
      "ethSubscribe()",
      -32602,
      'Method "ethSubscribe" failed. Invalid subscription type param.',
      {
        url: thorClient.httpClient.baseURL,
        params: stringifyData19(params)
      }
    );
  }
  if (provider.getPollInstance() === void 0) {
    const block = await thorClient.blocks.getBestBlockCompressed();
    if (block !== void 0 && block !== null) {
      provider.subscriptionManager.currentBlockNumber = block.number;
    } else
      throw new JSONRPCServerError(
        "ethSubscribe()",
        -32e3,
        'Method "ethSubscribe" failed. Best block not available.',
        {
          url: thorClient.httpClient.baseURL,
          params: stringifyData19(params)
        }
      );
    provider.startSubscriptionsPolling();
  }
  const subscriptionId = Hex10.random(16).digits;
  if (params.includes("newHeads" /* NEW_HEADS */)) {
    provider.subscriptionManager.newHeadsSubscription = {
      subscriptionId,
      subscription: {
        type: "newHeads" /* NEW_HEADS */
      }
    };
  }
  if (params.includes("logs" /* LOGS */)) {
    provider.subscriptionManager.logSubscriptions.set(subscriptionId, {
      type: "logs" /* LOGS */,
      options: params[1]
    });
  }
  return subscriptionId;
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_unsubscribe/eth_unsubscribe.ts
import { JSONRPCInternalError as JSONRPCInternalError17, stringifyData as stringifyData20 } from "@vechain/sdk-errors";
var ethUnsubscribe = async (params, provider) => {
  let result = false;
  if (provider === void 0) {
    throw new JSONRPCInternalError17(
      "ethSubscribe()",
      -32603,
      'Method "ethSubscribe" failed. Provider is not defined.',
      {
        params: stringifyData20(params)
      }
    );
  }
  const subscriptionId = params[0];
  if (provider.subscriptionManager.newHeadsSubscription !== void 0 && subscriptionId === provider.subscriptionManager.newHeadsSubscription.subscriptionId) {
    provider.subscriptionManager.newHeadsSubscription = void 0;
    result = true;
  } else {
    result = provider.subscriptionManager.logSubscriptions.delete(
      subscriptionId
    );
  }
  if (!provider.isThereActiveSubscriptions()) {
    provider.stopSubscriptionsPolling();
  }
  return await Promise.resolve(result);
};

// src/provider/utils/rpc-mapper/methods-map/methods/debug_traceTransaction/debug_traceTransaction.ts
import { ThorId as ThorId7 } from "@vechain/sdk-core";
import {
  InvalidDataType as InvalidDataType13,
  JSONRPCInternalError as JSONRPCInternalError18,
  JSONRPCInvalidParams as JSONRPCInvalidParams19,
  stringifyData as stringifyData21
} from "@vechain/sdk-errors";
var debugTraceTransaction = async (thorClient, params) => {
  if (params.length !== 2 || typeof params[0] !== "string" || typeof params[1] !== "object")
    throw new JSONRPCInvalidParams19(
      "debug_traceTransaction",
      -32602,
      `Invalid input params for "debug_traceTransaction" method. See ${RPC_DOCUMENTATION_URL} for details.`,
      { params }
    );
  const [transactionId, traceOptions] = params;
  if (!ThorId7.isValid(transactionId)) {
    throw new InvalidDataType13(
      "debug_traceTransaction()",
      "Invalid transaction ID given as input. Input must be an hex string of length 64.",
      { transactionId }
    );
  }
  const tracerToUse = traceOptions.tracer === "callTracer" ? "call" : "prestate";
  try {
    const transactionReceipt = await ethGetTransactionReceipt(thorClient, [
      transactionId
    ]);
    const trace = await thorClient.debug.traceTransactionClause(
      {
        target: {
          blockID: transactionReceipt?.blockHash,
          transaction: transactionReceipt?.transactionHash,
          clauseIndex: 0
        },
        config: {}
      },
      tracerToUse
    );
    return debugFormatter.formatToRPCStandard(
      tracerToUse,
      trace
    );
  } catch (e) {
    throw new JSONRPCInternalError18(
      "debug_traceTransaction()",
      -32603,
      'Method "debug_traceTransaction" failed.',
      {
        params: stringifyData21(params),
        url: thorClient.httpClient.baseURL,
        innerError: stringifyData21(e)
      }
    );
  }
};

// src/provider/utils/rpc-mapper/methods-map/methods/debug_traceCall/debug_traceCall.ts
import {
  JSONRPCInternalError as JSONRPCInternalError19,
  JSONRPCInvalidParams as JSONRPCInvalidParams20,
  stringifyData as stringifyData22
} from "@vechain/sdk-errors";
var debugTraceCall = async (thorClient, params) => {
  if (params.length !== 3 || typeof params[0] !== "object" || typeof params[1] !== "string" || typeof params[2] !== "object")
    throw new JSONRPCInvalidParams20(
      "debug_traceCall",
      -32602,
      `Invalid input params for "debug_traceCall" method. See ${RPC_DOCUMENTATION_URL} for details.`,
      { params }
    );
  const transactionOptions = params[0];
  const tracerOptions = params[2];
  const tracerToUse = tracerOptions.tracer === "callTracer" ? "call" : "prestate";
  try {
    const trace = await thorClient.debug.traceContractCall(
      {
        transactionOptions: {
          caller: transactionOptions.from,
          gas: transactionOptions.gas !== void 0 ? parseInt(transactionOptions.gas, 16) : void 0,
          gasPrice: transactionOptions.gasPrice
        },
        contractInput: {
          to: transactionOptions.to,
          data: transactionOptions.data
        },
        config: tracerOptions.tracerConfig
      },
      tracerToUse
    );
    return debugFormatter.formatToRPCStandard(
      tracerToUse,
      trace
    );
  } catch (e) {
    throw new JSONRPCInternalError19(
      "debug_traceCall()",
      -32603,
      'Method "debug_traceCall" failed.',
      {
        params: stringifyData22(params),
        url: thorClient.httpClient.baseURL,
        innerError: stringifyData22(e)
      }
    );
  }
};

// src/provider/utils/rpc-mapper/methods-map/methods/evm_mine/evm_mine.ts
import { JSONRPCInternalError as JSONRPCInternalError20, stringifyData as stringifyData23 } from "@vechain/sdk-errors";
var evmMine = async (thorClient) => {
  try {
    const bestBlock = await thorClient.blocks.getBestBlockExpanded();
    const newBlock = bestBlock !== null ? await thorClient.blocks.waitForBlockCompressed(
      bestBlock.number + 1
    ) : null;
    const chainId = await RPCMethodsMap(thorClient)["eth_chainId" /* eth_chainId */]([]);
    return newBlock !== null ? blocksFormatter.formatToRPCStandard(newBlock, chainId) : null;
  } catch (e) {
    throw new JSONRPCInternalError20(
      "evm_mine()",
      -32603,
      'Method "evm_mine" failed.',
      {
        url: thorClient.httpClient.baseURL,
        innerError: stringifyData23(e)
      }
    );
  }
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_coinbase/eth_coinbase.ts
import { FunctionNotImplemented } from "@vechain/sdk-errors";
var ethCoinbase = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented(
    "eth_coinbase",
    'Method "eth_coinbase" has not been implemented yet.',
    {
      functionName: "eth_coinbase",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_feeHistory/eth_feeHistory.ts
import { FunctionNotImplemented as FunctionNotImplemented2 } from "@vechain/sdk-errors";
var ethFeeHistory = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented2(
    "eth_feeHistory",
    'Method "eth_feeHistory" has not been implemented yet.',
    {
      functionName: "eth_feeHistory",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getBlockTransactionCountByHash/eth_getBlockTransactionCountByHash.ts
import { FunctionNotImplemented as FunctionNotImplemented3 } from "@vechain/sdk-errors";
var ethGetBlockTransactionCountByHash = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented3(
    "eth_getBlockTransactionCountByHash",
    'Method "eth_getBlockTransactionCountByHash" has not been implemented yet.',
    {
      functionName: "eth_getBlockTransactionCountByHash",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getBlockTransactionCountByNumber/eth_getBlockTransactionCountByNumber.ts
import { FunctionNotImplemented as FunctionNotImplemented4 } from "@vechain/sdk-errors";
var ethGetBlockTransactionCountByNumber = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented4(
    "eth_getBlockTransactionCountByNumber",
    'Method "eth_getBlockTransactionCountByNumber" has not been implemented yet.',
    {
      functionName: "eth_getBlockTransactionCountByNumber",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getTransactionByBlockHashAndIndex/eth_getTransactionByBlockHashAndIndex.ts
import { FunctionNotImplemented as FunctionNotImplemented5 } from "@vechain/sdk-errors";
var ethGetTransactionByBlockHashAndIndex = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented5(
    "eth_getTransactionByBlockHashAndIndex",
    'Method "eth_getTransactionByBlockHashAndIndex" has not been implemented yet.',
    {
      functionName: "eth_getTransactionByBlockHashAndIndex",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getTransactionByBlockNumberAndIndex/eth_getTransactionByBlockNumberAndIndex.ts
import { FunctionNotImplemented as FunctionNotImplemented6 } from "@vechain/sdk-errors";
var ethGetTransactionByBlockNumberAndIndex = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented6(
    "eth_getTransactionByBlockNumberAndIndex",
    'Method "eth_getTransactionByBlockNumberAndIndex" has not been implemented yet.',
    {
      functionName: "eth_getTransactionByBlockNumberAndIndex",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getUncleByBlockHashAndIndex/eth_getUncleByBlockHashAndIndex.ts
import { FunctionNotImplemented as FunctionNotImplemented7 } from "@vechain/sdk-errors";
var ethGetUncleByBlockHashAndIndex = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented7(
    "eth_getUncleByBlockHashAndIndex",
    'Method "eth_getUncleByBlockHashAndIndex" has not been implemented yet.',
    {
      functionName: "eth_getUncleByBlockHashAndIndex",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getUncleByBlockNumberAndIndex/eth_getUncleByBlockNumberAndIndex.ts
import { FunctionNotImplemented as FunctionNotImplemented8 } from "@vechain/sdk-errors";
var ethGetUncleByBlockNumberAndIndex = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented8(
    "eth_getUncleByBlockNumberAndIndex",
    'Method "eth_getUncleByBlockNumberAndIndex" has not been implemented yet.',
    {
      functionName: "eth_getUncleByBlockNumberAndIndex",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getUncleCountByBlockHash/eth_getUncleCountByBlockHash.ts
import { FunctionNotImplemented as FunctionNotImplemented9 } from "@vechain/sdk-errors";
var ethGetUncleCountByBlockHash = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented9(
    "eth_getUncleCountByBlockHash",
    'Method "eth_getUncleCountByBlockHash" has not been implemented yet.',
    {
      functionName: "eth_getUncleCountByBlockHash",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getUncleCountByBlockNumber/eth_getUncleCountByBlockNumber.ts
import { FunctionNotImplemented as FunctionNotImplemented10 } from "@vechain/sdk-errors";
var ethGetUncleCountByBlockNumber = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented10(
    "eth_getUncleCountByBlockNumber",
    'Method "eth_getUncleCountByBlockNumber" has not been implemented yet.',
    {
      functionName: "eth_getUncleCountByBlockNumber",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getWork/eth_getWork.ts
import { FunctionNotImplemented as FunctionNotImplemented11 } from "@vechain/sdk-errors";
var ethGetWork = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented11(
    "eth_getWork",
    'Method "eth_getWork" has not been implemented yet.',
    {
      functionName: "eth_getWork",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_mining/eth_mining.ts
import { FunctionNotImplemented as FunctionNotImplemented12 } from "@vechain/sdk-errors";
var ethMining = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented12(
    "eth_mining",
    'Method "eth_mining" has not been implemented yet.',
    {
      functionName: "eth_mining",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_hashrate/eth_hashrate.ts
import { FunctionNotImplemented as FunctionNotImplemented13 } from "@vechain/sdk-errors";
var ethHashrate = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented13(
    "ethHashrate",
    'Method "ethHashrate" has not been implemented yet.',
    {
      functionName: "ethHashrate",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_protocolVersion/eth_protocolVersion.ts
import { FunctionNotImplemented as FunctionNotImplemented14 } from "@vechain/sdk-errors";
var ethProtocolVersion = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented14(
    "eth_protocolVersion",
    'Method "eth_protocolVersion" has not been implemented yet.',
    {
      functionName: "eth_protocolVersion",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_sign/eth_sign.ts
import { FunctionNotImplemented as FunctionNotImplemented15 } from "@vechain/sdk-errors";
var ethSign = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented15(
    "eth_sign",
    'Method "eth_sign" has not been implemented yet.',
    {
      functionName: "eth_sign",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_submitWork/eth_submitWork.ts
import { FunctionNotImplemented as FunctionNotImplemented16 } from "@vechain/sdk-errors";
var ethSubmitWork = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented16(
    "eth_submitWork",
    'Method "eth_submitWork" has not been implemented yet.',
    {
      functionName: "eth_submitWork",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/net_listening/net_listening.ts
import { FunctionNotImplemented as FunctionNotImplemented17 } from "@vechain/sdk-errors";
var netListening = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented17(
    "net_listening",
    'Method "net_listening" has not been implemented yet.',
    {
      functionName: "net_listening",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/net_peerCount/net_peerCount.ts
import { FunctionNotImplemented as FunctionNotImplemented18 } from "@vechain/sdk-errors";
var netPeerCount = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented18(
    "net_peerCount",
    'Method "net_peerCount" has not been implemented yet.',
    {
      functionName: "net_peerCount",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/net_version/net_version.ts
var netVersion = async (thorClient) => {
  return await ethChainId(thorClient);
};

// src/provider/utils/rpc-mapper/methods-map/methods/parity_nextNonce/parity_nextNonce.ts
import { FunctionNotImplemented as FunctionNotImplemented19 } from "@vechain/sdk-errors";
var parityNextNonce = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented19(
    "parity_nextNonce",
    'Method "parity_nextNonce" has not been implemented yet.',
    {
      functionName: "parity_nextNonce",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_newFilter/eth_newFilter.ts
import { FunctionNotImplemented as FunctionNotImplemented20 } from "@vechain/sdk-errors";
var ethNewFilter = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented20(
    "eth_newFilter",
    'Method "eth_newFilter" has not been implemented yet.',
    {
      functionName: "eth_newFilter",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_newBlockFilter/eth_newBlockFilter.ts
import { FunctionNotImplemented as FunctionNotImplemented21 } from "@vechain/sdk-errors";
var ethNewBlockFilter = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented21(
    "eth_newBlockFilter",
    'Method "eth_newBlockFilter" has not been implemented yet.',
    {
      functionName: "eth_newBlockFilter",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_newPendingTransactionFilter/eth_newPendingTransactionFilter.ts
import { FunctionNotImplemented as FunctionNotImplemented22 } from "@vechain/sdk-errors";
var ethNewPendingTransactionFilter = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented22(
    "eth_newPendingTransactionFilter",
    'Method "eth_newPendingTransactionFilter" has not been implemented yet.',
    {
      functionName: "eth_newPendingTransactionFilter",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getFilterLogs/eth_getFilterLogs.ts
import { FunctionNotImplemented as FunctionNotImplemented23 } from "@vechain/sdk-errors";
var ethGetFilterLogs = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented23(
    "eth_getFilterLogs",
    'Method "eth_getFilterLogs" has not been implemented yet.',
    {
      functionName: "eth_getFilterLogs",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getFilterChanges/eth_getFilterChanges.ts
import { FunctionNotImplemented as FunctionNotImplemented24 } from "@vechain/sdk-errors";
var ethGetFilterChanges = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented24(
    "eth_getFilterChanges",
    'Method "eth_getFilterChanges" has not been implemented yet.',
    {
      functionName: "eth_getFilterChanges",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_uninstallFilter/eth_uninstallFilter.ts
import { FunctionNotImplemented as FunctionNotImplemented25 } from "@vechain/sdk-errors";
var ethUninstallFilter = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented25(
    "eth_uninstallFilter",
    'Method "eth_uninstallFilter" has not been implemented yet.',
    {
      functionName: "eth_uninstallFilter",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/debug_getBadBlocks/debug_getBadBlocks.ts
import { FunctionNotImplemented as FunctionNotImplemented26 } from "@vechain/sdk-errors";
var debugGetBadBlocks = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented26(
    "debug_getBadBlocks",
    'Method "debug_getBadBlocks" has not been implemented yet.',
    {
      functionName: "debug_getBadBlocks",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/debug_getRawBlock/debug_getRawBlock.ts
import { FunctionNotImplemented as FunctionNotImplemented27 } from "@vechain/sdk-errors";
var debugGetRawBlock = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented27(
    "debug_getRawBlock",
    'Method "debug_getRawBlock" has not been implemented yet.',
    {
      functionName: "debug_getRawBlock",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/debug_getRawHeader/debug_getRawHeader.ts
import { FunctionNotImplemented as FunctionNotImplemented28 } from "@vechain/sdk-errors";
var debugGetRawHeader = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented28(
    "debug_getRawHeader",
    'Method "debug_getRawHeader" has not been implemented yet.',
    {
      functionName: "debug_getRawHeader",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/debug_getRawReceipts/debug_getRawReceipts.ts
import { FunctionNotImplemented as FunctionNotImplemented29 } from "@vechain/sdk-errors";
var debugGetRawReceipts = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented29(
    "debug_getRawReceipts",
    'Method "debug_getRawReceipts" has not been implemented yet.',
    {
      functionName: "debug_getRawReceipts",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/debug_getRawTransaction/debug_getRawTransaction.ts
import { FunctionNotImplemented as FunctionNotImplemented30 } from "@vechain/sdk-errors";
var debugGetRawTransaction = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented30(
    "debug_getRawTransaction",
    'Method "debug_getRawTransaction" has not been implemented yet.',
    {
      functionName: "debug_getRawTransaction",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/engine_exchangeCapabilities/engine_exchangeCapabilities.ts
import { FunctionNotImplemented as FunctionNotImplemented31 } from "@vechain/sdk-errors";
var engineExchangeCapabilities = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented31(
    "engine_exchangeCapabilities",
    'Method "engine_exchangeCapabilities" has not been implemented yet.',
    {
      functionName: "engine_exchangeCapabilities",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/engine_exchangeTransitionConfigurationV1/engine_exchangeTransitionConfigurationV1.ts
import { FunctionNotImplemented as FunctionNotImplemented32 } from "@vechain/sdk-errors";
var engineExchangeTransitionConfigurationV1 = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented32(
    "engine_exchangeTransitionConfigurationV1",
    'Method "engine_exchangeTransitionConfigurationV1" has not been implemented yet.',
    {
      functionName: "engine_exchangeTransitionConfigurationV1",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/engine_forkchoiceUpdatedV1/engine_forkchoiceUpdatedV1.ts
import { FunctionNotImplemented as FunctionNotImplemented33 } from "@vechain/sdk-errors";
var engineForkchoiceUpdatedV1 = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented33(
    "engine_forkchoiceUpdatedV1",
    'Method "engine_forkchoiceUpdatedV1" has not been implemented yet.',
    {
      functionName: "engine_forkchoiceUpdatedV1",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/engine_forkchoiceUpdatedV2/engine_forkchoiceUpdatedV2.ts
import { FunctionNotImplemented as FunctionNotImplemented34 } from "@vechain/sdk-errors";
var engineForkchoiceUpdatedV2 = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented34(
    "engine_forkchoiceUpdatedV2",
    'Method "engine_forkchoiceUpdatedV2" has not been implemented yet.',
    {
      functionName: "engine_forkchoiceUpdatedV2",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/engine_forkchoiceUpdatedV3/engine_forkchoiceUpdatedV3.ts
import { FunctionNotImplemented as FunctionNotImplemented35 } from "@vechain/sdk-errors";
var engineForkchoiceUpdatedV3 = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented35(
    "engine_forkchoiceUpdatedV3",
    'Method "engine_forkchoiceUpdatedV3" has not been implemented yet.',
    {
      functionName: "engine_forkchoiceUpdatedV3",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/engine_getPayloadBodiesByHashV1/engine_getPayloadBodiesByHashV1.ts
import { FunctionNotImplemented as FunctionNotImplemented36 } from "@vechain/sdk-errors";
var engineGetPayloadBodiesByHashV1 = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented36(
    "engine_getPayloadBodiesByHashV1",
    'Method "engine_getPayloadBodiesByHashV1" has not been implemented yet.',
    {
      functionName: "engine_getPayloadBodiesByHashV1",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/engine_getPayloadBodiesByRangeV1/engine_getPayloadBodiesByRangeV1.ts
import { FunctionNotImplemented as FunctionNotImplemented37 } from "@vechain/sdk-errors";
var engineGetPayloadBodiesByRangeV1 = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented37(
    "engine_getPayloadBodiesByRangeV1",
    'Method "engine_getPayloadBodiesByRangeV1" has not been implemented yet.',
    {
      functionName: "engine_getPayloadBodiesByRangeV1",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/engine_getPayloadV1/engine_getPayloadV1.ts
import { FunctionNotImplemented as FunctionNotImplemented38 } from "@vechain/sdk-errors";
var engineGetPayloadV1 = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented38(
    "engine_getPayloadV1",
    'Method "engine_getPayloadV1" has not been implemented yet.',
    {
      functionName: "engine_getPayloadV1",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/engine_getPayloadV2/engine_getPayloadV2.ts
import { FunctionNotImplemented as FunctionNotImplemented39 } from "@vechain/sdk-errors";
var engineGetPayloadV2 = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented39(
    "engine_getPayloadV2",
    'Method "engine_getPayloadV2" has not been implemented yet.',
    {
      functionName: "engine_getPayloadV2",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/engine_getPayloadV3/engine_getPayloadV3.ts
import { FunctionNotImplemented as FunctionNotImplemented40 } from "@vechain/sdk-errors";
var engineGetPayloadV3 = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented40(
    "engine_getPayloadV3",
    'Method "engine_getPayloadV3" has not been implemented yet.',
    {
      functionName: "engine_getPayloadV3",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/engine_newPayloadV1/engine_newPayloadV1.ts
import { FunctionNotImplemented as FunctionNotImplemented41 } from "@vechain/sdk-errors";
var engineNewPayloadV1 = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented41(
    "engine_newPayloadV1",
    'Method "engine_newPayloadV1" has not been implemented yet.',
    {
      functionName: "engine_newPayloadV1",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/engine_newPayloadV2/engine_newPayloadV2.ts
import { FunctionNotImplemented as FunctionNotImplemented42 } from "@vechain/sdk-errors";
var engineNewPayloadV2 = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented42(
    "engine_newPayloadV2",
    'Method "engine_newPayloadV2" has not been implemented yet.',
    {
      functionName: "engine_newPayloadV2",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/engine_newPayloadV3/engine_newPayloadV3.ts
import { FunctionNotImplemented as FunctionNotImplemented43 } from "@vechain/sdk-errors";
var engineNewPayloadV3 = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented43(
    "engine_newPayloadV3",
    'Method "engine_newPayloadV3" has not been implemented yet.',
    {
      functionName: "engine_newPayloadV3",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_createAccessList/eth_createAccessList.ts
import { FunctionNotImplemented as FunctionNotImplemented44 } from "@vechain/sdk-errors";
var ethCreateAccessList = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented44(
    "eth_createAccessList",
    'Method "eth_createAccessList" has not been implemented yet.',
    {
      functionName: "eth_createAccessList",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getBlockReceipts/eth_getBlockReceipts.ts
import {
  JSONRPCInternalError as JSONRPCInternalError21,
  JSONRPCInvalidParams as JSONRPCInvalidParams21,
  stringifyData as stringifyData24
} from "@vechain/sdk-errors";
var ethGetBlockReceipts = async (thorClient, params) => {
  if (params.length !== 1 || typeof params[0] !== "string")
    throw new JSONRPCInvalidParams21(
      "eth_getBlockReceipts",
      -32602,
      `Invalid input params for "eth_getBlockReceipts" method. See ${RPC_DOCUMENTATION_URL} for details.`,
      { params }
    );
  try {
    const [blockNumber] = params;
    const block = await ethGetBlockByNumber(thorClient, [
      blockNumber,
      true
    ]);
    if (block === null) return null;
    const transactionsIntoTheBlock = block.transactions;
    const transactionReceipts = [];
    for (const tx of transactionsIntoTheBlock) {
      const receipt = await ethGetTransactionReceipt(thorClient, [
        tx.hash
      ]);
      transactionReceipts.push(receipt);
    }
    return transactionReceipts;
  } catch (e) {
    throw new JSONRPCInternalError21(
      "ethGetBlockReceipts()",
      -32603,
      'Method "ethGetBlockReceipts" failed.',
      {
        params: stringifyData24(params),
        url: thorClient.httpClient.baseURL,
        innerError: stringifyData24(e)
      }
    );
  }
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_getProof/eth_getProof.ts
import { FunctionNotImplemented as FunctionNotImplemented45 } from "@vechain/sdk-errors";
var ethGetProof = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented45(
    "eth_getProof",
    'Method "eth_getProof" has not been implemented yet.',
    {
      functionName: "eth_getProof",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_maxPriorityFeePerGas/eth_maxPriorityFeePerGas.ts
import { FunctionNotImplemented as FunctionNotImplemented46 } from "@vechain/sdk-errors";
var ethMaxPriorityFeePerGas = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented46(
    "eth_maxPriorityFeePerGas",
    'Method "eth_maxPriorityFeePerGas" has not been implemented yet.',
    {
      functionName: "eth_maxPriorityFeePerGas",
      thorClient,
      params
    }
  );
};

// src/provider/utils/rpc-mapper/methods-map/methods/eth_signTransaction/eth_signTransaction.ts
import { FunctionNotImplemented as FunctionNotImplemented47 } from "@vechain/sdk-errors";
var ethSignTransaction = async (thorClient, params) => {
  await Promise.resolve(0);
  throw new FunctionNotImplemented47(
    "eth_signTransaction",
    'Method "eth_signTransaction" has not been implemented yet.',
    {
      functionName: "eth_signTransaction",
      thorClient,
      params
    }
  );
};

// src/provider/providers/vechain-provider/vechain-provider.ts
import { HexInt as HexInt3 } from "@vechain/sdk-core";
var VeChainProvider = class extends EventEmitter2 {
  /**
   * Constructor for VeChainProvider
   *
   * @param thorClient - ThorClient instance.
   * @param wallet - ProviderInternalWallet instance. It is optional because the majority of the methods do not require a wallet.
   * @param enableDelegation - Enable fee delegation or not.
   * @throws {JSONRPCInvalidParams}
   *
   */
  constructor(thorClient, wallet, enableDelegation = false) {
    super();
    this.thorClient = thorClient;
    this.wallet = wallet;
    this.enableDelegation = enableDelegation;
    if (enableDelegation && wallet?.delegator === void 0) {
      throw new JSONRPCInvalidParams22(
        "VechainProvider constructor",
        -32602,
        "Delegation is enabled but the delegator is not defined. Ensure that the delegator is defined and connected to the network.",
        { wallet }
      );
    }
  }
  subscriptionManager = {
    logSubscriptions: /* @__PURE__ */ new Map(),
    currentBlockNumber: 0
  };
  /**
   * Poll instance for subscriptions
   *
   * @private
   */
  pollInstance;
  /**
   * Destroys the provider by closing the thorClient and stopping the provider poll instance if present.
   * This is because thorClient and the provider might be initialized with a polling interval.
   */
  destroy() {
    this.thorClient.destroy();
    if (this.pollInstance !== void 0) {
      this.pollInstance.stopListen();
      this.pollInstance = void 0;
    }
  }
  /**
   * This method is used to send a request to the provider.
   * Basically, it is a wrapper around the RPCMethodsMap.
   *
   * @param args - Method and parameters to be used for the request.
   * @returns The result of the request.
   * @throws {JSONRPCMethodNotFound}
   */
  async request(args) {
    if (!Object.values(RPC_METHODS).map((key) => key.toString()).includes(args.method)) {
      throw new JSONRPCMethodNotFound(
        "VeChainProvider.request()",
        -32601,
        "Method not found. Invalid RPC method given as input.",
        { method: args.method }
      );
    }
    return await RPCMethodsMap(this.thorClient, this)[args.method](
      args.params
    );
  }
  /**
   * Initializes and starts the polling mechanism for subscription events.
   * This method sets up an event poll that periodically checks for new events related to active
   * subscriptions, such as 'newHeads' or log subscriptions. When new data is available, it emits
   * these events to listeners.
   *
   * This method leverages the `Poll.createEventPoll` utility to create the polling mechanism,
   * which is then started by invoking `startListen` on the poll instance.
   */
  startSubscriptionsPolling() {
    let result = false;
    if (this.pollInstance === void 0) {
      this.pollInstance = Poll.createEventPoll(async () => {
        const data = [];
        const currentBlock = await this.getCurrentBlock();
        if (currentBlock !== null) {
          if (this.subscriptionManager.newHeadsSubscription !== void 0) {
            data.push({
              method: "eth_subscription",
              params: {
                subscription: this.subscriptionManager.newHeadsSubscription.subscriptionId,
                result: currentBlock
              }
            });
          }
          if (this.subscriptionManager.logSubscriptions.size > 0) {
            const logs = await this.getLogsRPC();
            data.push(...logs);
          }
          this.subscriptionManager.currentBlockNumber++;
        }
        return data;
      }, POLLING_INTERVAL).onData(
        (subscriptionEvents) => {
          subscriptionEvents.forEach((event) => {
            this.emit("message", event);
          });
        }
      );
      this.pollInstance.startListen();
      result = true;
    }
    return result;
  }
  /**
   * Stops the polling mechanism for subscription events.
   * This method stops the polling mechanism for subscription events, if it is active.
   *
   * @returns {boolean} A boolean indicating whether the polling mechanism was stopped.
   */
  stopSubscriptionsPolling() {
    let result = false;
    if (this.pollInstance !== void 0) {
      this.pollInstance.stopListen();
      this.pollInstance = void 0;
      result = true;
    }
    return result;
  }
  /**
   * Checks if there are active subscriptions.
   * This method checks if there are any active log subscriptions or a new heads subscription.
   *
   * @returns {boolean} A boolean indicating whether there are active subscriptions.
   */
  isThereActiveSubscriptions() {
    return this.subscriptionManager.logSubscriptions.size > 0 || this.subscriptionManager.newHeadsSubscription !== void 0;
  }
  /**
   * Returns the poll instance for subscriptions.
   */
  getPollInstance() {
    return this.pollInstance;
  }
  /**
   * Fetches logs for all active log subscriptions managed by `subscriptionManager`.
   * This method iterates over each log subscription, constructs filter options based on the
   * subscription details, and then queries for logs using these filter options.
   *
   * Each log query is performed asynchronously, and the method waits for all queries to complete
   * before returning. The result for each subscription is encapsulated in a `SubscriptionEvent`
   * object, which includes the subscription ID and the fetched logs.
   *
   * This function is intended to be called when there's a need to update or fetch the latest
   * logs for all active subscriptions, typically in response to a new block being mined or
   * at regular intervals to keep subscription data up to date.
   *
   * @returns {Promise<SubscriptionEvent[]>} A promise that resolves to an array of `SubscriptionEvent`
   * objects, each containing the subscription ID and the corresponding logs fetched for that
   * subscription. The promise resolves to an empty array if there are no active log subscriptions.
   */
  async getLogsRPC() {
    const promises = Array.from(
      this.subscriptionManager.logSubscriptions.entries()
    ).map(async ([subscriptionId, subscriptionDetails]) => {
      const currentBlock = HexInt3.of(
        this.subscriptionManager.currentBlockNumber
      ).toString();
      const filterOptions = {
        address: subscriptionDetails.options?.address,
        // Contract address to filter the logs by
        fromBlock: currentBlock,
        toBlock: currentBlock,
        topics: subscriptionDetails.options?.topics
        // Topics to filter the logs by
      };
      return {
        method: "eth_subscription",
        params: {
          subscription: subscriptionId,
          // Subscription ID
          result: await ethGetLogs(this.thorClient, [filterOptions])
          // The actual log data fetched from Ethereum node
        }
      };
    });
    const subscriptionEvents = await Promise.all(promises);
    return subscriptionEvents.filter(
      (event) => event.params.result.length > 0
    );
  }
  /**
   * Fetches the current block details from the VeChain node.
   *
   * @private
   */
  async getCurrentBlock() {
    let result = null;
    if (this.isThereActiveSubscriptions()) {
      const block = await this.thorClient.blocks.getBlockCompressed(
        this.subscriptionManager.currentBlockNumber
      );
      if (block !== void 0 && block !== null) {
        result = block;
      }
    }
    return result;
  }
  /**
   * Get a signer into the internal wallet provider
   * for the given address.
   *
   * @param addressOrIndex - Address of index of the account.
   * @returns The signer for the given address.
   */
  async getSigner(addressOrIndex) {
    if (this.wallet === void 0) {
      return null;
    }
    return await this.wallet?.getSigner(this, addressOrIndex);
  }
  /**
   * Use vet.domains to resolve name to address
   * @param vnsName - The name to resolve
   * @returns the address for a name or null
   */
  async resolveName(vnsName) {
    return await vnsUtils.resolveName(this.thorClient, vnsName);
  }
  /**
   * Use vet.domains to look up a verified primary name for an address
   * @param address - The address to lookup
   * @returns the primary name for an address or null
   */
  async lookupAddress(address) {
    return await vnsUtils.lookupAddress(this.thorClient, address);
  }
};

// src/provider/providers/hardhat-provider/hardhat-provider.ts
import { JSONRPCInternalError as JSONRPCInternalError22, stringifyData as stringifyData25 } from "@vechain/sdk-errors";
import { VeChainSDKLogger } from "@vechain/sdk-logging";
var HardhatVeChainProvider = class extends VeChainProvider {
  /**
   * Debug mode.
   */
  debug;
  /**
   * The function to use to build Hardhat errors.
   */
  buildHardhatErrorFunctionCallback;
  /**
   * Constructor with the network configuration.
   *
   * @param walletToUse - The wallet to use.
   * @param nodeUrl - The node url to use
   * @param buildHardhatErrorFunctionCallback - The function to use to build Hardhat errors.
   * @param debug - Debug mode.
   * @param enableDelegation - Enable fee delegation or not.
   */
  constructor(walletToUse, nodeUrl, buildHardhatErrorFunctionCallback, debug = false, enableDelegation = false) {
    super(
      new ThorClient(new HttpClient(nodeUrl)),
      walletToUse,
      enableDelegation
    );
    this.debug = debug;
    this.buildHardhatErrorFunctionCallback = buildHardhatErrorFunctionCallback;
  }
  /**
   * Overload off the send method
   *
   * @param method - The method to call.
   * @param params - The parameters to pass to the method.
   */
  async send(method, params) {
    return await this.request({
      method,
      params
    });
  }
  /**
   * Overload off the sendAsync method.
   * It is the same of the send method, but with a callback.
   * Instead of returning the result, it calls the callback with the result.
   *
   * @param payload - The request payload (it contains method and params as 'send' method).
   * @param callback - The callback to call with the result.
   */
  async sendAsync(payload, callback) {
    try {
      const result = await this.request({
        method: payload.method,
        params: payload.params
      });
      callback(null, {
        id: payload.id,
        jsonrpc: "2.0",
        result
      });
    } catch (e) {
      callback(e, {
        id: payload.id,
        jsonrpc: "2.0"
      });
    }
  }
  /**
   * It sends the request through the VeChainProvider.
   *
   * @param args - The request arguments.
   */
  async request(args) {
    try {
      if (this.debug) {
        const accounts = await this.wallet.getAddresses();
        const delegator = await this.wallet.getDelegator();
        VeChainSDKLogger("log").log({
          title: `Sending request - ${args.method}`,
          messages: [
            `params: ${stringifyData25(args.params)}`,
            `accounts: ${stringifyData25(accounts)}`,
            `delegator: ${stringifyData25(delegator)}`,
            `url: ${this.thorClient.httpClient.baseURL}`
          ]
        });
      }
      const result = await super.request({
        method: args.method,
        params: args.params
      });
      if (this.debug) {
        VeChainSDKLogger("log").log({
          title: `Get request - ${args.method} result`,
          messages: [`result: ${stringifyData25(result)}`]
        });
      }
      return result;
    } catch (e) {
      if (this.debug) {
        VeChainSDKLogger("error").log(
          new JSONRPCInternalError22(
            args.method,
            -32603,
            `Error on request - ${args.method}`,
            {
              args
            }
          )
        );
      }
      throw this.buildHardhatErrorFunctionCallback(
        `Error on request - ${args.method}`,
        e
      );
    }
  }
};
export {
  AccountsModule,
  BUILT_IN_CONTRACTS,
  BlocksModule,
  CHAIN_ID,
  Contract,
  ContractFactory,
  ContractsModule,
  DEFAULT_HTTP_TIMEOUT,
  DebugModule,
  DelegationHandler,
  ERROR_SELECTOR,
  GasModule,
  HTTPS_REGEX,
  HTTP_REGEX,
  HardhatVeChainProvider,
  HttpClient,
  JSONRPCEthersProvider,
  LogsModule,
  MAINNET_URL,
  NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS,
  NodesModule,
  PANIC_SELECTOR,
  POLLING_INTERVAL,
  Poll,
  ProviderInternalBaseWallet,
  ProviderInternalHDWallet,
  RPCMethodsMap,
  RPC_DOCUMENTATION_URL,
  RPC_METHODS,
  TESTNET_URL,
  THOR_SOLO_ACCOUNTS,
  THOR_SOLO_URL,
  ThorClient,
  TransactionsModule,
  VeChainAbstractSigner,
  VeChainPrivateKeySigner,
  VeChainProvider,
  blocksFormatter,
  buildQuery,
  debugFormatter,
  debugGetBadBlocks,
  debugGetRawBlock,
  debugGetRawHeader,
  debugGetRawReceipts,
  debugGetRawTransaction,
  debugTraceCall,
  debugTraceTransaction,
  engineExchangeCapabilities,
  engineExchangeTransitionConfigurationV1,
  engineForkchoiceUpdatedV1,
  engineForkchoiceUpdatedV2,
  engineForkchoiceUpdatedV3,
  engineGetPayloadBodiesByHashV1,
  engineGetPayloadBodiesByRangeV1,
  engineGetPayloadV1,
  engineGetPayloadV2,
  engineGetPayloadV3,
  engineNewPayloadV1,
  engineNewPayloadV2,
  engineNewPayloadV3,
  ethAccounts,
  ethBlockNumber,
  ethCall,
  ethChainId,
  ethCoinbase,
  ethCreateAccessList,
  ethEstimateGas,
  ethFeeHistory,
  ethGasPrice,
  ethGetBalance,
  ethGetBlockByHash,
  ethGetBlockByNumber,
  ethGetBlockReceipts,
  ethGetBlockTransactionCountByHash,
  ethGetBlockTransactionCountByNumber,
  ethGetCode,
  ethGetFilterChanges,
  ethGetFilterLogs,
  ethGetLogs,
  ethGetProof,
  ethGetStorageAt,
  ethGetTransactionByBlockHashAndIndex,
  ethGetTransactionByBlockNumberAndIndex,
  ethGetTransactionByHash,
  ethGetTransactionCount,
  ethGetTransactionReceipt,
  ethGetUncleByBlockHashAndIndex,
  ethGetUncleByBlockNumberAndIndex,
  ethGetUncleCountByBlockHash,
  ethGetUncleCountByBlockNumber,
  ethGetWork,
  ethHashrate,
  ethMaxPriorityFeePerGas,
  ethMining,
  ethNewBlockFilter,
  ethNewFilter,
  ethNewPendingTransactionFilter,
  ethProtocolVersion,
  ethSendRawTransaction,
  ethSendTransaction,
  ethSign,
  ethSignTransaction,
  ethSubmitWork,
  ethSubscribe,
  ethSyncing,
  ethUninstallFilter,
  ethUnsubscribe,
  evmMine,
  formatToLogsRPC,
  formatToRPCStandard3 as formatToRPCStandard,
  getCorrectBlockNumberRPCToVeChain,
  getCriteriaSetForInput,
  getNumberOfLogsAheadOfTransactionIntoBlockExpanded,
  getTransactionIndexIntoBlock,
  netListening,
  netPeerCount,
  netVersion,
  network_exports as network,
  parityNextNonce,
  sanitizeWebsocketBaseURL,
  signerUtils,
  subscriptions,
  thorest,
  toQueryString,
  transactionsFormatter,
  vnsUtils,
  web3ClientVersion
};
/*! Bundled license information:

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
